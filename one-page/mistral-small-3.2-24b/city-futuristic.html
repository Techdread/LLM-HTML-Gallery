<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Futuristic Cityscape Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }

        label {
            display: inline-block;
            width: 120px;
        }

        input {
            width: 100px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <label for="gridSize">Grid Size:</label>
        <input type="range" id="gridSize" min="1" max="10" value="5"><br>
        <label for="citySize">City Size:</label>
        <input type="range" id="citySize" min="1" max="10" value="5"><br>
        <label for="vehicleCount">Vehicle Count:</label>
        <input type="range" id="vehicleCount" min="1" max="50" value="10"><br>
        <label for="timeOfDay">Time of Day:</label>
        <input type="range" id="timeOfDay" min="0" max="24" value="12"><br>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
      }
    }
  </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';

        let scene, camera, renderer, controls, clock;
        let city, vehicles, timeOfDay = 12;
        let gridSize = 5, citySize = 5, vehicleCount = 10;

        init();
        animate();

        function init() {
            // Create scene, camera, renderer
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 50, 50);
            clock = new THREE.Clock();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // OrbitControls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;

            // Resize listener
            window.addEventListener('resize', onWindowResize, false);

            // UI event listeners
            document.getElementById('gridSize').addEventListener('input', onGridSizeChange);
            document.getElementById('citySize').addEventListener('input', onCitySizeChange);
            document.getElementById('vehicleCount').addEventListener('input', onVehicleCountChange);
            document.getElementById('timeOfDay').addEventListener('input', onTimeOfDayChange);

            // Create city
            createCity();

            // Create vehicles
            createVehicles();

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            // Add directional light (sun)
            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(100, 100, 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
        }

        function createCity() {
            // Clear previous city
            if (city) {
                scene.remove(city);
            }

            city = new THREE.Group();

            const noise = new ImprovedNoise();
            const size = citySize * 10;
            const grid = gridSize * 10;

            for (let i = 0; i < grid; i++) {
                for (let j = 0; j < grid; j++) {
                    const x = i * size / grid - size / 2;
                    const z = j * size / grid - size / 2;

                    // Generate random building height and type
                    const height = Math.random() * 20 + 5;
                    const type = Math.floor(Math.random() * 3);

                    // Create building geometry
                    let geometry;
                    switch (type) {
                        case 0:
                            geometry = new THREE.BoxGeometry(5, height, 5);
                            break;
                        case 1:
                            geometry = new THREE.CylinderGeometry(2.5, 2.5, height, 8);
                            break;
                        case 2:
                            geometry = new THREE.ConeGeometry(2.5, height, 8);
                            break;
                    }

                    // Create building material
                    const color = new THREE.Color();
                    color.setHSL(Math.random(), 0.5, 0.5);
                    const material = new THREE.MeshPhongMaterial({ color: color });
                    const building = new THREE.Mesh(geometry, material);
                    building.position.set(x, height / 2, z);
                    building.castShadow = true;
                    building.receiveShadow = true;
                    city.add(building);

                    // Add some random parks and beaches
                    if (Math.random() > 0.8) {
                        const park = new THREE.Mesh(
                            new THREE.PlaneGeometry(10, 10),
                            new THREE.MeshPhongMaterial({ color: 0x3a5f0b })
                        );
                        park.position.set(x, 0, z);
                        park.rotation.x = -Math.PI / 2;
                        park.receiveShadow = true;
                        city.add(park);
                    } else if (Math.random() > 0.8) {
                        const beach = new THREE.Mesh(
                            new THREE.PlaneGeometry(10, 10),
                            new THREE.MeshPhongMaterial({ color: 0xe6b800 })
                        );
                        beach.position.set(x, 0, z);
                        beach.rotation.x = -Math.PI / 2;
                        beach.receiveShadow = true;
                        city.add(beach);
                    }
                }
            }

            scene.add(city);
        }

        function createVehicles() {
            // Clear previous vehicles
            if (vehicles) {
                scene.remove(vehicles);
            }

            vehicles = new THREE.Group();

            for (let i = 0; i < vehicleCount; i++) {
                // Load vehicle model (placeholder: use a simple geometry)
                const vehicle = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 16, 16),
                    new THREE.MeshPhongMaterial({ color: 0xff0000 })
                );
                vehicle.position.set(
                    Math.random() * citySize * 10 - citySize * 5,
                    Math.random() * 20 + 10,
                    Math.random() * citySize * 10 - citySize * 5
                );
                vehicle.castShadow = true;
                vehicles.add(vehicle);

                // Create vehicle path
                const path = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(
                        Math.random() * citySize * 10 - citySize * 5,
                        Math.random() * 20 + 10,
                        Math.random() * citySize * 10 - citySize * 5
                    ),
                    new THREE.Vector3(
                        Math.random() * citySize * 10 - citySize * 5,
                        Math.random() * 20 + 10,
                        Math.random() * citySize * 10 - citySize * 5
                    ),
                    new THREE.Vector3(
                        Math.random() * citySize * 10 - citySize * 5,
                        Math.random() * 20 + 10,
                        Math.random() * citySize * 10 - citySize * 5
                    )
                ]);
                vehicle.userData.path = path;
                vehicle.userData.progress = 0;
            }

            scene.add(vehicles);
        }

        function onGridSizeChange(event) {
            gridSize = parseInt(event.target.value);
            createCity();
        }

        function onCitySizeChange(event) {
            citySize = parseInt(event.target.value);
            createCity();
            createVehicles();
        }

        function onVehicleCountChange(event) {
            vehicleCount = parseInt(event.target.value);
            createVehicles();
        }

        function onTimeOfDayChange(event) {
            timeOfDay = parseInt(event.target.value);
            updateLighting();
        }

        function updateLighting() {
            const sunLight = scene.children.find(child => child instanceof THREE.DirectionalLight);
            if (sunLight) {
                const hour = timeOfDay;
                const minute = (hour - Math.floor(hour)) * 60;

                const sunPosition = new THREE.Vector3();
                sunPosition.setFromSphericalCoords(
                    1,
                    (90 - hour * 15 - minute / 2) * Math.PI / 180,
                    0
                );
                sunLight.position.copy(sunPosition);
                sunLight.position.multiplyScalar(100);

                // Adjust light intensity based on time of day
                sunLight.intensity = 1 - Math.abs(hour - 12) / 12 * 0.8;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Update vehicles
            vehicles.children.forEach(vehicle => {
                const path = vehicle.userData.path;
                const progress = vehicle.userData.progress;
                const point = path.getPointAt(progress);
                vehicle.position.copy(point);

                vehicle.userData.progress += delta * 0.5;
                if (vehicle.userData.progress > 1) {
                    vehicle.userData.progress = 0;
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>