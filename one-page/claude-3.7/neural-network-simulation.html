<!DOCTYPE html>
<html>
<head>
  <title>3D Neural Network Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
    }
    #controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
    }
    button {
      margin: 5px;
      padding: 5px 10px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="info">
    <h2>Neural Network Simulation</h2>
    <p>Click and drag to rotate. Scroll to zoom.</p>
    <p>Click on a node to fire it.</p>
  </div>
  
  <div id="controls">
    <button id="randomFire">Fire Random Node</button>
    <button id="resetNetwork">Reset Network</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Main variables
    let scene, camera, renderer;
    let nodes = [];
    let connections = [];
    let signals = [];
    
    // Initialize
    init();
    animate();
    
    function init() {
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111827);
      
      // Create camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 40;
      
      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Add lights
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 10, 10);
      scene.add(directionalLight);
      
      // Create neural network
      createNetwork(4, 5);
      
      // Setup controls
      setupMouseControls();
      
      // Setup UI controls
      document.getElementById('randomFire').addEventListener('click', fireRandomNode);
      document.getElementById('resetNetwork').addEventListener('click', resetNetwork);
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }
    
    function createNetwork(layers, nodesPerLayer) {
      const layerDistance = 15;
      
      // Create nodes in layers
      for (let layer = 0; layer < layers; layer++) {
        const layerNodes = [];
        const nodesInThisLayer = layer === 0 || layer === layers - 1 ? nodesPerLayer : nodesPerLayer + Math.floor(Math.random() * 3) - 1;
        
        for (let i = 0; i < nodesInThisLayer; i++) {
          // Position nodes in a grid pattern
          const x = (layer - (layers - 1) / 2) * layerDistance;
          const y = (i - (nodesInThisLayer - 1) / 2) * 8;
          const z = 0;
          
          const node = createNode(x, y, z, `L${layer}-N${i}`);
          node.userData.layer = layer;
          node.userData.index = i;
          nodes.push(node);
          layerNodes.push(node);
        }
        
        // Connect to previous layer
        if (layer > 0) {
          const prevLayerNodes = nodes.filter(n => n.userData.layer === layer - 1);
          
          layerNodes.forEach(targetNode => {
            // Each node connects to 1-3 nodes in previous layer
            const connectionCount = 1 + Math.floor(Math.random() * 3);
            
            for (let c = 0; c < connectionCount; c++) {
              const sourceNode = prevLayerNodes[Math.floor(Math.random() * prevLayerNodes.length)];
              createConnection(sourceNode, targetNode);
            }
          });
        }
      }
    }
    
    function createNode(x, y, z, id) {
      const geometry = new THREE.SphereGeometry(1.5, 16, 16);
      const material = new THREE.MeshPhongMaterial({
        color: 0x3498db,
        emissive: 0x0,
        specular: 0xffffff,
        shininess: 30
      });
      
      const node = new THREE.Mesh(geometry, material);
      node.position.set(x, y, z);
      node.userData = {
        id: id,
        isActive: false,
        connections: []
      };
      
      scene.add(node);
      return node;
    }
    
    function createConnection(sourceNode, targetNode) {
      // Create line between nodes
      const points = [
        sourceNode.position,
        targetNode.position
      ];
      
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0x4a5568,
        opacity: 0.4,
        transparent: true
      });
      
      const connection = new THREE.Line(geometry, material);
      connection.userData = {
        sourceId: sourceNode.userData.id,
        targetId: targetNode.userData.id
      };
      
      // Store connection references
      sourceNode.userData.connections.push(targetNode.userData.id);
      targetNode.userData.connections.push(sourceNode.userData.id);
      
      scene.add(connection);
      connections.push(connection);
      
      return connection;
    }
    
    function fireNode(node, strength = 1.0) {
      if (node.userData.isActive) return;
      
      // Activate node
      node.userData.isActive = true;
      
      // Visual effect
      const originalColor = node.material.color.clone();
      const originalEmissive = node.material.emissive.clone();
      const originalScale = node.scale.clone();
      
      // Change color to orange/yellow
      node.material.color.set(0xf39c12);
      node.material.emissive.set(0x663300);
      
      // Scale up
      node.scale.set(1.3, 1.3, 1.3);
      
      // Propagate to connected nodes in next layer
      const currentLayer = node.userData.layer;
      
      // Find connected nodes in next layer
      const connectedNodeIds = node.userData.connections;
      connectedNodeIds.forEach(targetId => {
        const targetNode = nodes.find(n => n.userData.id === targetId);
        
        if (targetNode && targetNode.userData.layer > currentLayer) {
          // Create visual signal
          createSignal(node, targetNode, strength);
          
          // Schedule target firing with delay
          setTimeout(() => {
            if (strength > 0.2) { // Only fire if signal is strong enough
              fireNode(targetNode, strength * 0.8);
            }
          }, 500);
        }
      });
      
      // Reset node after delay
      setTimeout(() => {
        // Reset color and scale
        node.material.color.copy(originalColor);
        node.material.emissive.copy(originalEmissive);
        node.scale.copy(originalScale);
        node.userData.isActive = false;
      }, 1000);
    }
    
    function createSignal(sourceNode, targetNode, strength = 1.0) {
      // Create a glowing pulse that travels from source to target
      const signalGeometry = new THREE.SphereGeometry(0.5, 8, 8);
      const signalMaterial = new THREE.MeshBasicMaterial({
        color: 0xffaa00,
        transparent: true,
        opacity: 0.8
      });
      
      const signal = new THREE.Mesh(signalGeometry, signalMaterial);
      
      // Set initial position at source node
      signal.position.copy(sourceNode.position);
      
      signal.userData = {
        sourcePos: sourceNode.position.clone(),
        targetPos: targetNode.position.clone(),
        progress: 0,
        speed: 0.02,
        strength: strength
      };
      
      scene.add(signal);
      signals.push(signal);
      
      return signal;
    }
    
    function updateSignals() {
      // Update all active signals
      for (let i = signals.length - 1; i >= 0; i--) {
        const signal = signals[i];
        
        // Update progress
        signal.userData.progress += signal.userData.speed;
        
        // Update position
        signal.position.lerpVectors(
          signal.userData.sourcePos,
          signal.userData.targetPos,
          signal.userData.progress
        );
        
        // Update color based on strength
        signal.material.color.setHSL(0.1, 0.8, 0.5 * signal.userData.strength + 0.3);
        
        // Remove if complete
        if (signal.userData.progress >= 1) {
          scene.remove(signal);
          signals.splice(i, 1);
        }
      }
    }
    
    function fireRandomNode() {
      // Find all input layer nodes (layer 0)
      const inputNodes = nodes.filter(node => node.userData.layer === 0);
      
      if (inputNodes.length > 0) {
        // Pick a random input node
        const randomNode = inputNodes[Math.floor(Math.random() * inputNodes.length)];
        fireNode(randomNode);
      }
    }
    
    function resetNetwork() {
      // Reset all nodes
      nodes.forEach(node => {
        node.userData.isActive = false;
        node.material.color.set(0x3498db);
        node.material.emissive.set(0x0);
        node.scale.set(1, 1, 1);
      });
      
      // Remove all signals
      for (let i = signals.length - 1; i >= 0; i--) {
        scene.remove(signals[i]);
      }
      signals = [];
    }
    
    // Mouse controls
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    
    function setupMouseControls() {
      // Mouse drag for rotation
      renderer.domElement.addEventListener('mousedown', e => {
        isDragging = true;
        previousMousePosition = {
          x: e.clientX,
          y: e.clientY
        };
      });
      
      renderer.domElement.addEventListener('mouseup', () => {
        isDragging = false;
      });
      
      renderer.domElement.addEventListener('mousemove', e => {
        if (isDragging) {
          const deltaX = e.clientX - previousMousePosition.x;
          const deltaY = e.clientY - previousMousePosition.y;
          
          scene.rotation.y += deltaX * 0.01;
          scene.rotation.x += deltaY * 0.01;
          
          previousMousePosition = {
            x: e.clientX,
            y: e.clientY
          };
        }
      });
      
      // Mouse wheel for zoom
      renderer.domElement.addEventListener('wheel', e => {
        const zoomSpeed = 0.1;
        if (e.deltaY > 0) {
          camera.position.z += zoomSpeed * 5;
        } else {
          camera.position.z -= zoomSpeed * 5;
        }
        // Limit zoom
        camera.position.z = Math.max(10, Math.min(100, camera.position.z));
      });
      
      // Click to fire nodes
      renderer.domElement.addEventListener('click', e => {
        // Calculate mouse position in normalized device coordinates
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        
        // Update the picking ray
        raycaster.setFromCamera(mouse, camera);
        
        // Calculate objects intersecting the picking ray
        const intersects = raycaster.intersectObjects(nodes);
        
        if (intersects.length > 0) {
          // Fire the first intersected node
          fireNode(intersects[0].object);
        }
      });
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Update signals
      updateSignals();
      
      // Render scene
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>