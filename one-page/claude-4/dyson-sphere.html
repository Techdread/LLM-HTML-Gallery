<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Dyson Sphere Construction Simulator</title>
    <style>
        body {
            margin: 0;
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 20px;
            color: #00ffff;
            min-width: 300px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .slider {
            width: 100%;
            height: 5px;
            border-radius: 5px;
            background: #002040;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #00ffff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .button {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .button:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .button.active {
            background: rgba(0, 255, 255, 0.6);
        }

        .stats {
            background: rgba(0, 40, 80, 0.9);
            border: 1px solid #0080ff;
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
            font-size: 11px;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #002040;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0080ff);
            width: 0%;
            transition: width 0.2s ease;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .checkbox {
            margin-right: 10px;
            width: 15px;
            height: 15px;
        }
    </style>
</head>

<body>
    <div class="ui-panel">
        <h3 style="margin-top: 0; text-align: center; color: #00ffff;">DYSON SPHERE CONSTRUCTOR</h3>

        <div class="control-group">
            <button id="playPause" class="button">START CONSTRUCTION</button>
            <button id="reset" class="button">RESET</button>
        </div>

        <div class="control-group">
            <label for="progressSlider">Construction Progress</label>
            <input type="range" id="progressSlider" class="slider" min="0" max="100" value="0">
        </div>

        <div class="control-group">
            <label for="brightnessSlider">Star Brightness</label>
            <input type="range" id="brightnessSlider" class="slider" min="0.2" max="3" value="1" step="0.1">
        </div>

        <div class="control-group">
            <label for="speedSlider">Construction Speed</label>
            <input type="range" id="speedSlider" class="slider" min="0.1" max="5" value="1" step="0.1">
        </div>

        <div class="checkbox-container">
            <input type="checkbox" id="showCollectors" class="checkbox" checked>
            <label for="showCollectors">Show Solar Collectors</label>
        </div>

        <div class="checkbox-container">
            <input type="checkbox" id="animateCollectors" class="checkbox" checked>
            <label for="animateCollectors">Animate Collectors</label>
        </div>

        <div class="stats">
            <div class="stats-row">
                <span>Completion:</span>
                <span id="completionPercent">0%</span>
            </div>
            <div class="stats-row">
                <span>Collectors Built:</span>
                <span id="collectorsBuilt">0 / 2000</span>
            </div>
            <div class="stats-row">
                <span>Est. Time Remaining:</span>
                <span id="timeRemaining">âˆž</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let star, starGlow, corona, dysonSphere;
        let collectors = [];
        let sunspots = [];
        let isConstructing = false;
        let constructionProgress = 0;
        let constructionSpeed = 1;
        let animationId;

        const TOTAL_COLLECTORS = 2000;
        const DYSON_RADIUS = 8;
        const STAR_RADIUS = 2;

        // UI Elements
        const playPauseBtn = document.getElementById('playPause');
        const resetBtn = document.getElementById('reset');
        const progressSlider = document.getElementById('progressSlider');
        const brightnessSlider = document.getElementById('brightnessSlider');
        const speedSlider = document.getElementById('speedSlider');
        const showCollectorsCheckbox = document.getElementById('showCollectors');
        const animateCollectorsCheckbox = document.getElementById('animateCollectors');
        const completionPercent = document.getElementById('completionPercent');
        const collectorsBuilt = document.getElementById('collectorsBuilt');
        const timeRemaining = document.getElementById('timeRemaining');
        const progressFill = document.getElementById('progressFill');

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000511);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 10, 15);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // OrbitControls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;

            // Create star system
            createStar();
            createDysonSphere();

            // Add ambient lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.1);
            scene.add(ambientLight);

            setupEventListeners();
            updateStats();
        }

        function createStar() {
            // Main star body
            const starGeometry = new THREE.SphereGeometry(STAR_RADIUS, 64, 64);
            const starMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    brightness: { value: 1.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float brightness;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    
                    float noise(vec2 p) {
                        return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                    }
                    
                    void main() {
                        vec2 uv = vUv;
                        float n1 = noise(uv * 10.0 + time * 0.5);
                        float n2 = noise(uv * 20.0 - time * 0.3);
                        float pattern = n1 * 0.5 + n2 * 0.3;
                        
                        vec3 orange = vec3(1.0, 0.4, 0.1);
                        vec3 yellow = vec3(1.0, 0.8, 0.2);
                        vec3 color = mix(orange, yellow, pattern);
                        
                        // Add sunspots
                        float spots = smoothstep(0.7, 0.9, noise(uv * 5.0 + time * 0.1));
                        color *= (1.0 - spots * 0.3);
                        
                        gl_FragColor = vec4(color * brightness, 1.0);
                    }
                `
            });

            star = new THREE.Mesh(starGeometry, starMaterial);
            scene.add(star);

            // Star glow effect
            const glowGeometry = new THREE.SphereGeometry(STAR_RADIUS * 1.2, 32, 32);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    brightness: { value: 1.0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float brightness;
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                        gl_FragColor = vec4(1.0, 0.6, 0.2, 1.0) * intensity * brightness * 0.5;
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });

            starGlow = new THREE.Mesh(glowGeometry, glowMaterial);
            scene.add(starGlow);

            // Corona particles
            const coronaGeometry = new THREE.BufferGeometry();
            const coronaPositions = [];
            const coronaColors = [];

            for (let i = 0; i < 500; i++) {
                const radius = STAR_RADIUS + Math.random() * 2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                coronaPositions.push(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                );

                const intensity = Math.random();
                coronaColors.push(1, 0.6 + intensity * 0.4, 0.2 + intensity * 0.3);
            }

            coronaGeometry.setAttribute('position', new THREE.Float32BufferAttribute(coronaPositions, 3));
            coronaGeometry.setAttribute('color', new THREE.Float32BufferAttribute(coronaColors, 3));

            const coronaMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true
            });

            corona = new THREE.Points(coronaGeometry, coronaMaterial);
            scene.add(corona);
        }

        function createDysonSphere() {
            dysonSphere = new THREE.Group();
            scene.add(dysonSphere);

            // Generate collector positions using fibonacci spiral
            const positions = generateFibonacciSphere(TOTAL_COLLECTORS, DYSON_RADIUS);

            for (let i = 0; i < TOTAL_COLLECTORS; i++) {
                const collector = createSolarCollector();
                collector.position.copy(positions[i]);
                collector.lookAt(0, 0, 0);
                collector.visible = false;
                collector.userData = {
                    originalPosition: positions[i].clone(),
                    phase: Math.random() * Math.PI * 2,
                    orbitSpeed: 0.001 + Math.random() * 0.001
                };
                collectors.push(collector);
                dysonSphere.add(collector);
            }
        }

        function createSolarCollector() {
            const group = new THREE.Group();

            // Main panel
            const panelGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.02);
            const panelMaterial = new THREE.MeshLambertMaterial({
                color: 0x001122,
                emissive: 0x002244
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            group.add(panel);

            // Solar cells pattern
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 4; j++) {
                    const cellGeometry = new THREE.PlaneGeometry(0.04, 0.04);
                    const cellMaterial = new THREE.MeshLambertMaterial({
                        color: 0x003366,
                        emissive: 0x001133
                    });
                    const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                    cell.position.set(
                        (i - 2.5) * 0.05,
                        (j - 1.5) * 0.05,
                        0.011
                    );
                    group.add(cell);
                }
            }

            // Support structure
            const strutGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.1);
            const strutMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const strut = new THREE.Mesh(strutGeometry, strutMaterial);
            strut.position.z = -0.05;
            group.add(strut);

            return group;
        }

        function generateFibonacciSphere(numPoints, radius) {
            const positions = [];
            const phi = Math.PI * (3 - Math.sqrt(5)); // Golden angle

            for (let i = 0; i < numPoints; i++) {
                const y = 1 - (i / (numPoints - 1)) * 2;
                const radiusAtY = Math.sqrt(1 - y * y);
                const theta = phi * i;

                const x = Math.cos(theta) * radiusAtY;
                const z = Math.sin(theta) * radiusAtY;

                positions.push(new THREE.Vector3(x * radius, y * radius, z * radius));
            }

            return positions;
        }

        function updateConstruction() {
            const targetCollectors = Math.floor((constructionProgress / 100) * TOTAL_COLLECTORS);

            for (let i = 0; i < collectors.length; i++) {
                collectors[i].visible = showCollectorsCheckbox.checked && i < targetCollectors;
            }

            updateStats();
        }

        function updateStats() {
            const builtCollectors = Math.floor((constructionProgress / 100) * TOTAL_COLLECTORS);
            const remainingTime = isConstructing && constructionSpeed > 0 ?
                ((100 - constructionProgress) / constructionSpeed).toFixed(1) + 's' : 'âˆž';

            completionPercent.textContent = constructionProgress.toFixed(1) + '%';
            collectorsBuilt.textContent = `${builtCollectors} / ${TOTAL_COLLECTORS}`;
            timeRemaining.textContent = remainingTime;
            progressFill.style.width = constructionProgress + '%';
        }

        function setupEventListeners() {
            playPauseBtn.addEventListener('click', () => {
                isConstructing = !isConstructing;
                playPauseBtn.textContent = isConstructing ? 'STOP CONSTRUCTION' : 'START CONSTRUCTION';
                playPauseBtn.classList.toggle('active', isConstructing);
            });

            resetBtn.addEventListener('click', () => {
                constructionProgress = 0;
                progressSlider.value = 0;
                isConstructing = false;
                playPauseBtn.textContent = 'START CONSTRUCTION';
                playPauseBtn.classList.remove('active');
                updateConstruction();
            });

            progressSlider.addEventListener('input', (e) => {
                constructionProgress = parseFloat(e.target.value);
                updateConstruction();
            });

            brightnessSlider.addEventListener('input', (e) => {
                const brightness = parseFloat(e.target.value);
                star.material.uniforms.brightness.value = brightness;
                starGlow.material.uniforms.brightness.value = brightness;
            });

            speedSlider.addEventListener('input', (e) => {
                constructionSpeed = parseFloat(e.target.value);
            });

            showCollectorsCheckbox.addEventListener('change', () => {
                updateConstruction();
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // Update star animation
            star.material.uniforms.time.value = time;
            star.rotation.y = time * 0.1;

            // Animate corona
            corona.rotation.x = time * 0.05;
            corona.rotation.y = time * 0.03;

            // Construction progress
            if (isConstructing && constructionProgress < 100) {
                constructionProgress += constructionSpeed * 0.1;
                if (constructionProgress > 100) constructionProgress = 100;
                progressSlider.value = constructionProgress;
                updateConstruction();
            }

            // Animate collectors
            if (animateCollectorsCheckbox.checked) {
                collectors.forEach((collector, index) => {
                    if (collector.visible) {
                        collector.userData.phase += collector.userData.orbitSpeed;
                        const offset = new THREE.Vector3(
                            Math.sin(collector.userData.phase) * 0.1,
                            Math.cos(collector.userData.phase * 1.3) * 0.05,
                            Math.sin(collector.userData.phase * 0.7) * 0.05
                        );
                        collector.position.copy(collector.userData.originalPosition).add(offset);
                        collector.lookAt(0, 0, 0);
                    }
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>