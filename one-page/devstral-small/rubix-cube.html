<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik's Cube Simulation</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }

        #controlPanel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <div id="controlPanel">
        Cube Size: <input type="number" id="cubeSize" value="3" min="1" max="20">
        <button onclick="init(parseInt(document.getElementById('cubeSize').value))">Set Size</button>
        <br><br>
        <button onclick="scrambleCube()">Scramble</button>
        <button onclick="solveCube()">Solve</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls, cube, originalState;

        function createMaterial(color) {
            return new THREE.MeshPhongMaterial({ color: color, shininess: 100 });
        }

        function createCube(size) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const materials = [
                createMaterial(0xffffff), // top face: white
                createMaterial(0xffff00), // bottom face: yellow
                createMaterial(0xff0000), // front face: red
                createMaterial(0xffa500), // right face: orange
                createMaterial(0x0000ff), // left face: blue
                createMaterial(0x00ff00)  // back face: green
            ];

            let cubeGroup = new THREE.Group();

            const colors = ['white', 'yellow', 'red', 'orange', 'blue', 'green'];

            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    for (let z = 0; z < size; z++) {
                        const materialIndex = (x === size - 1 ? 0 :
                            (y === 0 ? 1 :
                                (z === size - 1 ? 2 :
                                    (x === 0 ? 4 :
                                        (z === 0 ? 5 : 3)))))
                        const material = materials[materialIndex];
                        const cubeElement = new THREE.Mesh(geometry, material);
                        cubeElement.position.set(x - (size / 2), y - (size / 2), z - (size / 2));
                        cubeElement.userData = { x, y, z, originalColor: materialIndex };
                        cubeGroup.add(cubeElement);
                    }
                }
            }
            return cubeGroup;
        }

        function init(size) {
            const container = document.body;
            if (!scene) {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 10;

                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                const ambientLight = new THREE.AmbientLight(0x404040, 1);
                scene.add(ambientLight);
                const pointLight = new THREE.PointLight(0xffffff, 1);
                pointLight.position.set(10, 10, 10);
                scene.add(pointLight);
            }

            if (cube) {
                scene.remove(cube);
            }
            const newCube = createCube(size);
            scene.add(newCube);
            cube = newCube;

            originalState = {
                cubes: newCube.children.map(c => ({ ...c.userData }))
            };

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function scrambleCube() {
            const moves = ['U', 'D', 'L', 'R', 'F', 'B'];

            function executeMove(move) {
                const axis = move === 'U' || move === 'D' ? 'y' :
                    move === 'L' || move === 'R' ? 'x' :
                        move === 'F' || move === 'B' ? 'z' : null;

                const layer = move === 'U' || move === 'F' || move === 'L' ? Math.max(...cube.children.map(c => c.userData[axis])) :
                    move === 'D' || move === 'B' || move === 'R' ? Math.min(...cube.children.map(c => c.userData[axis])) : 0;

                const direction = move === 'U' || move === 'F' || move === 'L' ? -1 : 1;
                cube.children.filter(c => c.userData[axis] === layer).forEach(cubeElement => {
                    let [u, v, w] = [cubeElement.userData.x, cubeElement.userData.y, cubeElement.userData.z];
                    const originalPosition = {
                        x: cubeElement.position.x,
                        y: cubeElement.position.y,
                        z: cubeElement.position.z
                    };

                    if (axis === 'x') {
                        let temp = v;
                        v = w * direction;
                        w = temp * direction;
                        cubeElement.userData.y = v;
                        cubeElement.userData.z = w;
                    } else if (axis === 'y') {
                        let temp = u;
                        u = w * direction;
                        w = temp * direction;
                        cubeElement.userData.x = u;
                        cubeElement.userData.z = w;
                    } else if (axis === 'z') {
                        let temp = u;
                        u = v * direction;
                        v = temp * direction;
                        cubeElement.userData.x = u;
                        cubeElement.userData.y = v;
                    }

                    cubeElement.position.copy(originalPosition);
                });
            }

            [1, 2, 3, 4, 5].forEach(step => {
                const randomMove = moves[Math.floor(Math.random() * 6)];
                executeMove(randomMove);
            });
        }

        function solveCube() {
            const originalStates = originalState.cubes;
            cube.children.forEach((cubeElement, index) => {
                const { x, y, z, originalColor } = originalStates[index];

                const originalPosition = {
                    x: x - cube.children.length / 2,
                    y: y - cube.children.length / 2,
                    z: z - cube.children.length / 2
                };

                cubeElement.position.lerp(
                    originalPosition,
                    0.04
                );
            });

            setTimeout(solveCube, 20);
        }

        window.onload = function () {
            init(parseInt(document.getElementById('cubeSize').value));
        };
    </script>
</body>

</html>