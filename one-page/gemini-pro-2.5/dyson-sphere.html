<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dyson Sphere Construction Simulator</title>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #111;
            color: #eee;
            overflow: hidden;
            /* Prevent scrollbars from UI */
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 128, 255, 0.5);
            border: 1px solid rgba(0, 128, 255, 0.3);
            max-width: 320px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #aaa;
        }

        input[type="range"] {
            width: calc(100% - 20px);
            margin-right: 5px;
            vertical-align: middle;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
            margin-right: 5px;
            margin-bottom: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        #stats {
            margin-top: 15px;
            border-top: 1px solid #444;
            padding-top: 10px;
        }

        #stats p {
            margin: 5px 0;
            font-size: 0.85em;
            color: #ccc;
        }

        #stats span {
            font-weight: bold;
            color: #0af;
        }

        #progressPercentDisplay {
            font-size: 0.9em;
            color: #0af;
            vertical-align: middle;
        }
    </style>
</head>

<body>
    <div id="ui-container">
        <div class="control-group">
            <label for="progressSlider">Construction Progress (<span id="progressPercentDisplay">0%</span>):</label>
            <input type="range" id="progressSlider" min="0" max="1" step="0.001" value="0">
        </div>
        <button id="startStopButton">Start Construction</button>
        <button id="toggleCollectorsButton">Hide Collectors</button>
        <div class="control-group">
            <label for="starBrightnessSlider">Star Brightness:</label>
            <input type="range" id="starBrightnessSlider" min="0.2" max="3" step="0.05" value="1">
        </div>
        <div id="stats">
            <p>Completion: <span id="statCompletion">0%</span></p>
            <p>Collectors Built: <span id="statCollectors">0 / 0</span></p>
            <p>Est. Time to Full Build: <span id="statTime">-- s</span></p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, clock;
        let starMesh, coronaSprite, pointLight, ambientLight;
        let dysonSphereGroup, allCollectors = [];

        // Configuration
        const STAR_RADIUS = 1.5;
        const CORONA_SCALE = STAR_RADIUS * 2.5;
        const SUNSPOT_COUNT = 15;
        const DYSON_SPHERE_RADIUS = STAR_RADIUS * 3;
        const NUM_COLLECTORS = 600; // Number of solar collectors
        const COLLECTOR_SIZE = { width: 0.25, height: 0.4, depth: 0.05 };
        const TOTAL_CONSTRUCTION_TIME = 60; // seconds for full build

        // State
        let constructionProgress = 0;
        let isConstructing = false;
        let showCollectorsToggle = true;

        init();
        animate();

        function createCoronaTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0.1, 'rgba(255,255,220,0.8)');
            gradient.addColorStop(0.3, 'rgba(255,220,180,0.5)');
            gradient.addColorStop(0.6, 'rgba(255,200,100,0.2)');
            gradient.addColorStop(1, 'rgba(255,160,50,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510); // Dark space blue/black

            // Clock
            clock = new THREE.Clock();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, DYSON_SPHERE_RADIUS * 0.8, DYSON_SPHERE_RADIUS * 2);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // OrbitControls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = STAR_RADIUS * 2;
            controls.maxDistance = DYSON_SPHERE_RADIUS * 5;
            controls.target.set(0, 0, 0);

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.1); // Soft ambient light
            scene.add(ambientLight);

            pointLight = new THREE.PointLight(0xffddaa, 1.5, DYSON_SPHERE_RADIUS * 5, 1.5); // Star's light
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Star
            const starGeometry = new THREE.SphereGeometry(STAR_RADIUS, 64, 32);
            // Using MeshPhongMaterial for better interaction with light
            const starMaterial = new THREE.MeshPhongMaterial({
                color: 0xffff88, // Yellowish star color
                emissive: 0xffcc00, // Emits its own light
                emissiveIntensity: 1,
                shininess: 30, // Some shininess
                fog: false
            });
            starMesh = new THREE.Mesh(starGeometry, starMaterial);
            scene.add(starMesh);

            // Corona
            const coronaMaterial = new THREE.SpriteMaterial({
                map: createCoronaTexture(),
                color: 0xffcc33,
                transparent: true,
                blending: THREE.AdditiveBlending,
                opacity: 0.9,
                fog: false,
                sizeAttenuation: true
            });
            coronaSprite = new THREE.Sprite(coronaMaterial);
            coronaSprite.scale.set(CORONA_SCALE, CORONA_SCALE, 1);
            starMesh.add(coronaSprite); // Add as child to star

            // Sunspots
            const sunspotGeometry = new THREE.SphereGeometry(STAR_RADIUS * 0.05, 16, 8);
            const sunspotMaterial = new THREE.MeshBasicMaterial({ color: 0x332211, fog: false });
            for (let i = 0; i < SUNSPOT_COUNT; i++) {
                const sunspot = new THREE.Mesh(sunspotGeometry, sunspotMaterial);
                const phi = Math.random() * Math.PI * 2; // longitude
                const theta = Math.acos((Math.random() * 2) - 1); // latitude
                sunspot.position.setFromSphericalCoords(STAR_RADIUS * 1.005, phi, theta); // Slightly above surface
                sunspot.lookAt(new THREE.Vector3(0, 0, 0)); // Orient towards center
                starMesh.add(sunspot);
            }

            // Dyson Sphere Collectors
            dysonSphereGroup = new THREE.Group();
            scene.add(dysonSphereGroup);

            const collectorGeometry = new THREE.BoxGeometry(COLLECTOR_SIZE.width, COLLECTOR_SIZE.height, COLLECTOR_SIZE.depth);
            const collectorMaterial = new THREE.MeshStandardMaterial({
                color: 0x7799cc, // Bluish-metallic
                metalness: 0.9,
                roughness: 0.3,
                side: THREE.DoubleSide
            });

            const points = fibonacciSphere(NUM_COLLECTORS, DYSON_SPHERE_RADIUS);
            points.forEach(point => {
                const collector = new THREE.Mesh(collectorGeometry, collectorMaterial);
                collector.position.copy(point);
                collector.lookAt(new THREE.Vector3(0, 0, 0)); // Point towards the star
                collector.visible = false; // Initially hidden
                dysonSphereGroup.add(collector);
                allCollectors.push(collector);
            });

            document.getElementById('statCollectors').textContent = `0 / ${NUM_COLLECTORS}`;


            // UI Event Listeners
            const progressSlider = document.getElementById('progressSlider');
            progressSlider.addEventListener('input', (event) => {
                constructionProgress = parseFloat(event.target.value);
                if (isConstructing && constructionProgress < 1) { // If user scrubs while constructing, stop auto-construction
                    isConstructing = false;
                    document.getElementById('startStopButton').textContent = 'Start Construction';
                    document.getElementById('startStopButton').disabled = false;
                } else if (constructionProgress >= 1) {
                    document.getElementById('startStopButton').textContent = 'Construction Complete';
                    document.getElementById('startStopButton').disabled = true;
                    isConstructing = false;
                }
                updateCollectorsVisibility();
                updateStats();
            });

            document.getElementById('startStopButton').addEventListener('click', () => {
                if (constructionProgress >= 1) return;
                isConstructing = !isConstructing;
                document.getElementById('startStopButton').textContent = isConstructing ? 'Stop Construction' : 'Start Construction';
            });

            document.getElementById('toggleCollectorsButton').addEventListener('click', () => {
                showCollectorsToggle = !showCollectorsToggle;
                document.getElementById('toggleCollectorsButton').textContent = showCollectorsToggle ? 'Hide Collectors' : 'Show Collectors';
                updateCollectorsVisibility();
            });

            document.getElementById('starBrightnessSlider').addEventListener('input', (event) => {
                const brightness = parseFloat(event.target.value);
                starMesh.material.emissiveIntensity = brightness;
                pointLight.intensity = brightness * 1.5; // Adjust point light intensity as well
                coronaSprite.material.opacity = Math.min(0.9, brightness * 0.7); // Corona opacity tied to brightness
            });

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); // Initial call
            updateStats(); // Initial stat update
        }

        function fibonacciSphere(samples, radius) {
            const points = [];
            const phi = Math.PI * (Math.sqrt(5) - 1); // golden angle in radians

            for (let i = 0; i < samples; i++) {
                const y = 1 - (i / (samples - 1)) * 2;  // y goes from 1 to -1
                const R = Math.sqrt(1 - y * y) * radius; // radius at y

                const theta = phi * i; // golden angle increment

                const x = Math.cos(theta) * R;
                const z = Math.sin(theta) * R;

                points.push(new THREE.Vector3(x, y * radius, z));
            }
            return points;
        }

        function updateCollectorsVisibility() {
            const collectorsToShow = Math.floor(allCollectors.length * constructionProgress);
            let visibleCount = 0;
            allCollectors.forEach((collector, index) => {
                if (showCollectorsToggle && index < collectorsToShow) {
                    collector.visible = true;
                    visibleCount++;
                } else {
                    collector.visible = false;
                }
            });
            document.getElementById('statCollectors').textContent = `${visibleCount} / ${NUM_COLLECTORS}`;
        }

        function updateStats() {
            const progressPercent = Math.round(constructionProgress * 100);
            document.getElementById('progressPercentDisplay').textContent = `${progressPercent}%`;
            document.getElementById('progressSlider').value = constructionProgress; // Keep slider in sync if changed by animation

            document.getElementById('statCompletion').textContent = `${progressPercent}%`;

            // Collectors built stat is updated in updateCollectorsVisibility

            let timeToFullBuild = '-- s';
            if (constructionProgress < 1) {
                if (isConstructing) {
                    timeToFullBuild = `${Math.round(TOTAL_CONSTRUCTION_TIME * (1 - constructionProgress))} s`;
                } else {
                    timeToFullBuild = `${Math.round(TOTAL_CONSTRUCTION_TIME * (1 - constructionProgress))} s (paused)`;
                }
            } else {
                timeToFullBuild = 'Complete';
            }
            document.getElementById('statTime').textContent = timeToFullBuild;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            controls.update(); // For damping

            // Star and Corona animation
            starMesh.rotation.y += 0.0005 * deltaTime * 60; // Slow rotation for star and sunspots
            coronaSprite.rotation.z += 0.001 * deltaTime * 60; // Corona shimmers/rotates slightly differently

            // Construction progress
            if (isConstructing && constructionProgress < 1) {
                constructionProgress += (1 / TOTAL_CONSTRUCTION_TIME) * deltaTime;
                constructionProgress = Math.min(constructionProgress, 1.0);

                if (constructionProgress >= 1) {
                    constructionProgress = 1.0;
                    isConstructing = false;
                    document.getElementById('startStopButton').textContent = 'Construction Complete';
                    document.getElementById('startStopButton').disabled = true;
                }
                updateCollectorsVisibility();
                updateStats();
            }

            // Optional: Animate constructed part of Dyson Sphere
            if (dysonSphereGroup && constructionProgress > 0.01) {
                dysonSphereGroup.rotation.y += 0.00005 * deltaTime * 60 * constructionProgress; // Slower rotation, increases with completion
                dysonSphereGroup.rotation.x += 0.00002 * deltaTime * 60 * constructionProgress;
            }


            renderer.render(scene, camera);
        }

    </script>
</body>

</html>