<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Lorenz Attractor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            color: #eee;
            font-family: 'Inter', sans-serif;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(40, 40, 40, 0.8);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            max-width: 300px;
            /* Limit width on larger screens */
        }

        .control-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            margin-bottom: 4px;
            font-size: 0.9em;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: #60a5fa;
            /* Tailwind blue-400 */
        }

        input[type="range"]:hover {
            accent-color: #93c5fd;
            /* Tailwind blue-300 */
        }

        output {
            display: inline-block;
            min-width: 40px;
            /* Ensure consistent width */
            text-align: right;
            font-weight: bold;
            font-size: 0.9em;
            margin-left: 5px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 2px 5px;
            border-radius: 4px;
        }

        button {
            background-color: #3b82f6;
            /* Tailwind blue-500 */
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
            margin-top: 10px;
        }

        button:hover {
            background-color: #2563eb;
            /* Tailwind blue-600 */
        }

        /* Basic responsive adjustments */
        @media (max-width: 400px) {
            #ui-container {
                max-width: calc(100% - 20px);
                /* Adjust width for small screens */
                top: 5px;
                left: 5px;
                padding: 10px;
            }

            label,
            output,
            button {
                font-size: 0.8em;
            }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="ui-container">
        <div class="control-group">
            <label for="sigma">Sigma (σ): <output id="sigma-value">10.0</output></label>
            <input type="range" id="sigma" name="sigma" min="0.1" max="50" step="0.1" value="10">
        </div>
        <div class="control-group">
            <label for="rho">Rho (ρ): <output id="rho-value">28.0</output></label>
            <input type="range" id="rho" name="rho" min="0.1" max="100" step="0.1" value="28">
        </div>
        <div class="control-group">
            <label for="beta">Beta (β): <output id="beta-value">2.67</output></label>
            <input type="range" id="beta" name="beta" min="0.1" max="10" step="0.01" value="2.6667">
        </div>
        <div class="control-group">
            <label for="speed">Speed: <output id="speed-value">1.0</output></label>
            <input type="range" id="speed" name="speed" min="0.1" max="5" step="0.1" value="1">
        </div>
        <button id="reset-button">Reset Simulation</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let line, geometry, positions, colors;
        let currentPointIndex = 0;
        const MAX_POINTS = 15000; // Maximum number of points in the line trail
        const dt = 0.01; // Time step for integration

        // Lorenz system parameters
        let sigma = 10.0;
        let rho = 28.0;
        let beta = 8.0 / 3.0;
        let speed = 1.0; // Simulation speed multiplier

        // Current state
        let x = 0.1, y = 0, z = 0;

        // UI Elements
        const sigmaSlider = document.getElementById('sigma');
        const rhoSlider = document.getElementById('rho');
        const betaSlider = document.getElementById('beta');
        const speedSlider = document.getElementById('speed');
        const sigmaValue = document.getElementById('sigma-value');
        const rhoValue = document.getElementById('rho-value');
        const betaValue = document.getElementById('beta-value');
        const speedValue = document.getElementById('speed-value');
        const resetButton = document.getElementById('reset-button');

        function init() {
            // --- Scene Setup ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111); // Dark background

            // --- Camera Setup ---
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 50); // Position camera to view the attractor

            // --- Renderer Setup ---
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // --- Controls ---
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 500;

            // --- Line Setup ---
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(MAX_POINTS * 3); // x, y, z for each point
            colors = new Float32Array(MAX_POINTS * 3); // r, g, b for each point

            // Initialize arrays (optional, but good practice)
            positions.fill(0);
            colors.fill(0);

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));

            // Set initial draw range to 0
            geometry.setDrawRange(0, 0);

            // --- Material ---
            // Use vertex colors to create the gradient
            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                linewidth: 1.5 // Note: linewidth > 1 may not work on all platforms/drivers
            });

            // --- Line Object ---
            line = new THREE.Line(geometry, material);
            scene.add(line);

            // --- UI Event Listeners ---
            sigmaSlider.addEventListener('input', (e) => {
                sigma = parseFloat(e.target.value);
                sigmaValue.textContent = sigma.toFixed(1);
                // Consider resetting on major parameter changes if desired
                // resetSimulation();
            });
            rhoSlider.addEventListener('input', (e) => {
                rho = parseFloat(e.target.value);
                rhoValue.textContent = rho.toFixed(1);
                // resetSimulation();
            });
            betaSlider.addEventListener('input', (e) => {
                beta = parseFloat(e.target.value);
                betaValue.textContent = beta.toFixed(2);
                // resetSimulation();
            });
            speedSlider.addEventListener('input', (e) => {
                speed = parseFloat(e.target.value);
                speedValue.textContent = speed.toFixed(1);
            });
            resetButton.addEventListener('click', resetSimulation);

            // --- Initial UI Values ---
            updateUIValues();


            // --- Resize Listener ---
            window.addEventListener('resize', onWindowResize, false);

            // --- Start Animation ---
            animate();
        }

        function updateUIValues() {
            sigmaSlider.value = sigma;
            rhoSlider.value = rho;
            betaSlider.value = beta;
            speedSlider.value = speed;
            sigmaValue.textContent = sigma.toFixed(1);
            rhoValue.textContent = rho.toFixed(1);
            betaValue.textContent = beta.toFixed(2);
            speedValue.textContent = speed.toFixed(1);
        }


        function resetSimulation() {
            // Reset state variables
            x = 0.1;
            y = 0;
            z = 0;
            currentPointIndex = 0;

            // Clear geometry data
            positions.fill(0);
            colors.fill(0);

            // Update buffer attributes
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            // Reset draw range
            geometry.setDrawRange(0, 0);

            console.log("Simulation Reset");
        }

        function lorenzStep() {
            // Calculate derivatives using Euler method
            const dx = sigma * (y - x);
            const dy = x * (rho - z) - y;
            const dz = x * y - beta * z;

            // Update position
            x += dx * dt;
            y += dy * dt;
            z += dz * dt;
        }

        function addPointToLine() {
            const index = currentPointIndex % MAX_POINTS; // Wrap around the buffer
            const offset = index * 3;

            // Store new position
            positions[offset] = x;
            positions[offset + 1] = y;
            positions[offset + 2] = z;

            // Calculate color based on index (creates a gradient over the trail)
            const hue = (currentPointIndex / 50) % 1; // Cycle hue over time/points
            const color = new THREE.Color().setHSL(hue, 0.8, 0.6); // Saturation 0.8, Lightness 0.6

            colors[offset] = color.r;
            colors[offset + 1] = color.g;
            colors[offset + 2] = color.b;

            // Update the draw range
            // If we haven't filled the buffer yet, increase the count
            // Otherwise, the count stays at MAX_POINTS
            const drawCount = Math.min(currentPointIndex + 1, MAX_POINTS);
            geometry.setDrawRange(0, drawCount);

            // Tell Three.js to update the buffers
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            // Mark bounds dirty after first point added
            if (currentPointIndex === 0) {
                geometry.computeBoundingSphere(); // Important for initial rendering
            }


            currentPointIndex++;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Calculate multiple steps per frame based on speed
            const stepsPerFrame = Math.max(1, Math.round(speed * 5)); // Adjust multiplier (5) as needed
            for (let i = 0; i < stepsPerFrame; i++) {
                lorenzStep();
                addPointToLine();
            }

            controls.update(); // Required if enableDamping is true
            renderer.render(scene, camera);
        }

        // --- Run Initialization ---
        init();

    </script>
</body>

</html>