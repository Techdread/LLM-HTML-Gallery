<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Lennard-Jones Fluid/Gas Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; overflow: hidden; background-color: #f0f0f0; }
        #container { width: 100vw; height: 100vh; position: relative; }
        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 2;
            max-width: 300px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }
        #data-display {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 2;
            font-size: 0.8rem;
        }
        label { display: block; margin-bottom: 2px; font-weight: 500; font-size: 0.9rem; }
        input[type="range"], input[type="number"] { width: 100%; margin-bottom: 10px; }
        button {
            padding: 8px 12px;
            margin-right: 5px;
            margin-bottom: 5px;
            border: none;
            border-radius: 5px;
            background-color: #4a90e2;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #357abd; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        .control-group { margin-bottom: 15px; }
        h3 { font-size: 1.1rem; font-weight: 600; margin-bottom: 10px; border-bottom: 1px solid #eee; padding-bottom: 5px;}
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>

        <div id="controls">
            <h3>Controls</h3>
            <div class="control-group">
                <button id="start-pause-button">Start</button>
                <button id="reset-button">Reset</button>
            </div>

            <div class="control-group">
                <label for="num-particles">Particles: <span id="num-particles-value">100</span></label>
                <input type="range" id="num-particles" min="10" max="500" value="100" step="10">
            </div>

            <div class="control-group">
                <label for="box-size">Box Size: <span id="box-size-value">10</span></label>
                <input type="range" id="box-size" min="5" max="20" value="10" step="0.5">
            </div>

            <div class="control-group">
                <label for="temperature">Initial Temp: <span id="temperature-value">1.0</span></label>
                <input type="range" id="temperature" min="0.1" max="5.0" value="1.0" step="0.1">
            </div>

             <div class="control-group">
                <label for="epsilon">Epsilon (ε): <span id="epsilon-value">1.0</span></label>
                <input type="range" id="epsilon" min="0.1" max="5.0" value="1.0" step="0.1">
            </div>

             <div class="control-group">
                <label for="sigma">Sigma (σ): <span id="sigma-value">1.0</span></label>
                <input type="range" id="sigma" min="0.5" max="2.0" value="1.0" step="0.05">
            </div>

            <div class="control-group">
                <label for="dt">Time Step (dt): <span id="dt-value">0.005</span></label>
                <input type="range" id="dt" min="0.0001" max="0.02" value="0.005" step="0.0001">
            </div>

            <div class="control-group">
                 <label for="thermostat-toggle">Thermostat:</label>
                 <input type="checkbox" id="thermostat-toggle" checked>
                 <label for="target-temperature">Target Temp: <span id="target-temperature-value">1.0</span></label>
                 <input type="range" id="target-temperature" min="0.1" max="5.0" value="1.0" step="0.1">
            </div>
        </div>

        <div id="data-display">
            <div>Temp: <span id="current-temp">N/A</span></div>
            <div>KE: <span id="kinetic-energy">N/A</span></div>
            <div>PE: <span id="potential-energy">N/A</span></div>
            <div>Total E: <span id="total-energy">N/A</span></div>
            <div>Sim Time: <span id="sim-time">0.00</span></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let particles = [];
        let boxMesh; // To visualize the simulation box
        let simulationRunning = false;
        let simulationTime = 0;
        let animationFrameId;

        // --- Simulation Parameters (with defaults) ---
        let params = {
            numParticles: 100,
            boxSize: 10.0,
            halfBoxSize: 5.0,
            initialTemperature: 1.0,
            epsilon: 1.0, // Lennard-Jones parameter (depth of potential well)
            sigma: 1.0,   // Lennard-Jones parameter (finite distance where potential is zero)
            sigmaSq: 1.0,
            dt: 0.005,    // Time step
            cutoffRadius: 2.5, // Cutoff radius for LJ potential (usually 2.5 * sigma)
            cutoffRadiusSq: 6.25,
            particleMass: 1.0, // Assume mass = 1 for simplicity
            particleRadius: 0.15, // Visual radius in Three.js
            useThermostat: true,
            targetTemperature: 1.0,
            thermostatFrequency: 50, // Apply thermostat every N steps
            stepsSinceLastThermostat: 0
        };

        // --- DOM Elements ---
        const container = document.getElementById('container');
        const canvasContainer = document.getElementById('canvas-container');
        const startPauseButton = document.getElementById('start-pause-button');
        const resetButton = document.getElementById('reset-button');
        // Input sliders and value displays
        const numParticlesSlider = document.getElementById('num-particles');
        const numParticlesValue = document.getElementById('num-particles-value');
        const boxSizeSlider = document.getElementById('box-size');
        const boxSizeValue = document.getElementById('box-size-value');
        const temperatureSlider = document.getElementById('temperature');
        const temperatureValue = document.getElementById('temperature-value');
        const epsilonSlider = document.getElementById('epsilon');
        const epsilonValue = document.getElementById('epsilon-value');
        const sigmaSlider = document.getElementById('sigma');
        const sigmaValue = document.getElementById('sigma-value');
        const dtSlider = document.getElementById('dt');
        const dtValue = document.getElementById('dt-value');
        const thermostatToggle = document.getElementById('thermostat-toggle');
        const targetTemperatureSlider = document.getElementById('target-temperature');
        const targetTemperatureValue = document.getElementById('target-temperature-value');
        // Data display spans
        const currentTempDisplay = document.getElementById('current-temp');
        const kineticEnergyDisplay = document.getElementById('kinetic-energy');
        const potentialEnergyDisplay = document.getElementById('potential-energy');
        const totalEnergyDisplay = document.getElementById('total-energy');
        const simTimeDisplay = document.getElementById('sim-time');

        // --- Initialization ---
        function init() {
            setupThreeJS();
            setupUI();
            resetSimulation(); // Initialize particles and state
            animate();         // Start the animation loop (initially paused)
        }

        function setupThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = params.boxSize * 1.5; // Adjust initial camera distance based on box size

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            canvasContainer.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Optional damping effect
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 1;
            controls.maxDistance = 500;

            // Box visualization
            const boxGeometry = new THREE.BoxGeometry(params.boxSize, params.boxSize, params.boxSize);
            const edgesGeometry = new THREE.EdgesGeometry(boxGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
            boxMesh = new THREE.LineSegments(edgesGeometry, lineMaterial);
            scene.add(boxMesh);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function setupUI() {
            // --- Event Listeners for Controls ---
            startPauseButton.addEventListener('click', toggleSimulation);
            resetButton.addEventListener('click', resetSimulation);

            numParticlesSlider.addEventListener('input', (e) => {
                params.numParticles = parseInt(e.target.value);
                numParticlesValue.textContent = params.numParticles;
                // Requires reset
                setNeedsReset();
            });

            boxSizeSlider.addEventListener('input', (e) => {
                params.boxSize = parseFloat(e.target.value);
                params.halfBoxSize = params.boxSize / 2.0;
                boxSizeValue.textContent = params.boxSize.toFixed(1);
                // Update box visualization and camera, requires reset
                updateBoxVisualization();
                setNeedsReset();
            });

            temperatureSlider.addEventListener('input', (e) => {
                params.initialTemperature = parseFloat(e.target.value);
                temperatureValue.textContent = params.initialTemperature.toFixed(1);
                 // Requires reset for initial temp, but target temp can be changed live
                setNeedsReset();
            });

             epsilonSlider.addEventListener('input', (e) => {
                params.epsilon = parseFloat(e.target.value);
                epsilonValue.textContent = params.epsilon.toFixed(1);
                // Changing potential requires recalculating forces, but not necessarily a full reset
                // For simplicity, let's require a reset for now.
                setNeedsReset();
            });

             sigmaSlider.addEventListener('input', (e) => {
                params.sigma = parseFloat(e.target.value);
                params.sigmaSq = params.sigma * params.sigma;
                // Update cutoff based on sigma
                params.cutoffRadius = 2.5 * params.sigma;
                params.cutoffRadiusSq = params.cutoffRadius * params.cutoffRadius;
                sigmaValue.textContent = params.sigma.toFixed(2);
                // Requires reset
                setNeedsReset();
             });

            dtSlider.addEventListener('input', (e) => {
                params.dt = parseFloat(e.target.value);
                dtValue.textContent = params.dt.toExponential(1);
                // Can be changed live
            });

            thermostatToggle.addEventListener('change', (e) => {
                params.useThermostat = e.target.checked;
            });

            targetTemperatureSlider.addEventListener('input', (e) => {
                params.targetTemperature = parseFloat(e.target.value);
                targetTemperatureValue.textContent = params.targetTemperature.toFixed(1);
                // Can be changed live if thermostat is on
            });

            // Set initial values on sliders/displays
            numParticlesSlider.value = params.numParticles;
            numParticlesValue.textContent = params.numParticles;
            boxSizeSlider.value = params.boxSize;
            boxSizeValue.textContent = params.boxSize.toFixed(1);
            temperatureSlider.value = params.initialTemperature;
            temperatureValue.textContent = params.initialTemperature.toFixed(1);
            epsilonSlider.value = params.epsilon;
            epsilonValue.textContent = params.epsilon.toFixed(1);
            sigmaSlider.value = params.sigma;
            sigmaValue.textContent = params.sigma.toFixed(2);
            dtSlider.value = params.dt;
            dtValue.textContent = params.dt.toExponential(1);
            thermostatToggle.checked = params.useThermostat;
            targetTemperatureSlider.value = params.targetTemperature;
            targetTemperatureValue.textContent = params.targetTemperature.toFixed(1);
        }

        function setNeedsReset() {
            if (simulationRunning) {
                pauseSimulation();
            }
            startPauseButton.textContent = 'Start (Reset Required)';
            startPauseButton.disabled = false; // Re-enable if it was disabled
        }

        function updateBoxVisualization() {
             // Remove old box
            if (boxMesh) {
                scene.remove(boxMesh);
                boxMesh.geometry.dispose();
                boxMesh.material.dispose();
            }
             // Create new box
            const boxGeometry = new THREE.BoxGeometry(params.boxSize, params.boxSize, params.boxSize);
            const edgesGeometry = new THREE.EdgesGeometry(boxGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
            boxMesh = new THREE.LineSegments(edgesGeometry, lineMaterial);
            scene.add(boxMesh);

            // Adjust camera position slightly based on new box size
            // camera.position.z = params.boxSize * 1.5;
            controls.update(); // Important after camera changes
        }


        // --- Simulation Logic ---

        function initializeParticles() {
            // Clear existing particles
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];

            const particleGeometry = new THREE.SphereGeometry(params.particleRadius, 16, 8); // Lower segments for performance
            const particleMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 }); // Red particles

            // Attempt to place particles on a simple cubic grid
            const particlesPerSide = Math.ceil(Math.pow(params.numParticles, 1.0/3.0));
            const spacing = params.boxSize / particlesPerSide;
            let count = 0;

            for (let i = 0; i < particlesPerSide && count < params.numParticles; i++) {
                for (let j = 0; j < particlesPerSide && count < params.numParticles; j++) {
                    for (let k = 0; k < particlesPerSide && count < params.numParticles; k++) {
                        const position = new THREE.Vector3(
                            (i + 0.5) * spacing - params.halfBoxSize,
                            (j + 0.5) * spacing - params.halfBoxSize,
                            (k + 0.5) * spacing - params.halfBoxSize
                        );

                        // Add slight random offset to break perfect grid
                        position.add(new THREE.Vector3(
                            (Math.random() - 0.5) * spacing * 0.1,
                            (Math.random() - 0.5) * spacing * 0.1,
                            (Math.random() - 0.5) * spacing * 0.1
                        ));

                        // Maxwell-Boltzmann distribution for velocities (simplified)
                        // Target average kinetic energy per particle = 1.5 * T (in reduced units k_B=1)
                        const velocityScale = Math.sqrt(3 * params.initialTemperature / params.particleMass); // RMS velocity scalar
                        const velocity = new THREE.Vector3(
                            (Math.random() - 0.5),
                            (Math.random() - 0.5),
                            (Math.random() - 0.5)
                        ).normalize().multiplyScalar(velocityScale * (0.8 + Math.random() * 0.4)); // Add some randomness to magnitude


                        const mesh = new THREE.Mesh(particleGeometry, particleMaterial);
                        mesh.position.copy(position);
                        scene.add(mesh);

                        particles.push({
                            position: position,
                            velocity: velocity,
                            force: new THREE.Vector3(0, 0, 0), // Initialize force
                            mesh: mesh
                        });
                        count++;
                    }
                }
            }

             // Ensure exactly numParticles are created if grid placement resulted in fewer
            while (particles.length < params.numParticles) {
                 const position = new THREE.Vector3(
                    (Math.random() - 0.5) * params.boxSize,
                    (Math.random() - 0.5) * params.boxSize,
                    (Math.random() - 0.5) * params.boxSize
                );
                 const velocityScale = Math.sqrt(3 * params.initialTemperature / params.particleMass);
                 const velocity = new THREE.Vector3(
                    (Math.random() - 0.5),
                    (Math.random() - 0.5),
                    (Math.random() - 0.5)
                ).normalize().multiplyScalar(velocityScale * (0.8 + Math.random() * 0.4));

                 const mesh = new THREE.Mesh(particleGeometry, particleMaterial);
                 mesh.position.copy(position);
                 scene.add(mesh);
                 particles.push({
                    position: position,
                    velocity: velocity,
                    force: new THREE.Vector3(0, 0, 0),
                    mesh: mesh
                });
            }

            // Initial velocity adjustment to remove center-of-mass drift
            removeCenterOfMassVelocity();
        }

        function removeCenterOfMassVelocity() {
            if (particles.length === 0) return;
            const totalVel = new THREE.Vector3(0, 0, 0);
            particles.forEach(p => totalVel.add(p.velocity));
            totalVel.divideScalar(particles.length);
            particles.forEach(p => p.velocity.sub(totalVel));
        }


        function calculateForces() {
            let potentialEnergy = 0;
            // Reset forces
            particles.forEach(p => p.force.set(0, 0, 0));

            // Calculate pairwise forces using Lennard-Jones potential
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const pi = particles[i];
                    const pj = particles[j];

                    // Minimum image convention
                    const rij = new THREE.Vector3().subVectors(pi.position, pj.position);
                    rij.x = rij.x - params.boxSize * Math.round(rij.x / params.boxSize);
                    rij.y = rij.y - params.boxSize * Math.round(rij.y / params.boxSize);
                    rij.z = rij.z - params.boxSize * Math.round(rij.z / params.boxSize);

                    const rSq = rij.lengthSq();

                    if (rSq < params.cutoffRadiusSq && rSq > 1e-6) { // Check cutoff and avoid self-interaction
                        const r = Math.sqrt(rSq);
                        const rm2 = 1.0 / rSq; // 1/r^2
                        const rm6 = rm2 * rm2 * rm2; // 1/r^6
                        const rm12 = rm6 * rm6; // 1/r^12

                        const sigma_r_6 = Math.pow(params.sigma / r, 6);
                        const sigma_r_12 = sigma_r_6 * sigma_r_6;

                        // Lennard-Jones Potential: U(r) = 4 * eps * [(sigma/r)^12 - (sigma/r)^6]
                        const lj_potential = 4.0 * params.epsilon * (sigma_r_12 - sigma_r_6);
                        potentialEnergy += lj_potential;

                        // Lennard-Jones Force Magnitude: F(r) = -dU/dr = 24 * eps / r * [2*(sigma/r)^12 - (sigma/r)^6]
                        // Or F(r) = 48 * eps / sigma^2 * [ (sigma/r)^14 - 0.5 * (sigma/r)^8 ] * sigma^2 / r
                        // Let's use the first form, F = force_magnitude * (rij / r)
                        const forceMagnitude = 24.0 * params.epsilon / rSq * (2.0 * sigma_r_12 - sigma_r_6); // F * r

                        const forceVector = rij.multiplyScalar(forceMagnitude / rSq); // Force vector = F * (rij / r) / r = F * rij / r^2

                        pi.force.add(forceVector);
                        pj.force.sub(forceVector); // Newton's third law
                    }
                }
            }
            return potentialEnergy;
        }

        function integrateVelocityVerlet(dt) {
            const dtHalf = dt / 2.0;

            // First half-step velocity update & full step position update
            particles.forEach(p => {
                // v(t + dt/2) = v(t) + a(t) * dt / 2
                const acceleration = p.force.clone().divideScalar(params.particleMass);
                p.velocity.addScaledVector(acceleration, dtHalf);

                // x(t + dt) = x(t) + v(t + dt/2) * dt
                p.position.addScaledVector(p.velocity, dt);

                // Apply periodic boundary conditions
                applyPeriodicBoundaries(p);
            });

            // Calculate forces at new positions -> a(t + dt)
            const potentialEnergy = calculateForces();

            // Second half-step velocity update
            particles.forEach(p => {
                // v(t + dt) = v(t + dt/2) + a(t + dt) * dt / 2
                const acceleration = p.force.clone().divideScalar(params.particleMass);
                p.velocity.addScaledVector(acceleration, dtHalf);
            });

            return potentialEnergy; // Return calculated potential energy
        }

        function applyPeriodicBoundaries(particle) {
            // Wrap positions around the box boundaries
            if (particle.position.x > params.halfBoxSize) particle.position.x -= params.boxSize;
            else if (particle.position.x < -params.halfBoxSize) particle.position.x += params.boxSize;

            if (particle.position.y > params.halfBoxSize) particle.position.y -= params.boxSize;
            else if (particle.position.y < -params.halfBoxSize) particle.position.y += params.boxSize;

            if (particle.position.z > params.halfBoxSize) particle.position.z -= params.boxSize;
            else if (particle.position.z < -params.halfBoxSize) particle.position.z += params.boxSize;
        }

        function applyThermostat() {
            if (!params.useThermostat || particles.length === 0) return;

            params.stepsSinceLastThermostat++;
            if (params.stepsSinceLastThermostat >= params.thermostatFrequency) {
                const currentKE = calculateKineticEnergy();
                const currentTemp = (2.0 / 3.0) * currentKE / particles.length; // KE = (3/2) N k_B T -> T = (2/3) KE / N (with k_B=1)

                if (currentTemp > 1e-6) { // Avoid division by zero or scaling issues at very low temps
                    const scaleFactor = Math.sqrt(params.targetTemperature / currentTemp);
                    particles.forEach(p => p.velocity.multiplyScalar(scaleFactor));
                }
                 params.stepsSinceLastThermostat = 0; // Reset counter
            }
        }


        function calculateKineticEnergy() {
            let kineticEnergy = 0;
            particles.forEach(p => {
                kineticEnergy += 0.5 * params.particleMass * p.velocity.lengthSq();
            });
            return kineticEnergy;
        }

        function updateDataDisplay(kineticEnergy, potentialEnergy) {
            const totalEnergy = kineticEnergy + potentialEnergy;
            // Calculate instantaneous temperature (k_B = 1)
            const currentTemp = particles.length > 0 ? (2.0 / 3.0) * kineticEnergy / particles.length : 0;

            currentTempDisplay.textContent = currentTemp.toFixed(3);
            kineticEnergyDisplay.textContent = kineticEnergy.toFixed(3);
            potentialEnergyDisplay.textContent = potentialEnergy.toFixed(3);
            totalEnergyDisplay.textContent = totalEnergy.toFixed(3);
            simTimeDisplay.textContent = simulationTime.toFixed(3);
        }

        function simulationStep() {
            // Integrate motion using Velocity Verlet
            const potentialEnergy = integrateVelocityVerlet(params.dt);

            // Apply thermostat if enabled
            applyThermostat();

            // Calculate energies
            const kineticEnergy = calculateKineticEnergy();

            // Update simulation time
            simulationTime += params.dt;

            // Update UI display
            updateDataDisplay(kineticEnergy, potentialEnergy);

            // Update Three.js mesh positions
            particles.forEach(p => {
                p.mesh.position.copy(p.position);
            });
        }

        // --- Animation Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            if (simulationRunning) {
                // Perform multiple simulation steps per frame for stability/speedup if dt is small
                const stepsPerFrame = 1; // Adjust as needed
                for(let i=0; i<stepsPerFrame; ++i) {
                    simulationStep();
                }
            }

            controls.update(); // Update orbit controls
            renderer.render(scene, camera);
        }

        // --- Control Functions ---
        function toggleSimulation() {
            if (startPauseButton.textContent.includes('Reset Required')) {
                 resetSimulation(); // Force reset if parameters changed
                 startSimulation();
            } else if (simulationRunning) {
                pauseSimulation();
            } else {
                startSimulation();
            }
        }

        function startSimulation() {
            simulationRunning = true;
            startPauseButton.textContent = 'Pause';
            // Disable controls that require a reset
            numParticlesSlider.disabled = true;
            boxSizeSlider.disabled = true;
            temperatureSlider.disabled = true;
            epsilonSlider.disabled = true;
            sigmaSlider.disabled = true;
        }

        function pauseSimulation() {
            simulationRunning = false;
            startPauseButton.textContent = 'Resume';
            // Re-enable controls
            numParticlesSlider.disabled = false;
            boxSizeSlider.disabled = false;
            temperatureSlider.disabled = false;
            epsilonSlider.disabled = false;
            sigmaSlider.disabled = false;
        }

        function resetSimulation() {
            pauseSimulation(); // Ensure simulation is paused

            // Reset simulation state
            simulationTime = 0;
            params.stepsSinceLastThermostat = 0;

            // Re-initialize particles based on current UI settings
            initializeParticles();

            // Reset forces and calculate initial potential energy
            const initialPE = calculateForces();
            const initialKE = calculateKineticEnergy();

            // Update display
            updateDataDisplay(initialKE, initialPE);

            // Update mesh positions immediately
            particles.forEach(p => p.mesh.position.copy(p.position));

            // Reset button text and state
            startPauseButton.textContent = 'Start';
            startPauseButton.disabled = false;
            // Re-enable controls
             numParticlesSlider.disabled = false;
            boxSizeSlider.disabled = false;
            temperatureSlider.disabled = false;
            epsilonSlider.disabled = false;
            sigmaSlider.disabled = false;

             // Update box visualization in case size changed
            updateBoxVisualization();

            console.log("Simulation Reset");
        }

        // --- Window Resize ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start ---
        init();

    </script>
</body>
</html>
