<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Gravity Well Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            /* bg-gray-900 */
            color: #f3f4f6;
            /* text-gray-100 */
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(17, 24, 39, 0.8);
            /* bg-gray-900 with opacity */
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #374151;
            /* border-gray-700 */
            color: #f3f4f6;
            /* text-gray-100 */
            max-width: 300px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        #controls label,
        #controls button,
        #controls input {
            display: block;
            margin-bottom: 8px;
            font-size: 0.875rem;
            /* text-sm */
        }

        #controls input[type="range"],
        #controls input[type="number"] {
            width: 100%;
            background-color: #374151;
            /* bg-gray-700 */
            border-radius: 4px;
            padding: 2px;
            accent-color: #3b82f6;
            /* accent-blue-500 */
        }

        #controls input[type="number"] {
            padding: 4px 8px;
            border: 1px solid #4b5563;
            /* border-gray-600 */
        }

        #controls button {
            background-color: #3b82f6;
            /* bg-blue-600 */
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            width: 100%;
            margin-top: 10px;
        }

        #controls button:hover {
            background-color: #2563eb;
            /* bg-blue-700 */
        }

        #controls h3 {
            font-weight: 600;
            /* font-semibold */
            margin-bottom: 10px;
            border-bottom: 1px solid #4b5563;
            /* border-gray-600 */
            padding-bottom: 5px;
        }

        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(17, 24, 39, 0.8);
            /* bg-gray-900 with opacity */
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #374151;
            /* border-gray-700 */
            color: #d1d5db;
            /* text-gray-300 */
            font-size: 0.8rem;
            max-width: 350px;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <div id="controls">
        <h3>Controls</h3>

        <label for="massInput">Massive Object Mass (1-100):</label>
        <input type="range" id="massInput" min="1" max="100" value="20">
        <button id="addMassiveObject">Add Massive Object (Click Grid)</button>
        <p id="addMassiveObjectStatus" class="text-xs text-yellow-400 mt-1"></p>

        <hr class="border-gray-600 my-3">

        <label for="particleVelocityX">Particle Velocity X (-1 to 1):</label>
        <input type="range" id="particleVelocityX" min="-1" max="1" value="0.5" step="0.1">
        <label for="particleVelocityZ">Particle Velocity Z (-1 to 1):</label>
        <input type="range" id="particleVelocityZ" min="-1" max="1" value="0" step="0.1">
        <label for="particleSpeed">Particle Speed (0.1 - 5):</label>
        <input type="range" id="particleSpeed" min="0.1" max="5" value="1" step="0.1">
        <button id="launchParticle">Launch Particle (Click Grid)</button>
        <p id="launchParticleStatus" class="text-xs text-yellow-400 mt-1"></p>

        <hr class="border-gray-600 my-3">

        <button id="resetSimulation">Reset Simulation</button>
    </div>

    <div id="instructions">
        <strong>Instructions:</strong>
        <ul>
            <li>Orbit: Left Mouse Button + Drag</li>
            <li>Zoom: Mouse Wheel</li>
            <li>Pan: Right Mouse Button + Drag</li>
            <li>Add Massive Object: Set mass, click button, then click on the grid.</li>
            <li>Launch Particle: Set velocity/speed, click button, then click on the grid for starting position.</li>
        </ul>
    </div>

    <script type="module">
        // Ensure Three.js and OrbitControls are loaded
        if (typeof THREE === 'undefined' || typeof THREE.OrbitControls === 'undefined') {
            console.error("Three.js or OrbitControls failed to load.");
            // Display error message to user
            document.getElementById('container').innerHTML = '<p style="color: red; padding: 20px;">Error: Could not load required 3D libraries. Please check your internet connection and try refreshing.</p>';
        } else {
            // --- Global Variables ---
            let scene, camera, renderer, controls;
            let gridMesh, originalVertices;
            const massiveObjects = []; // Store { mesh: THREE.Mesh, mass: number, position: THREE.Vector3 }
            const particles = []; // Store { mesh: THREE.Mesh, velocity: THREE.Vector3, trail: THREE.Line, trailIndex: number }
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let isAddingMassiveObject = false;
            let isLaunchingParticle = false;
            const G = 0.1; // Gravitational constant (scaled for simulation)
            const timeStep = 0.05; // Simulation time step
            const GRID_SIZE = 50;
            const GRID_SEGMENTS = 50;
            const maxTrailPoints = 200; // Maximum points in a particle's trail

            // --- Initialization ---
            function init() {
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x111827); // bg-gray-900

                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 30, 30); // Position camera above the grid

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('container').appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 0.5).normalize();
                scene.add(directionalLight);

                // Grid (Spacetime Fabric)
                // PlaneGeometry is created in its local XY plane.
                // Width along X, Height along Y, Normal along Z.
                const gridGeometry = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, GRID_SEGMENTS, GRID_SEGMENTS);
                const gridMaterial = new THREE.MeshPhongMaterial({
                    color: 0x3b82f6, // blue-500
                    wireframe: true,
                    side: THREE.DoubleSide
                });
                gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);
                // Rotate to be horizontal in world XZ plane.
                // Original local X -> World X
                // Original local Y -> World Z (after rotation, -Y local becomes +Z world)
                // Original local Z -> World Y (after rotation, +Z local becomes +Y world)
                gridMesh.rotation.x = -Math.PI / 2;
                scene.add(gridMesh);

                // Store original vertices for deformation calculations
                // These are in the local coordinate system of the grid.
                // For PlaneGeometry, original z-coordinates are 0.
                originalVertices = gridGeometry.attributes.position.array.slice(); // Create a copy

                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; // Smooth camera movement
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = false; // Pan parallel to the grid plane
                controls.maxPolarAngle = Math.PI / 2 - 0.05; // Prevent camera going below grid
                controls.minDistance = 5;
                controls.maxDistance = 100;

                // Event Listeners
                window.addEventListener('resize', onWindowResize, false);
                renderer.domElement.addEventListener('click', onCanvasClick, false);
                setupUIListeners();

                // Start Animation Loop
                animate();
            }

            // --- UI Event Listeners ---
            function setupUIListeners() {
                const addMassiveObjectButton = document.getElementById('addMassiveObject');
                const launchParticleButton = document.getElementById('launchParticle');
                const resetSimulationButton = document.getElementById('resetSimulation');
                const addMassiveObjectStatus = document.getElementById('addMassiveObjectStatus');
                const launchParticleStatus = document.getElementById('launchParticleStatus');

                addMassiveObjectButton.addEventListener('click', () => {
                    isAddingMassiveObject = true;
                    isLaunchingParticle = false;
                    addMassiveObjectStatus.textContent = "Click on the grid to place the object.";
                    launchParticleStatus.textContent = "";
                    renderer.domElement.style.cursor = 'crosshair';
                });

                launchParticleButton.addEventListener('click', () => {
                    isLaunchingParticle = true;
                    isAddingMassiveObject = false;
                    launchParticleStatus.textContent = "Click on the grid for particle start position.";
                    addMassiveObjectStatus.textContent = "";
                    renderer.domElement.style.cursor = 'crosshair';
                });

                resetSimulationButton.addEventListener('click', resetSimulation);
            }

            // --- Event Handlers ---
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function onCanvasClick(event) {
                if (!isAddingMassiveObject && !isLaunchingParticle) return;

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(gridMesh);

                if (intersects.length > 0) {
                    const intersectPoint = intersects[0].point; // World coordinates

                    if (isAddingMassiveObject) {
                        addMassiveObject(intersectPoint);
                        isAddingMassiveObject = false;
                        document.getElementById('addMassiveObjectStatus').textContent = "";
                        renderer.domElement.style.cursor = 'default';
                    } else if (isLaunchingParticle) {
                        launchParticle(intersectPoint);
                        isLaunchingParticle = false;
                        document.getElementById('launchParticleStatus').textContent = "";
                        renderer.domElement.style.cursor = 'default';
                    }
                } else {
                    if (isAddingMassiveObject) document.getElementById('addMassiveObjectStatus').textContent = "Click failed. Aim for the grid.";
                    if (isLaunchingParticle) document.getElementById('launchParticleStatus').textContent = "Click failed. Aim for the grid.";
                }
            }

            // --- Object Creation ---
            function addMassiveObject(position) { // position is world coordinates from click
                const mass = parseFloat(document.getElementById('massInput').value);
                if (isNaN(mass) || mass <= 0) {
                    console.warn("Invalid mass value provided.");
                    return;
                }
                const radius = Math.cbrt(mass) * 0.3;
                const geometry = new THREE.SphereGeometry(radius, 32, 16);
                const material = new THREE.MeshPhongMaterial({ color: 0xffcc00 });
                const mesh = new THREE.Mesh(geometry, material);

                // Set mesh position in world coordinates
                mesh.position.copy(position);
                // The click 'position' y is on the grid (approx 0). Elevate sphere by its radius.
                mesh.position.y = radius;

                scene.add(mesh);
                massiveObjects.push({ mesh, mass, position: mesh.position.clone() }); // Store world position

                deformGrid();
            }

            function launchParticle(startPosition) { // startPosition is world coordinates
                const velX = parseFloat(document.getElementById('particleVelocityX').value);
                const velZ = parseFloat(document.getElementById('particleVelocityZ').value);
                const speed = parseFloat(document.getElementById('particleSpeed').value);

                if (isNaN(velX) || isNaN(velZ) || isNaN(speed) || speed <= 0) {
                    console.warn("Invalid particle velocity or speed.");
                    return;
                }

                const geometry = new THREE.SphereGeometry(0.2, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(startPosition);
                mesh.position.y = 0.5; // Start slightly above the grid's visual plane

                const velocity = new THREE.Vector3(velX, 0, velZ).normalize().multiplyScalar(speed);

                const trailMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa, linewidth: 1 });
                const trailGeometry = new THREE.BufferGeometry();
                const trailPositions = new Float32Array(maxTrailPoints * 3);
                trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
                const trail = new THREE.Line(trailGeometry, trailMaterial);
                trail.frustumCulled = false;
                scene.add(trail);

                scene.add(mesh);
                particles.push({ mesh, velocity, trail, trailIndex: 0 });
            }

            // --- Simulation Logic ---
            function deformGrid() {
                const positions = gridMesh.geometry.attributes.position; // Local coordinates
                const vertex = new THREE.Vector3(); // For local vertex calculation
                const worldVertex = new THREE.Vector3(); // For world vertex calculation

                for (let i = 0; i < positions.count; i++) {
                    // Get original local vertex (original local z is 0)
                    vertex.fromArray(originalVertices, i * 3);

                    // Transform original local vertex to world space for distance calculation
                    worldVertex.copy(vertex).applyMatrix4(gridMesh.matrixWorld);
                    // After rotation: worldX = localX, worldY = localZ, worldZ = -localY
                    // So worldVertex.y is initially 0 because original localZ is 0.

                    let totalDeformation = 0; // This will be the change in local Z, affecting world Y

                    massiveObjects.forEach(obj => {
                        // obj.position is the world position of the massive object
                        // Calculate distance in the world XZ plane (the plane of the grid)
                        const dx = worldVertex.x - obj.position.x;
                        const dz = worldVertex.z - obj.position.z; // worldVertex.z is -localY
                        const distanceSq = dx * dx + dz * dz;

                        const minDistanceSq = 0.1;
                        if (distanceSq > minDistanceSq) {
                            // Negative deformation for downward curve (negative world Y)
                            const deformation = - (G * obj.mass * 5) / distanceSq;
                            totalDeformation += Math.max(deformation, -GRID_SIZE / 4);
                        } else {
                            totalDeformation += -GRID_SIZE / 4; // Max deformation
                        }
                    });

                    // Apply deformation to the LOCAL Z-coordinate of the vertex.
                    // Original local Z (vertex.z) is 0.
                    // Since worldY = localZ (due to grid rotation), changing localZ deforms along worldY.
                    // A negative totalDeformation makes localZ negative, thus worldY negative (downwards).
                    positions.setZ(i, Math.max(vertex.z + totalDeformation, -GRID_SIZE / 2));
                }

                positions.needsUpdate = true;
                gridMesh.geometry.computeVertexNormals(); // Recalculate normals for correct lighting
            }


            function updateParticles() {
                const particlesToRemove = [];

                particles.forEach((particle, index) => {
                    const acceleration = new THREE.Vector3(0, 0, 0);

                    massiveObjects.forEach(obj => {
                        const direction = new THREE.Vector3().subVectors(obj.position, particle.mesh.position);
                        const distanceSq = direction.lengthSq();
                        const objRadius = obj.mesh.geometry.parameters.radius;
                        const minForceDistanceSq = objRadius * objRadius * 1.1;

                        if (distanceSq > minForceDistanceSq) {
                            const forceMagnitude = (G * obj.mass) / distanceSq;
                            const forceVector = direction.normalize().multiplyScalar(forceMagnitude);
                            acceleration.add(forceVector);
                        } else if (distanceSq < objRadius * objRadius) {
                            if (!particlesToRemove.includes(index)) {
                                particlesToRemove.push(index);
                            }
                        }
                    });

                    particle.velocity.add(acceleration.multiplyScalar(timeStep));
                    particle.mesh.position.add(particle.velocity.clone().multiplyScalar(timeStep));

                    if (!particlesToRemove.includes(index)) {
                        const trailPositionsAttr = particle.trail.geometry.attributes.position;
                        const currentPointIndex = (particle.trailIndex % maxTrailPoints) * 3;

                        trailPositionsAttr.array[currentPointIndex] = particle.mesh.position.x;
                        trailPositionsAttr.array[currentPointIndex + 1] = particle.mesh.position.y;
                        trailPositionsAttr.array[currentPointIndex + 2] = particle.mesh.position.z;

                        const nextPointIndex = ((particle.trailIndex + 1) % maxTrailPoints) * 3;
                        trailPositionsAttr.array[nextPointIndex] = particle.mesh.position.x;
                        trailPositionsAttr.array[nextPointIndex + 1] = particle.mesh.position.y;
                        trailPositionsAttr.array[nextPointIndex + 2] = particle.mesh.position.z;

                        particle.trailIndex++;

                        if (particle.trailIndex < maxTrailPoints) {
                            particle.trail.geometry.setDrawRange(0, particle.trailIndex + 1);
                        } else {
                            particle.trail.geometry.setDrawRange(0, maxTrailPoints);
                        }
                        trailPositionsAttr.needsUpdate = true;
                    }

                    const boundary = GRID_SIZE * 1.5;
                    if (Math.abs(particle.mesh.position.x) > boundary ||
                        Math.abs(particle.mesh.position.z) > boundary ||
                        Math.abs(particle.mesh.position.y) > boundary * 2) {
                        if (!particlesToRemove.includes(index)) {
                            particlesToRemove.push(index);
                        }
                    }
                });

                for (let i = particlesToRemove.length - 1; i >= 0; i--) {
                    const indexToRemove = particlesToRemove[i];
                    const particleToRemove = particles[indexToRemove];

                    scene.remove(particleToRemove.mesh);
                    scene.remove(particleToRemove.trail);

                    particleToRemove.mesh.geometry.dispose();
                    particleToRemove.mesh.material.dispose();
                    particleToRemove.trail.geometry.dispose();
                    particleToRemove.trail.material.dispose();

                    particles.splice(indexToRemove, 1);
                }
            }

            // --- Reset ---
            function resetSimulation() {
                massiveObjects.forEach(obj => {
                    scene.remove(obj.mesh);
                    if (obj.mesh.geometry) obj.mesh.geometry.dispose();
                    if (obj.mesh.material) obj.mesh.material.dispose();
                });
                massiveObjects.length = 0;

                particles.forEach(p => {
                    scene.remove(p.mesh);
                    scene.remove(p.trail);
                    if (p.mesh.geometry) p.mesh.geometry.dispose();
                    if (p.mesh.material) p.mesh.material.dispose();
                    if (p.trail.geometry) p.trail.geometry.dispose();
                    if (p.trail.material) p.trail.material.dispose();
                });
                particles.length = 0;

                const positions = gridMesh.geometry.attributes.position;
                positions.array.set(originalVertices); // Restore original local vertex data
                positions.needsUpdate = true;
                gridMesh.geometry.computeVertexNormals();

                isAddingMassiveObject = false;
                isLaunchingParticle = false;
                document.getElementById('addMassiveObjectStatus').textContent = "";
                document.getElementById('launchParticleStatus').textContent = "";
                renderer.domElement.style.cursor = 'default';
                console.log("Simulation Reset");
            }

            // --- Animation Loop ---
            function animate() {
                requestAnimationFrame(animate);
                updateParticles();
                controls.update();
                renderer.render(scene, camera);
            }

            // --- Start ---
            window.onload = init;
        }
    </script>
</body>

</html>