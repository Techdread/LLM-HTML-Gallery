<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Bin Packing Visualization (Step-by-Step)</title>
    <style>
        /* Basic styling for the page */
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            /* Using Inter font */
            background-color: #f0f0f0;
            /* Light gray background */
            color: #333;
            overflow: hidden;
            /* Prevent scrollbars */
        }

        canvas {
            display: block;
            /* Remove extra space below canvas */
            width: 100%;
            /* Make canvas responsive */
            height: 100%;
        }

        /* Style for the info overlay */
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px 15px;
            background-color: rgba(255, 255, 255, 0.85);
            border-radius: 8px;
            font-size: 0.9em;
            max-width: 300px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 10;
            /* Ensure it's above the canvas */
        }

        /* Style for buttons */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            font-family: 'Inter', sans-serif;
            border: none;
            border-radius: 8px;
            background-color: #4a90e2;
            /* Blue */
            color: white;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease;
        }

        button:hover {
            background-color: #357abd;
            /* Darker blue */
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        #resetButton {
            background-color: #d9534f;
            /* Red */
        }

        #resetButton:hover {
            background-color: #c9302c;
            /* Darker red */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>

<body>
    <div id="info">
        <strong>3D Bin Packing Visualization</strong><br>
        Drag to rotate, scroll to zoom.<br>
        <span id="status">Status: Ready</span>
    </div>

    <div id="controls">
        <button id="startButton">Start Packing</button>
        <button id="resetButton">Reset</button>
    </div>


    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Import necessary Three.js components
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let binMesh; // Reference to the bin wireframe
        const pieceMeshes = new THREE.Group(); // Group to hold all piece meshes
        const cornerMeshes = new THREE.Group(); // Group to hold corner visualizations
        let theBin; // The bin object
        let allPieces = []; // The initial list of all pieces
        let remainingPieces = []; // Pieces yet to be packed in the current run
        let packingTimeoutId = null; // To control the step-by-step timeout
        const packingDelay = 300; // Delay between steps in milliseconds

        const statusElement = document.getElementById('status');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        // --- 1. Data Structures (Identical to previous version) ---
        class Piece {
            constructor(id, width, height, depth, value = 0) {
                this.id = id;
                this.width = width;
                this.height = height;
                this.depth = depth;
                this.value = value;
                this.volume = width * height * depth;
                this.position = null;
                this.orientation = 0;
                this.isPlaced = false;
                // Store original dimensions for reset
                this.originalWidth = width;
                this.originalHeight = height;
                this.originalDepth = depth;
            }
            // Reset piece state
            reset() {
                this.position = null;
                this.orientation = 0;
                this.isPlaced = false;
                this.width = this.originalWidth;
                this.height = this.originalHeight;
                this.depth = this.originalDepth;
            }
        }
        class Corner {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
        }
        class Bin {
            constructor(width, height, depth) {
                this.width = width;
                this.height = height;
                this.depth = depth;
                this.volume = width * height * depth;
                this.placedPieces = [];
                this.corners = [new Corner(0, 0, 0)];
                this.epsilon = 0.0001;
            }
            reset() {
                this.placedPieces = [];
                this.corners = [new Corner(0, 0, 0)];
            }
            // --- Methods: checkPlacement, boxesOverlap, placePiece, addCornerIfNotExists, getOrientationDims ---
            // (These methods remain identical to the previous version)
            checkPlacement(piece, corner, orientation) {
                const dims = this.getOrientationDims(piece, orientation);
                if (corner.x + dims.w > this.width + this.epsilon ||
                    corner.y + dims.h > this.height + this.epsilon ||
                    corner.z + dims.d > this.depth + this.epsilon) {
                    return false;
                }
                const pieceBox = new THREE.Box3(
                    new THREE.Vector3(corner.x, corner.y, corner.z),
                    new THREE.Vector3(corner.x + dims.w, corner.y + dims.h, corner.z + dims.d)
                );
                for (const placed of this.placedPieces) {
                    const placedDims = this.getOrientationDims(placed, placed.orientation);
                    const placedBox = new THREE.Box3(
                        new THREE.Vector3(placed.position.x, placed.position.y, placed.position.z),
                        new THREE.Vector3(placed.position.x + placedDims.w, placed.position.y + placedDims.h, placed.position.z + placedDims.d)
                    );
                    if (pieceBox.intersectsBox(placedBox)) {
                        if (this.boxesOverlap(pieceBox, placedBox)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            boxesOverlap(box1, box2) {
                const overlapX = box1.max.x > box2.min.x + this.epsilon && box1.min.x < box2.max.x - this.epsilon;
                const overlapY = box1.max.y > box2.min.y + this.epsilon && box1.min.y < box2.max.y - this.epsilon;
                const overlapZ = box1.max.z > box2.min.z + this.epsilon && box1.min.z < box2.max.z - this.epsilon;
                return overlapX && overlapY && overlapZ;
            }
            placePiece(piece, corner, orientation) {
                const dims = this.getOrientationDims(piece, orientation);
                piece.position = { x: corner.x, y: corner.y, z: corner.z };
                piece.orientation = orientation;
                piece.isPlaced = true;
                this.placedPieces.push(piece);
                this.corners = this.corners.filter(c =>
                    !(Math.abs(c.x - corner.x) < this.epsilon &&
                        Math.abs(c.y - corner.y) < this.epsilon &&
                        Math.abs(c.z - corner.z) < this.epsilon)
                );
                const cornerX = new Corner(corner.x + dims.w, corner.y, corner.z);
                const cornerY = new Corner(corner.x, corner.y + dims.h, corner.z);
                const cornerZ = new Corner(corner.x, corner.y, corner.z + dims.d);
                if (cornerX.x < this.width - this.epsilon) this.addCornerIfNotExists(cornerX);
                if (cornerY.y < this.height - this.epsilon) this.addCornerIfNotExists(cornerY);
                if (cornerZ.z < this.depth - this.epsilon) this.addCornerIfNotExists(cornerZ);
                this.corners = this.corners.filter(c => {
                    const pieceBox = new THREE.Box3(
                        new THREE.Vector3(corner.x, corner.y, corner.z),
                        new THREE.Vector3(corner.x + dims.w, corner.y + dims.h, corner.z + dims.d)
                    );
                    const point = new THREE.Vector3(c.x, c.y, c.z);
                    const isInside = point.x > pieceBox.min.x + this.epsilon && point.x < pieceBox.max.x - this.epsilon &&
                        point.y > pieceBox.min.y + this.epsilon && point.y < pieceBox.max.y - this.epsilon &&
                        point.z > pieceBox.min.z + this.epsilon && point.z < pieceBox.max.z - this.epsilon;
                    return !isInside;
                });
            }
            addCornerIfNotExists(newCorner) {
                const exists = this.corners.some(c =>
                    Math.abs(c.x - newCorner.x) < this.epsilon &&
                    Math.abs(c.y - newCorner.y) < this.epsilon &&
                    Math.abs(c.z - newCorner.z) < this.epsilon
                );
                if (!exists) {
                    this.corners.push(newCorner);
                }
            }
            getOrientationDims(piece, orientation) {
                switch (orientation) {
                    case 0: return { w: piece.width, h: piece.height, d: piece.depth };
                    case 1: return { w: piece.height, h: piece.width, d: piece.depth };
                    case 2: return { w: piece.width, h: piece.depth, d: piece.height };
                    case 3: return { w: piece.depth, h: piece.width, d: piece.height };
                    case 4: return { w: piece.height, h: piece.depth, d: piece.width };
                    case 5: return { w: piece.depth, h: piece.height, d: piece.width };
                    default: return { w: piece.width, h: piece.height, d: piece.depth };
                }
            }
        }

        // --- 2. Packing Algorithm (Step-by-Step Logic) ---

        /**
         * Finds the next valid placement based on the current heuristic.
         * @param {Bin} bin - The bin object.
         * @param {Piece[]} currentRemainingPieces - Array of pieces still to be placed.
         * @returns {object|null} - An object { piece, corner, orientation, pieceIndex } or null if no placement found.
         */
        function findNextPlacement(bin, currentRemainingPieces) {
            // Sort corners by position (e.g., bottom-left-back first approach)
            bin.corners.sort((a, b) => {
                if (Math.abs(a.z - b.z) > bin.epsilon) return a.z - b.z; // Z first
                if (Math.abs(a.y - b.y) > bin.epsilon) return a.y - b.y; // Then Y
                return a.x - b.x; // Then X
            });

            // Iterate through remaining pieces (sorted by volume desc in initial setup)
            for (let i = 0; i < currentRemainingPieces.length; i++) {
                const piece = currentRemainingPieces[i];

                // Try placing this piece at each available corner
                for (const corner of bin.corners) {
                    // Try all 6 possible orientations
                    for (let orientation = 0; orientation < 6; orientation++) {
                        // Check if this placement is valid
                        if (bin.checkPlacement(piece, corner, orientation)) {
                            // If valid, return the placement details
                            return { piece, corner, orientation, pieceIndex: i };
                        }
                    }
                }
            }
            // If no valid placement found after checking all pieces/corners/orientations
            return null;
        }

        /**
         * Executes one step of the packing process. Finds and performs one placement.
         */
        function packStep() {
            if (remainingPieces.length === 0) {
                statusElement.textContent = "Status: Packing Complete (All pieces placed).";
                console.log("Packing Complete: All pieces placed.");
                startButton.disabled = false;
                return;
            }

            // Find the next placement based on the heuristic
            const placement = findNextPlacement(theBin, remainingPieces);

            if (placement) {
                // Placement found: Place the piece
                const { piece, corner, orientation, pieceIndex } = placement;
                theBin.placePiece(piece, corner, orientation);

                // Remove the placed piece from the remaining list
                remainingPieces.splice(pieceIndex, 1);

                statusElement.textContent = `Status: Placed Piece ${piece.id}. Remaining: ${remainingPieces.length}`;
                console.log(`Placed Piece ${piece.id} (Vol: ${piece.volume}) at (${corner.x.toFixed(2)}, ${corner.y.toFixed(2)}, ${corner.z.toFixed(2)}) orientation ${orientation}. Remaining: ${remainingPieces.length}`);

                // Update visualization
                visualizePacking(theBin.placedPieces, theBin);
                visualizeCorners(theBin.corners);

                // Schedule the next step
                packingTimeoutId = setTimeout(packStep, packingDelay);
            } else {
                // No placement found for any remaining piece
                statusElement.textContent = `Status: Packing Complete (Cannot place remaining ${remainingPieces.length} pieces).`;
                console.log(`Packing Complete: No valid placement found for remaining ${remainingPieces.length} pieces.`);
                startButton.disabled = false;
            }
        }

        /**
         * Initiates the step-by-step packing process.
         */
        function startPackingProcess() {
            if (packingTimeoutId) {
                clearTimeout(packingTimeoutId); // Clear previous timeout if any
            }
            resetPacking(); // Ensure a clean state before starting
            startButton.disabled = true; // Disable button while packing

            // Initial sort of pieces (largest volume first)
            remainingPieces = [...allPieces]; // Get a fresh copy
            remainingPieces.sort((a, b) => b.volume - a.volume);

            statusElement.textContent = "Status: Packing Started...";
            console.log("Packing Started...");

            // Start the first step
            packingTimeoutId = setTimeout(packStep, packingDelay);
        }

        /**
        * Resets the packing state and visualization.
        */
        function resetPacking() {
            if (packingTimeoutId) {
                clearTimeout(packingTimeoutId);
                packingTimeoutId = null;
            }
            // Reset bin state
            theBin.reset();
            // Reset all piece states
            allPieces.forEach(p => p.reset());
            remainingPieces = [];

            // Clear visualization
            pieceMeshes.clear();
            cornerMeshes.clear();

            // Visualize initial state (empty bin, starting corner)
            visualizeCorners(theBin.corners);

            statusElement.textContent = "Status: Ready";
            startButton.disabled = false;
            console.log("Packing Reset.");

        }


        // --- 3. Three.js Visualization Setup ---

        /**
         * Initializes the Three.js scene, camera, renderer, controls, and lighting.
         */
        function initVisualization() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x606060, 1.5);
            scene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight1.position.set(1, 0.75, 0.5).normalize();
            scene.add(directionalLight1);
            const directionalLight2 = new THREE.DirectionalLight(0xaaaaaa, 0.8);
            directionalLight2.position.set(-1, -0.75, -0.5).normalize();
            scene.add(directionalLight2);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;

            const axesHelper = new THREE.AxesHelper(Math.max(theBin.width, theBin.height, theBin.depth) * 1.2);
            scene.add(axesHelper);

            const binGeometry = new THREE.BoxGeometry(theBin.width, theBin.height, theBin.depth);
            const binEdges = new THREE.EdgesGeometry(binGeometry);
            binMesh = new THREE.LineSegments(binEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
            binMesh.position.set(theBin.width / 2, theBin.height / 2, theBin.depth / 2);
            scene.add(binMesh);

            // Add groups for pieces and corners to the scene
            scene.add(pieceMeshes);
            scene.add(cornerMeshes);

            // Set initial camera position and target
            camera.position.set(theBin.width * 1.2, theBin.height * 1.5, theBin.depth * 1.8);
            controls.target.set(theBin.width / 2, theBin.height / 2, theBin.depth / 2);
            controls.update();

            window.addEventListener('resize', onWindowResize, false);
            animate();

            // Visualize the initial state (empty bin, starting corner)
            resetPacking(); // Use reset to set initial state

            console.log("Three.js visualization initialized.");
        }

        /**
         * Updates the visualization to show the currently placed pieces.
         * @param {Piece[]} packedPieces - Array of placed Piece objects.
         * @param {Bin} bin - The Bin object (needed for getOrientationDims).
         */
        function visualizePacking(packedPieces, bin) {
            pieceMeshes.clear(); // Clear only piece meshes
            packedPieces.forEach(piece => {
                const dims = bin.getOrientationDims(piece, piece.orientation);
                const geometry = new THREE.BoxGeometry(dims.w, dims.h, dims.d);
                const material = new THREE.MeshLambertMaterial({
                    color: new THREE.Color(Math.random() * 0xffffff), // Keep random color generation simple
                    transparent: true,
                    opacity: 0.9
                });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set(
                    piece.position.x + dims.w / 2,
                    piece.position.y + dims.h / 2,
                    piece.position.z + dims.d / 2
                );
                pieceMeshes.add(cube);
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.6 }));
                line.position.copy(cube.position);
                pieceMeshes.add(line);
            });
            // console.log("Piece visualization updated."); // Less verbose logging
        }

        /**
         * Visualizes the available corner points as small spheres.
         * @param {Corner[]} corners - Array of Corner objects to visualize.
         */
        function visualizeCorners(corners) {
            cornerMeshes.clear(); // Clear previous corner meshes
            const cornerGeometry = new THREE.SphereGeometry(0.1, 8, 8); // Small sphere
            const cornerMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Blue color

            corners.forEach(corner => {
                const sphere = new THREE.Mesh(cornerGeometry, cornerMaterial);
                sphere.position.set(corner.x, corner.y, corner.z);
                cornerMeshes.add(sphere);
            });
            // console.log("Corner visualization updated."); // Less verbose logging
        }


        /** Handles window resize events. */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /** The main animation loop. */
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Update controls for damping
            renderer.render(scene, camera);
        }

        // --- 4. Initialization and Event Listeners ---

        // Define the dimensions of the bin
        const binDimensions = { width: 10, height: 10, depth: 10 };
        // Create the Bin object
        theBin = new Bin(binDimensions.width, binDimensions.height, binDimensions.depth);

        // Define the initial list of all pieces
        allPieces = [
            new Piece(1, 4, 4, 4), new Piece(2, 3, 3, 3), new Piece(3, 5, 2, 2),
            new Piece(4, 2, 5, 2), new Piece(5, 2, 2, 5), new Piece(6, 6, 1, 1),
            new Piece(7, 1, 6, 1), new Piece(8, 1, 1, 6), new Piece(9, 3, 4, 5),
            new Piece(10, 5, 3, 4), new Piece(11, 4, 5, 3), new Piece(12, 2, 2, 2),
            new Piece(13, 2, 2, 2), new Piece(14, 1, 1, 1), new Piece(15, 1, 1, 1),
            new Piece(16, 1, 1, 1), new Piece(17, 3, 1, 3), new Piece(18, 1, 3, 3),
            new Piece(19, 3, 3, 1), new Piece(20, 4, 2, 3),
        ];

        // Add event listeners for buttons
        startButton.addEventListener('click', startPackingProcess);
        resetButton.addEventListener('click', resetPacking);

        // Initialize the Three.js visualization environment
        initVisualization(); // This now also calls resetPacking for initial state

    </script>
</body>

</html>