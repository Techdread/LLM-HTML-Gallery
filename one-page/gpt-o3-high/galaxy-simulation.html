<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Galaxy Formation Simulation</title>
  <style>
    /* Basic page reset and styling */
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    /* Control panel styling */
    #gui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.85);
      padding: 10px;
      border-radius: 5px;
      z-index: 10;
      max-width: 200px;
    }
    #gui label {
      display: block;
      margin: 5px 0 2px;
      font-size: 0.9em;
    }
    #gui input, #gui select, #gui button {
      margin-bottom: 5px;
      width: 100%;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <div id="gui">
    <button id="startBtn">Start</button>
    <button id="pauseBtn">Pause</button>
    <button id="resetBtn">Reset</button>
    <label for="gravity">Gravity Strength:</label>
    <input type="range" id="gravity" min="0" max="5" step="0.1" value="1">
    <label for="distribution">Particle Distribution:</label>
    <select id="distribution">
      <option value="random">Random</option>
      <option value="uniform">Uniform</option>
      <option value="clustered">Clustered</option>
    </select>
    <label for="particleSize">Particle Size:</label>
    <input type="range" id="particleSize" min="1" max="10" step="0.5" value="2">
    <label for="particleColor">Particle Color:</label>
    <input type="color" id="particleColor" value="#ffffff">
  </div>

  <script type="module">
    // Import necessary modules
    import * as THREE from 'https://cdn.skypack.dev/three@0.128.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';

    // Global variables and constants
    let scene, camera, renderer, controls;
    let particles, particlePositions, velocities;
    const numParticles = 5000;
    let particleGeometry, particleMaterial;
    let simulationRunning = false;
    let gravityStrength = parseFloat(document.getElementById('gravity').value);
    let distributionType = document.getElementById('distribution').value;
    let particleSize = parseFloat(document.getElementById('particleSize').value);
    let particleColor = document.getElementById('particleColor').value;
    const dt = 0.016; // Time step for simulation (~60 FPS)
    const softening = 0.1; // Softening parameter to avoid singularities

    // Initialize Three.js scene, camera, renderer, and controls
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 100;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      
      // Create the particle system
      createParticles();

      window.addEventListener('resize', onWindowResize, false);
    }

    // Create particles with positions and velocities based on the selected distribution
    function createParticles() {
      // Remove existing particles if resetting
      if (particles) {
        scene.remove(particles);
      }
      particleGeometry = new THREE.BufferGeometry();
      particlePositions = new Float32Array(numParticles * 3);
      velocities = new Float32Array(numParticles * 3);

      for (let i = 0; i < numParticles; i++) {
        let x, y, z;
        if (distributionType === "random") {
          // Random positions within a cube
          x = (Math.random() - 0.5) * 200;
          y = (Math.random() - 0.5) * 200;
          z = (Math.random() - 0.5) * 200;
        } else if (distributionType === "uniform") {
          // Uniform grid distribution
          const gridSize = Math.cbrt(numParticles);
          const ix = i % gridSize;
          const iy = Math.floor(i / gridSize) % gridSize;
          const iz = Math.floor(i / (gridSize * gridSize));
          x = (ix / gridSize - 0.5) * 200;
          y = (iy / gridSize - 0.5) * 200;
          z = (iz / gridSize - 0.5) * 200;
        } else if (distributionType === "clustered") {
          // Clustered distribution near the center with random offsets
          const r = Math.random() * 20;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);
          x = r * Math.sin(phi) * Math.cos(theta);
          y = r * Math.sin(phi) * Math.sin(theta);
          z = r * Math.cos(phi);
          x += (Math.random() - 0.5) * 50;
          y += (Math.random() - 0.5) * 50;
          z += (Math.random() - 0.5) * 50;
        }
        particlePositions[i * 3] = x;
        particlePositions[i * 3 + 1] = y;
        particlePositions[i * 3 + 2] = z;

        // Give each particle a small tangential velocity to promote orbital motion
        const vx = -y * 0.01 + (Math.random() - 0.5) * 0.1;
        const vy =  x * 0.01 + (Math.random() - 0.5) * 0.1;
        const vz = (Math.random() - 0.5) * 0.1;
        velocities[i * 3] = vx;
        velocities[i * 3 + 1] = vy;
        velocities[i * 3 + 2] = vz;
      }
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

      // Create the material for the particles
      particleMaterial = new THREE.PointsMaterial({
        color: particleColor,
        size: particleSize,
      });

      // Create and add the Points object to the scene
      particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);
    }

    // Adjust camera and renderer on window resize
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Update simulation: apply a central gravitational force to each particle
    function updateSimulation() {
      for (let i = 0; i < numParticles; i++) {
        const idx = i * 3;
        let x = particlePositions[idx];
        let y = particlePositions[idx + 1];
        let z = particlePositions[idx + 2];

        // Compute distance from the center with softening to avoid division by zero
        const r = Math.sqrt(x * x + y * y + z * z) + softening;
        // Calculate acceleration (Newtonian gravity: a ∝ 1/r²)
        const a = -gravityStrength / (r * r);

        // Components of acceleration (directed toward the center)
        const ax = a * (x / r);
        const ay = a * (y / r);
        const az = a * (z / r);

        // Update velocities
        velocities[idx]     += ax * dt;
        velocities[idx + 1] += ay * dt;
        velocities[idx + 2] += az * dt;

        // Update positions
        particlePositions[idx]     += velocities[idx] * dt;
        particlePositions[idx + 1] += velocities[idx + 1] * dt;
        particlePositions[idx + 2] += velocities[idx + 2] * dt;
      }
      // Inform Three.js that the positions have changed
      particleGeometry.attributes.position.needsUpdate = true;
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      if (simulationRunning) {
        updateSimulation();
      }
      controls.update();
      renderer.render(scene, camera);
    }

    // Event listeners for the UI controls
    document.getElementById('startBtn').addEventListener('click', function() {
      simulationRunning = true;
    });

    document.getElementById('pauseBtn').addEventListener('click', function() {
      simulationRunning = false;
    });

    document.getElementById('resetBtn').addEventListener('click', function() {
      simulationRunning = false;
      distributionType = document.getElementById('distribution').value;
      gravityStrength = parseFloat(document.getElementById('gravity').value);
      particleSize = parseFloat(document.getElementById('particleSize').value);
      particleColor = document.getElementById('particleColor').value;
      createParticles();
    });

    document.getElementById('gravity').addEventListener('input', function(e) {
      gravityStrength = parseFloat(e.target.value);
    });

    document.getElementById('particleSize').addEventListener('input', function(e) {
      particleSize = parseFloat(e.target.value);
      if (particleMaterial) {
        particleMaterial.size = particleSize;
      }
    });

    document.getElementById('particleColor').addEventListener('input', function(e) {
      particleColor = e.target.value;
      if (particleMaterial) {
        particleMaterial.color.set(particleColor);
      }
    });

    // Initialize and start the animation loop
    init();
    animate();
  </script>
</body>
</html>
