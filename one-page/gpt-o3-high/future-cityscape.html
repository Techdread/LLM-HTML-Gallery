<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Futuristic Cityscape Simulation</title>
    <style>
      /* Reset and style for full-screen canvas */
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
      }
      canvas {
        display: block;
      }
      /* Optional UI element for camera control hint */
      .controls {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #fff;
        font-family: Arial, sans-serif;
        background: rgba(0, 0, 0, 0.4);
        padding: 5px 10px;
        border-radius: 4px;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      Use mouse/touch to move the camera.
    </div>

    <!-- Include Three.js and OrbitControls via ES6 module imports -->
    <script type="module">
      // Import modules from the CDN (ensure you have an Internet connection)
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js';
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/controls/OrbitControls.js';

      // ----------------------------
      // Scene, Camera, and Renderer
      // ----------------------------
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 50, 100);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // ----------------------------
      // OrbitControls for camera movement
      // ----------------------------
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.1;

      // ----------------------------
      // Lighting Setup
      // ----------------------------
      // Ambient light for soft global illumination.
      const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
      scene.add(ambientLight);

      // Directional light to mimic sunlight and cast shadows.
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(50, 100, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // ----------------------------
      // Ground Plane
      // ----------------------------
      const groundGeometry = new THREE.PlaneGeometry(500, 500);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // ----------------------------
      // Create Cityscape Buildings
      // ----------------------------
      const buildingGroup = new THREE.Group();
      // Generate a grid of buildings with random dimensions and positions.
      for (let i = -20; i < 20; i++) {
        for (let j = -20; j < 20; j++) {
          // Randomize dimensions for variety.
          const width = THREE.MathUtils.randFloat(2, 8);
          const depth = THREE.MathUtils.randFloat(2, 8);
          const height = THREE.MathUtils.randFloat(10, 80);

          const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
          // Use HSL colors for a futuristic, subtle variation.
          const buildingMaterial = new THREE.MeshLambertMaterial({
            color: new THREE.Color(`hsl(${Math.random() * 360}, 20%, 50%)`)
          });

          const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
          building.castShadow = true;
          building.receiveShadow = true;
          // Position buildings on a grid with small random offset
          building.position.x = i * 12 + THREE.MathUtils.randFloatSpread(4);
          building.position.y = height / 2;
          building.position.z = j * 12 + THREE.MathUtils.randFloatSpread(4);
          buildingGroup.add(building);
        }
      }
      scene.add(buildingGroup);

      // ----------------------------
      // Create Flying Vehicles
      // ----------------------------
      const vehicles = [];
      const numVehicles = 10; // Number of flying vehicles
      
      for (let v = 0; v < numVehicles; v++) {
        // Stylized vehicle: a cone shape representing a futuristic flying craft.
        const vehicleGeometry = new THREE.ConeGeometry(1.5, 4, 8);
        const vehicleMaterial = new THREE.MeshStandardMaterial({
          color: Math.random() * 0xffffff
        });
        const vehicle = new THREE.Mesh(vehicleGeometry, vehicleMaterial);
        // Rotate so the cone points forward (adjust orientation as needed)
        vehicle.rotation.x = Math.PI / 2;
        vehicle.castShadow = true;
        scene.add(vehicle);

        // Define a circular path with some variance:
        const radius = THREE.MathUtils.randFloat(30, 80);
        const speed = THREE.MathUtils.randFloat(0.001, 0.005);
        vehicles.push({
          mesh: vehicle,
          radius,
          speed,
          offset: Math.random() * Math.PI * 2
        });
      }

      // ----------------------------
      // Animation Loop
      // ----------------------------
      function animate(time) {
        time *= 0.001; // Convert time to seconds

        // Update flying vehicles along their circular path with smooth vertical oscillation.
        vehicles.forEach((vehicle) => {
          const angle = time * vehicle.speed * 100 + vehicle.offset;
          vehicle.mesh.position.x = Math.cos(angle) * vehicle.radius;
          vehicle.mesh.position.z = Math.sin(angle) * vehicle.radius;
          // Vertical oscillation: base altitude plus sine variation.
          vehicle.mesh.position.y = 20 + Math.sin(angle * 3) * 5;
          // Rotate the vehicle for added effect.
          vehicle.mesh.rotation.z = angle;
        });

        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);

      // ----------------------------
      // Handle Window Resize
      // ----------------------------
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>