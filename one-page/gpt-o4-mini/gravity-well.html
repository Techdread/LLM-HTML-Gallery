<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Gravity Well Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            z-index: 1;
        }

        .dg {
            z-index: 2 !important;
        }
    </style>
</head>

<body>
    <div id="info">Click on the scene to add a mass object.<br>Use GUI to adjust values.</div>

    <!-- Load Three.js and dependencies as global scripts -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.148.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>

    <script>
        // Scene, camera, renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.minDistance = 10;
        controls.maxDistance = 300;
        controls.enableDamping = true; // Enable damping for smoother camera movements
        controls.dampingFactor = 0.05; // Set the damping factor (lower is smoother, default is 0.05)

        // Grid mesh for spacetime
        const size = 100, segments = 100;
        const gridGeometry = new THREE.PlaneGeometry(size, size, segments, segments);
        gridGeometry.rotateX(-Math.PI / 2);
        const gridMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffdd, wireframe: true });
        const gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);
        scene.add(gridMesh);

        // Mass objects and particles
        const masses = [];
        const particles = [];

        // GUI parameters
        const params = {
            massValue: 20,
            initialSpeed: 5,
            addParticle: function () { addParticle(); }
        };
        const gui = new dat.GUI();
        gui.add(params, 'massValue', 1, 100).name('Mass Value');
        gui.add(params, 'initialSpeed', 0, 20).name('Init Speed');
        gui.add(params, 'addParticle').name('Launch Particle');

        // Add mass on click
        window.addEventListener('pointerdown', function (e) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(gridMesh);
            if (intersects.length > 0) {
                const pt = intersects[0].point;
                addMass(pt, params.massValue);
            }
        });

        function addMass(position, mass) {
            const geom = new THREE.SphereGeometry(1, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const sphere = new THREE.Mesh(geom, mat);
            sphere.position.copy(position);
            sphere.mass = mass;
            scene.add(sphere);
            masses.push(sphere);
        }

        function addParticle() {
            const geom = new THREE.SphereGeometry(0.5, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const p = new THREE.Mesh(geom, mat);
            p.position.set(0, 1, 0);
            // random direction
            const dir = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
            p.velocity = dir.multiplyScalar(params.initialSpeed);
            scene.add(p);
            // trajectory line
            p.trajGeom = new THREE.BufferGeometry().setFromPoints([]);
            p.trajMat = new THREE.LineBasicMaterial({ color: 0xffff00 });
            p.trajLine = new THREE.Line(p.trajGeom, p.trajMat);
            scene.add(p.trajLine);
            particles.push(p);
        }

        function updateGrid() {
            const vertices = gridGeometry.attributes.position;
            for (let i = 0; i < vertices.count; i++) {
                const x = vertices.getX(i);
                const z = vertices.getZ(i);
                let y = 0;
                masses.forEach(function (m) {
                    const dx = x - m.position.x;
                    const dz = z - m.position.z;
                    const r2 = dx * dx + dz * dz + 1;
                    y -= m.mass / r2;
                });
                vertices.setY(i, y);
            }
            vertices.needsUpdate = true;
            gridGeometry.computeVertexNormals();
        }

        function updateParticles(dt) {
            particles.forEach(function (p) {
                masses.forEach(function (m) {
                    const force = new THREE.Vector3().subVectors(m.position, p.position);
                    const dist2 = force.lengthSq() + 1;
                    force.normalize().multiplyScalar(m.mass / dist2);
                    p.velocity.add(force.clone().multiplyScalar(dt));
                });
                p.position.add(p.velocity.clone().multiplyScalar(dt));
                // update trajectory
                const oldArr = p.trajGeom.attributes.position ? Array.from(p.trajGeom.attributes.position.array) : [];
                oldArr.push(p.position.x, p.position.y, p.position.z);
                const newPoints = new THREE.Float32BufferAttribute(oldArr, 3);
                p.trajGeom.setAttribute('position', newPoints);
                p.trajGeom.setDrawRange(0, oldArr.length / 3);
            });
        }

        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            updateGrid();
            updateParticles(dt);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle resize
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>