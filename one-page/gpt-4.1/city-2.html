<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Procedural City Generator with Traffic</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 8px;
            padding: 12px 20px 8px 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-family: sans-serif;
            font-size: 15px;
        }

        #ui label {
            margin-right: 6px;
        }

        #ui input[type=range] {
            width: 80px;
        }

        #ui select {
            margin-left: 5px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <label>City Seed: <input type="number" id="seed" min="1" max="99999" value="1" /></label>
        <label>City Size: <input type="range" id="size" min="8" max="40" value="20" /></label>
        <label>Density: <input type="range" id="density" min="1" max="3" step="0.1" value="2" /></label>
        <label>Districts: <select id="districtStyle">
                <option value="grid">Grid</option>
                <option value="organic">Organic</option>
            </select></label>
        <button id="regen">Regenerate</button>
    </div>
    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
  }
}
</script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, cityGroup, clock;
        let trafficObjects = [], pedestrianObjects = [];
        let SEED = 1, CITY_SIZE = 20, DENSITY = 2, DISTRICT_STYLE = 'grid';

        init();
        generateCity();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xaec6cf);
            clock = new THREE.Clock();
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, CITY_SIZE * 1.5, CITY_SIZE * 2.2);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.15;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.minDistance = CITY_SIZE * 0.7;
            controls.maxDistance = CITY_SIZE * 4;
            // UI events
            document.getElementById('regen').onclick = () => {
                updateParams();
                generateCity();
            };
            document.getElementById('seed').oninput = document.getElementById('size').oninput = document.getElementById('density').oninput = document.getElementById('districtStyle').oninput = function () {
                updateParams();
            };
            window.addEventListener('resize', onWindowResize);
        }

        function updateParams() {
            SEED = parseInt(document.getElementById('seed').value);
            CITY_SIZE = parseInt(document.getElementById('size').value);
            DENSITY = parseFloat(document.getElementById('density').value);
            DISTRICT_STYLE = document.getElementById('districtStyle').value;
        }

        function generateCity() {
            if (cityGroup) scene.remove(cityGroup);
            trafficObjects = [];
            pedestrianObjects = [];
            cityGroup = new THREE.Group();
            const rng = mulberry32(SEED);
            const districtMap = createDistrictMap(CITY_SIZE, DISTRICT_STYLE, rng);
            // Roads
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x222428, roughness: 0.5, metalness: 0.3 });
            for (let i = 0; i < CITY_SIZE; ++i) for (let j = 0; j < CITY_SIZE; ++j) {
                if (districtMap.roads[i][j]) {
                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 0.08, 1), roadMat);
                    mesh.position.set(i - CITY_SIZE / 2, 0, j - CITY_SIZE / 2);
                    cityGroup.add(mesh);
                }
            }
            // District Zoning + Buildings
            for (let i = 0; i < CITY_SIZE; ++i) for (let j = 0; j < CITY_SIZE; ++j) {
                if (!districtMap.roads[i][j]) {
                    const zone = districtMap.zones[i][j];
                    if (!zone) continue;
                    const height = getBuildingHeight(zone, rng, DENSITY, i, j, CITY_SIZE);
                    const mesh = createBuildingMesh(zone, height, rng);
                    mesh.position.set(i - CITY_SIZE / 2, height / 2, j - CITY_SIZE / 2);
                    cityGroup.add(mesh);
                }
            }
            // Parks/Green spaces
            for (const park of districtMap.parks) {
                const parkGeo = new THREE.BoxGeometry(park.size, 0.06, park.size);
                const parkMat = new THREE.MeshStandardMaterial({ color: 0x61c48a });
                const parkMesh = new THREE.Mesh(parkGeo, parkMat);
                parkMesh.position.set(park.x - CITY_SIZE / 2, 0.035, park.z - CITY_SIZE / 2);
                cityGroup.add(parkMesh);
            }
            // Street lights (simple for demo)
            for (let i = 0; i < CITY_SIZE; ++i) for (let j = 0; j < CITY_SIZE; ++j) {
                if (districtMap.roads[i][j] && rng() < 0.06) {
                    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.7, 10), new THREE.MeshStandardMaterial({ color: 0xe5e3ce, metalness: 0.6, roughness: 0.4 }));
                    pole.position.set(i - CITY_SIZE / 2, 0.35, j - CITY_SIZE / 2);
                    cityGroup.add(pole);
                    const light = new THREE.PointLight(0xffeeaa, 0.7, 2.5, 2);
                    light.position.set(i - CITY_SIZE / 2, 0.72, j - CITY_SIZE / 2);
                    cityGroup.add(light);
                }
            }
            // Add subtle city ambient & sun
            scene.add(new THREE.AmbientLight(0xddddff, 0.35));
            const sun = new THREE.DirectionalLight(0xfffbdb, 1.2);
            sun.position.set(1.8, 2.6, 1.7);
            scene.add(sun);
            // Drop shadow below city
            const cityBase = new THREE.Mesh(
                new THREE.CylinderGeometry(CITY_SIZE * 0.73, CITY_SIZE * 0.68, 0.08, 50),
                new THREE.MeshStandardMaterial({ color: 0x2c393c, roughness: 0.6, metalness: 0.2, transparent: true, opacity: 0.6 })
            );
            cityBase.position.y = -0.04;
            cityGroup.add(cityBase);

            // --- TRAFFIC: CARS & BUSES ---
            // Find horizontal and vertical roads (for demo, just use a slice of roads)
            let roadLines = [];
            for (let i = 0; i < CITY_SIZE; i++) {
                let count = 0;
                for (let j = 0; j < CITY_SIZE; j++) {
                    if (districtMap.roads[i][j]) count++;
                }
                if (count > CITY_SIZE * 0.7) roadLines.push({ dir: 'h', i });
            }
            for (let j = 0; j < CITY_SIZE; j++) {
                let count = 0;
                for (let i = 0; i < CITY_SIZE; i++) {
                    if (districtMap.roads[i][j]) count++;
                }
                if (count > CITY_SIZE * 0.7) roadLines.push({ dir: 'v', j });
            }

            // Add vehicles to major road lines
            let trafficSeed = mulberry32(SEED + 77);
            for (let k = 0; k < roadLines.length; k++) {
                let isBus = trafficSeed() > 0.8;
                let color = isBus ? 0xfbd14b : (trafficSeed() > 0.3 ? 0x3170a7 : 0xc0392b);
                let nVehicles = Math.floor(trafficSeed() * CITY_SIZE / 2.5) + 2;
                let jamZone = trafficSeed() > 0.6;
                let jamStart = Math.floor(CITY_SIZE / 2 + (trafficSeed() - 0.5) * CITY_SIZE / 3);

                for (let t = 0; t < nVehicles; t++) {
                    let mesh;
                    if (isBus) {
                        mesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.22, 1.65), new THREE.MeshStandardMaterial({ color, metalness: 0.5, roughness: 0.6 }));
                    } else {
                        mesh = new THREE.Mesh(new THREE.BoxGeometry(0.36, 0.17, 0.68), new THREE.MeshStandardMaterial({ color, metalness: 0.2, roughness: 0.5 }));
                    }
                    let pos, dir, mainAxis;
                    let gap = 1.15 + trafficSeed() * 0.6;
                    if (roadLines[k].dir == 'h') {
                        pos = new THREE.Vector3(roadLines[k].i - CITY_SIZE / 2, 0.12, -CITY_SIZE / 2 + t * gap);
                        dir = new THREE.Vector3(0, 0, 1);
                        mainAxis = 'z';
                        mesh.rotation.y = 0;
                        // Traffic jam: vehicles in front jammed in jamZone
                        if (jamZone && pos.z > jamStart && t > 0) gap *= 0.19;
                    } else {
                        pos = new THREE.Vector3(-CITY_SIZE / 2 + t * gap, 0.12, roadLines[k].j - CITY_SIZE / 2);
                        dir = new THREE.Vector3(1, 0, 0);
                        mainAxis = 'x';
                        mesh.rotation.y = Math.PI / 2;
                        if (jamZone && pos.x > jamStart && t > 0) gap *= 0.19;
                    }
                    mesh.position.copy(pos);
                    cityGroup.add(mesh);
                    trafficObjects.push({
                        mesh, dir, mainAxis, gap, roadIndex: t,
                        isBus, jamZone, jamStart, seed: trafficSeed()
                    });
                }
            }

            // --- PEDESTRIANS: Along roadsides and parks ---
            let pedSeed = mulberry32(SEED + 333);
            for (let i = 0; i < Math.floor(CITY_SIZE * 2.3); i++) {
                // Pick random roadside or park edge
                let isPark = pedSeed() > 0.7 && districtMap.parks.length;
                let mesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.07, 0.07, 0.22, 8),
                    new THREE.MeshStandardMaterial({ color: 0xf8b88b, metalness: 0.15, roughness: 0.45 })
                );
                let pos, dir;
                if (isPark) {
                    let park = districtMap.parks[Math.floor(pedSeed() * districtMap.parks.length)];
                    // Move along park perimeter
                    let edge = pedSeed() > 0.5 ? 'x' : 'z';
                    let along = (pedSeed() - 0.5) * park.size;
                    if (edge === 'x') {
                        pos = new THREE.Vector3(park.x - park.size / 2 + (pedSeed() > 0.5 ? 0 : park.size), 0.13, park.z + along - CITY_SIZE / 2);
                        dir = new THREE.Vector3(0, 0, pedSeed() > 0.5 ? 1 : -1);
                    } else {
                        pos = new THREE.Vector3(park.x + along - CITY_SIZE / 2, 0.13, park.z - park.size / 2 + (pedSeed() > 0.5 ? 0 : park.size));
                        dir = new THREE.Vector3(pedSeed() > 0.5 ? 1 : -1, 0, 0);
                    }
                } else {
                    // Move along main road edge
                    let main = pedSeed() > 0.5;
                    let idx = Math.floor(pedSeed() * CITY_SIZE);
                    if (main) {
                        pos = new THREE.Vector3(idx - CITY_SIZE / 2 + 0.42, 0.13, -CITY_SIZE / 2 + (pedSeed() - 0.5) * CITY_SIZE * 0.85);
                        dir = new THREE.Vector3(0, 0, pedSeed() > 0.5 ? 1 : -1);
                    } else {
                        pos = new THREE.Vector3(-CITY_SIZE / 2 + (pedSeed() - 0.5) * CITY_SIZE * 0.85, 0.13, idx - CITY_SIZE / 2 + 0.42);
                        dir = new THREE.Vector3(pedSeed() > 0.5 ? 1 : -1, 0, 0);
                    }
                }
                mesh.position.copy(pos);
                cityGroup.add(mesh);
                pedestrianObjects.push({
                    mesh, dir, start: pos.clone(), walkLength: (0.7 + pedSeed() * 0.4) * CITY_SIZE, t: pedSeed()
                });
            }

            scene.add(cityGroup);
        }

        function createDistrictMap(size, style, rng) {
            // ... same as before ...
            const roads = Array(size).fill(0).map(() => Array(size).fill(false));
            const zones = Array(size).fill(0).map(() => Array(size).fill(null));
            if (style == "grid") {
                for (let i = 0; i < size; i += 4 + Math.floor(rng() * 2)) {
                    for (let j = 0; j < size; ++j) roads[i][j] = true;
                }
                for (let j = 0; j < size; j += 4 + Math.floor(rng() * 2)) {
                    for (let i = 0; i < size; ++i) roads[i][j] = true;
                }
            } else {
                for (let k = 0; k < 3; ++k) {
                    let cx = Math.floor(size / 2 + (size / 4) * Math.sin(rng() * Math.PI * 2));
                    let cz = Math.floor(size / 2 + (size / 4) * Math.cos(rng() * Math.PI * 2));
                    for (let t = 0; t < size; ++t) {
                        let x = Math.floor(cx + Math.sin(t / size * Math.PI * 2 + k) * size / 3 + (rng() - 0.5) * 2);
                        let z = Math.floor(cz + Math.cos(t / size * Math.PI * 2 + k) * size / 3 + (rng() - 0.5) * 2);
                        if (x >= 0 && x < size && z >= 0 && z < size) roads[x][z] = true;
                    }
                }
                let cx = Math.floor(size / 2), cz = Math.floor(size / 2);
                for (let a = 0; a < 6; ++a) {
                    for (let r = 0; r < size / 2 - 1; ++r) {
                        let x = Math.floor(cx + Math.sin(a / 6 * Math.PI * 2) * r);
                        let z = Math.floor(cz + Math.cos(a / 6 * Math.PI * 2) * r);
                        if (x >= 0 && x < size && z >= 0 && z < size) roads[x][z] = true;
                    }
                }
            }
            const parks = [];
            for (let p = 0; p < size / 5; ++p) {
                let parkSize = Math.round(2.2 + rng() * 2);
                let x = Math.floor(rng() * (size - parkSize));
                let z = Math.floor(rng() * (size - parkSize));
                let clear = true;
                for (let dx = 0; dx < parkSize; ++dx)for (let dz = 0; dz < parkSize; ++dz) {
                    if (roads[x + dx][z + dz]) clear = false;
                }
                if (clear) parks.push({ x: x + parkSize / 2, z: z + parkSize / 2, size: parkSize });
            }
            for (let i = 0; i < size; ++i) for (let j = 0; j < size; ++j) {
                if (roads[i][j]) continue;
                let distToCenter = Math.sqrt((i - size / 2) ** 2 + (j - size / 2) ** 2);
                let zone = null;
                if (distToCenter < size / 6) zone = 'commercial';
                else if (distToCenter < size / 3) zone = 'residential';
                else zone = 'industrial';
                for (const park of parks) {
                    if (Math.abs(i - park.x) < park.size / 2 && Math.abs(j - park.z) < park.size / 2) zone = null;
                }
                zones[i][j] = zone;
            }
            return { roads, zones, parks };
        }

        function getBuildingHeight(zone, rng, density, i, j, size) {
            if (zone === 'commercial') return 2.8 + rng() * 2.7 + Math.abs(i - size / 2) * 0.12 + density * 0.6;
            if (zone === 'residential') return 1.2 + rng() * 1.2 + density * 0.5;
            if (zone === 'industrial') return 0.8 + rng() * 0.6 + density * 0.2;
            return 0;
        }

        function createBuildingMesh(zone, h, rng) {
            let w = 0.65 + rng() * 0.5;
            let d = 0.65 + rng() * 0.5;
            if (zone === 'commercial') {
                if (rng() > 0.7) return createSkyscraperMesh(h, rng);
                return new THREE.Mesh(
                    new THREE.BoxGeometry(w, h, d),
                    new THREE.MeshStandardMaterial({ color: 0x22303d, metalness: 0.4, roughness: 0.4 })
                );
            }
            if (zone === 'residential') {
                let color = [0xddeef2, 0xf0d8b0, 0xd9bba0, 0xc7eae4, 0xf4a698][Math.floor(rng() * 5)];
                return new THREE.Mesh(
                    new THREE.BoxGeometry(w, h, d),
                    new THREE.MeshStandardMaterial({ color, metalness: 0.15, roughness: 0.65 })
                );
            }
            if (zone === 'industrial') {
                return new THREE.Mesh(
                    new THREE.BoxGeometry(w * 1.2, h, d * 1.2),
                    new THREE.MeshStandardMaterial({ color: 0xa09ea2, metalness: 0.4, roughness: 0.7 })
                );
            }
        }
        function createSkyscraperMesh(h, rng) {
            let group = new THREE.Group();
            let baseH = h * 0.35 + rng() * h * 0.15;
            let midH = h * 0.3 + rng() * h * 0.1;
            let topH = h * 0.18 + rng() * h * 0.1;
            let w = 0.8 + rng() * 0.4;
            let d = 0.8 + rng() * 0.4;
            let base = new THREE.Mesh(
                new THREE.BoxGeometry(w, baseH, d),
                new THREE.MeshStandardMaterial({ color: 0x294c60, metalness: 0.7, roughness: 0.35 })
            );
            base.position.y = baseH / 2;
            let mid = new THREE.Mesh(
                new THREE.CylinderGeometry(w * 0.42, w * 0.56, midH, 10),
                new THREE.MeshStandardMaterial({ color: 0x547a89, metalness: 0.5, roughness: 0.3 })
            );
            mid.position.y = baseH + midH / 2 - 0.02;
            let top = new THREE.Mesh(
                new THREE.CylinderGeometry(w * 0.32, w * 0.32, topH, 10),
                new THREE.MeshStandardMaterial({ color: 0xabb8c3, metalness: 0.5, roughness: 0.25 })
            );
            top.position.y = baseH + midH + topH / 2 - 0.04;
            group.add(base, mid, top);
            return group;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateTrafficAndPedestrians();
            controls.update();
            renderer.render(scene, camera);
        }

        function updateTrafficAndPedestrians() {
            let t = clock.getElapsedTime();
            // Move traffic
            for (let i = 0; i < trafficObjects.length; i++) {
                let obj = trafficObjects[i];
                let v = obj.isBus ? 0.11 : 0.16;
                let baseSpeed = v + 0.045 * Math.sin(t * 0.3 + obj.seed);
                let move = true;
                // Jam logic
                if (obj.jamZone) {
                    if ((obj.mainAxis == 'z' && obj.mesh.position.z > obj.jamStart) ||
                        (obj.mainAxis == 'x' && obj.mesh.position.x > obj.jamStart)) {
                        move = false; // jammed!
                    }
                }
                // If car ahead is close, stop
                for (let j = 0; j < trafficObjects.length; j++) {
                    if (i == j) continue;
                    let other = trafficObjects[j];
                    if (obj.mainAxis != other.mainAxis) continue;
                    if (obj.mainAxis == 'z' && obj.mesh.position.x == other.mesh.position.x) {
                        if (other.mesh.position.z > obj.mesh.position.z && other.mesh.position.z - obj.mesh.position.z < obj.gap * 0.95)
                            move = false;
                    }
                    if (obj.mainAxis == 'x' && obj.mesh.position.z == other.mesh.position.z) {
                        if (other.mesh.position.x > obj.mesh.position.x && other.mesh.position.x - obj.mesh.position.x < obj.gap * 0.95)
                            move = false;
                    }
                }
                if (move) {
                    obj.mesh.position.addScaledVector(obj.dir, baseSpeed * 0.17);
                    // Loop around for infinite city feel
                    if (obj.mainAxis == 'z' && obj.mesh.position.z > CITY_SIZE / 2) obj.mesh.position.z = -CITY_SIZE / 2;
                    if (obj.mainAxis == 'x' && obj.mesh.position.x > CITY_SIZE / 2) obj.mesh.position.x = -CITY_SIZE / 2;
                }
            }
            // Move pedestrians
            for (let i = 0; i < pedestrianObjects.length; i++) {
                let obj = pedestrianObjects[i];
                let speed = 0.08;
                obj.t += speed * 0.009;
                obj.mesh.position.addScaledVector(obj.dir, speed * 0.11);
                if (obj.mesh.position.distanceTo(obj.start) > obj.walkLength) {
                    // Reverse direction
                    obj.dir.negate();
                    obj.start.copy(obj.mesh.position);
                    obj.t = 0;
                }
            }
        }

        // Simple seeded PRNG
        function mulberry32(a) {
            return function () {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }
    </script>
</body>

</html>