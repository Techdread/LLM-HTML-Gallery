<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Futuristic Cityscape with Flying Vehicles</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }

        #ui h1 {
            margin: 0 0 15px 0;
        }

        #ui .control-group {
            margin-bottom: 10px;
        }

        #ui label {
            display: inline-block;
            width: 120px;
        }
    </style>
</head>

<body>
    <!-- Import map for three.js and its addons -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
      }
    }
    </script>

    <!-- UI -->
    <div id="ui">
        <h1>Futuristic Cityscape</h1>
        <div class="control-group">
            <label for="gridSize">Grid Size:</label>
            <input type="range" id="gridSize" min="10" max="100" value="30">
        </div>
        <div class="control-group">
            <label for="citySize">City Size:</label>
            <input type="range" id="citySize" min="10" max="200" value="50">
        </div>
        <div class="control-group">
            <label for="vehicleCount">Vehicle Count:</label>
            <input type="range" id="vehicleCount" min="1" max="100" value="10">
        </div>
        <div class="control-group">
            <label for="timeOfDay">Time of Day:</label>
            <input type="range" id="timeOfDay" min="0" max="24" value="0">
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';

        let scene, camera, renderer, controls, vehicles = [];
        let clock = new THREE.Clock();
        let timeOfDay = 0;
        let dayNightCycleSpeed = 0.1;

        // UI elements
        const gridSizeSlider = document.getElementById('gridSize');
        const citySizeSlider = document.getElementById('citySize');
        const vehicleCountSlider = document.getElementById('vehicleCount');
        const timeOfDaySlider = document.getElementById('timeOfDay');

        init();
        animate();

        function init() {
            // Create scene, camera, renderer
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Add orbit controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;

            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create cityscape
            createCityscape();

            // Create flying vehicles
            createFlyingVehicles();

            // Add event listeners for UI controls
            gridSizeSlider.addEventListener('input', function () {
                recreateCityscape();
            });

            citySizeSlider.addEventListener('input', function () {
                recreateCityscape();
            });

            vehicleCountSlider.addEventListener('input', function () {
                recreateFlyingVehicles();
            });

            timeOfDaySlider.addEventListener('input', function () {
                updateTimeOfDay();
            });

            // Resize listener
            window.addEventListener('resize', onWindowResize);
        }

        function createCityscape() {
            // Clear existing buildings
            scene.children.forEach(child => {
                if (child instanceof THREE.Mesh && child.name.startsWith('building')) {
                    scene.remove(child);
                }
            });

            // Clear parks and other recreational areas
            scene.children.forEach(child => {
                if (child instanceof THREE.Mesh && child.name.startsWith('park')) {
                    scene.remove(child);
                }
            });

            // Grid parameters
            const gridSize = parseInt(gridSizeSlider.value);
            const citySize = parseInt(citySizeSlider.value);
            const gridHalfSize = gridSize / 2;
            const noise = new ImprovedNoise();

            // Create buildings
            for (let x = -gridHalfSize; x <= gridHalfSize; x++) {
                for (let z = -gridHalfSize; z <= gridHalfSize; z++) {
                    // Determine building height based on noise and distance from center
                    const distanceFromCenter = Math.max(0, Math.abs(x) + Math.abs(z));
                    const noiseValue = noise.noise(x * 0.1, z * 0.1, 0);
                    const buildingHeight = Math.max(5, Math.floor((citySize - distanceFromCenter) * 0.5 + noiseValue * citySize * 0.3));

                    if (buildingHeight > 5) {
                        // Create building
                        const buildingGeometry = new THREE.BoxGeometry(2, buildingHeight, 2);
                        const buildingMaterial = new THREE.MeshStandardMaterial({
                            color: new THREE.Color(Math.random(), Math.random(), Math.random()),
                            metalness: 0.5,
                            roughness: 0.5
                        });
                        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                        building.position.set(x * 3, buildingHeight / 2, z * 3);
                        building.name = 'building-' + x + '-' + z;
                        building.castShadow = true;
                        building.receiveShadow = true;
                        scene.add(building);
                    }
                }
            }

            // Create parks and other recreational areas
            const parkGeometry = new THREE.PlaneGeometry(10, 10);
            const parkMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color(0.2, 0.8, 0.2),
                side: THREE.DoubleSide
            });

            // Create a park
            const park = new THREE.Mesh(parkGeometry, parkMaterial);
            park.position.set(0, 0, gridHalfSize * 3 + 5);
            park.rotation.x = -Math.PI / 2;
            park.name = 'park';
            park.receiveShadow = true;
            scene.add(park);

            // Create a beach
            const beachGeometry = new THREE.PlaneGeometry(20, 10);
            const beachMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color(0.8, 0.7, 0.5),
                side: THREE.DoubleSide
            });

            const beach = new THREE.Mesh(beachGeometry, beachMaterial);
            beach.position.set(0, 0, -gridHalfSize * 3 - 5);
            beach.rotation.x = -Math.PI / 2;
            beach.name = 'beach';
            beach.receiveShadow = true;
            scene.add(beach);

            // Add some trees or other decorative elements
            const treeGeometry = new THREE.ConeGeometry(1, 3, 8);
            const treeMaterial = new THREE.MeshStandardMaterial({ color: new THREE.Color(0.1, 0.5, 0.1) });

            for (let i = 0; i < 20; i++) {
                const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                tree.position.set(
                    (Math.random() - 0.5) * parkGeometry.parameters.width,
                    1.5,
                    park.position.z + (Math.random() - 0.5) * parkGeometry.parameters.width
                );
                tree.name = 'tree';
                tree.castShadow = true;
                tree.receiveShadow = true;
                scene.add(tree);
            }
        }

        function recreateCityscape() {
            // Recreate the cityscape with new parameters
            createCityscape();
            recreateFlyingVehicles();
        }

        function createFlyingVehicles() {
            // Clear existing vehicles
            vehicles.forEach(vehicle => {
                scene.remove(vehicle);
            });
            vehicles = [];

            // Vehicle count
            const vehicleCount = parseInt(vehicleCountSlider.value);

            // Create flying vehicles
            for (let i = 0; i < vehicleCount; i++) {
                // Create a simple vehicle (a sphere with a cone for the front)
                const vehicleBody = new THREE.SphereGeometry(0.5, 16, 16);
                const vehicleCone = new THREE.ConeGeometry(0.5, 1, 8);
                vehicleCone.position.y = -0.25; // Position the cone to be at the front of the sphere

                const vehicleGeometry = new THREE.BufferGeometry();
                const vehiclePositions = new Float32Array((vehicleBody.attributes.position.count + vehicleCone.attributes.position.count) * 3);
                const vehicleNormals = new Float32Array((vehicleBody.attributes.position.count + vehicleCone.attributes.position.count) * 3);

                // Copy positions and normals from the body
                vehicleBody.attributes.position.array.copyToRange(vehiclePositions, 0, 0, 0);
                vehicleBody.attributes.normal.array.copyToRange(vehicleNormals, 0, 0, 0);

                // Copy positions and normals from the cone (offset by the body's position count)
                vehicleCone.attributes.position.array.copyToRange(vehiclePositions, vehicleBody.attributes.position.count * 3, 0, 0);
                vehicleCone.attributes.normal.array.copyToRange(vehicleNormals, vehicleBody.attributes.normal.count * 3, 0, 0);

                vehicleGeometry.setAttribute('position', new THREE.BufferAttribute(vehiclePositions, 3));
                vehicleGeometry.setAttribute('normal', new THREE.BufferAttribute(vehicleNormals, 3));

                const vehicleMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(Math.random(), Math.random(), Math.random()),
                    metalness: 0.8,
                    roughness: 0.2
                });

                const vehicle = new THREE.Mesh(vehicleGeometry, vehicleMaterial);
                vehicle.name = 'vehicle-' + i;

                // Random initial position
                vehicle.position.set(
                    (Math.random() - 0.5) * 100,
                    Math.random() * 50 + 10,
                    (Math.random() - 0.5) * 100
                );

                // Random direction and speed
                vehicle.userData.direction = new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).normalize();
                vehicle.userData.speed = Math.random() * 2 + 1;

                // Rotate vehicle to face direction
                vehicle.lookAt(vehicle.position.clone().add(vehicle.userData.direction));

                vehicle.castShadow = true;
                vehicle.receiveShadow = true;
                scene.add(vehicle);

                vehicles.push(vehicle);
            }
        }

        function recreateFlyingVehicles() {
            // Recreate the flying vehicles with new parameters
            createFlyingVehicles();
        }

        function updateTimeOfDay() {
            timeOfDay = parseInt(timeOfDaySlider.value);
            const dayNightCycle = timeOfDay / 24;

            // Update lighting based on time of day
            const sunIntensity = 0.8 * Math.max(0, Math.min(1, 1 - Math.abs(dayNightCycle - 0.5) * 2));
            const ambientIntensity = 0.5 * (1 - sunIntensity);

            scene.children.forEach(child => {
                if (child instanceof THREE.DirectionalLight) {
                    child.intensity = sunIntensity;
                    child.color.setHSL(dayNightCycle, 0.5, 0.5);
                } else if (child instanceof THREE.AmbientLight) {
                    child.intensity = ambientIntensity;
                    child.color.setHSL((dayNightCycle + 0.5) % 1, 0.5, 0.5);
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update vehicles
            const delta = clock.getDelta();
            vehicles.forEach(vehicle => {
                // Move vehicle along its path
                vehicle.position.add(vehicle.userData.direction.clone().multiplyScalar(vehicle.userData.speed * delta));

                // If vehicle is too far from the center, reverse direction
                if (vehicle.position.distanceTo(new THREE.Vector3(0, 0, 0)) > 200) {
                    vehicle.userData.direction.multiplyScalar(-1);
                    vehicle.lookAt(vehicle.position.clone().add(vehicle.userData.direction));
                }
            });

            // Update day/night cycle
            timeOfDay = (timeOfDay + dayNightCycleSpeed * delta) % 24;
            timeOfDaySlider.value = Math.floor(timeOfDay);
            updateTimeOfDay();

            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>