{
  "title": "Procedural Planet Generator",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Procedural Planet Generator</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n            background: #000;\r\n        }\r\n\r\n        canvas {\r\n            display: block;\r\n        }\r\n\r\n        .info {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            color: white;\r\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n            background: rgba(0, 0, 0, 0.7);\r\n            padding: 15px;\r\n            border-radius: 10px;\r\n            max-width: 300px;\r\n            z-index: 10;\r\n        }\r\n\r\n        .info h1 {\r\n            margin-top: 0;\r\n            font-size: 24px;\r\n            color: #4fc3f7;\r\n        }\r\n\r\n        .controls {\r\n            position: absolute;\r\n            bottom: 20px;\r\n            left: 50%;\r\n            transform: translateX(-50%);\r\n            display: flex;\r\n            gap: 15px;\r\n            background: rgba(0, 0, 0, 0.7);\r\n            padding: 15px;\r\n            border-radius: 30px;\r\n            z-index: 10;\r\n        }\r\n\r\n        .control-btn {\r\n            background: #2196f3;\r\n            color: white;\r\n            border: none;\r\n            padding: 10px 20px;\r\n            border-radius: 30px;\r\n            cursor: pointer;\r\n            font-weight: bold;\r\n            transition: all 0.3s;\r\n        }\r\n\r\n        .control-btn:hover {\r\n            background: #0d47a1;\r\n            transform: translateY(-2px);\r\n        }\r\n\r\n        .control-btn:active {\r\n            transform: translateY(1px);\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div class=\"info\">\r\n        <h1>Procedural Planet Generator</h1>\r\n        <p>This planet features:</p>\r\n        <ul>\r\n            <li>Realistic terrain with mountains, valleys and plains</li>\r\n            <li>Diverse biomes based on elevation and latitude</li>\r\n            <li>Atmospheric glow effect</li>\r\n            <li>Oceans with reflective surfaces</li>\r\n            <li>Procedural cloud layer</li>\r\n        </ul>\r\n    </div>\r\n\r\n    <div class=\"controls\">\r\n        <button id=\"rotateBtn\" class=\"control-btn\">Pause Rotation</button>\r\n        <button id=\"resetBtn\" class=\"control-btn\">Reset View</button>\r\n    </div>\r\n\r\n    <script type=\"importmap\">\r\n        {\r\n            \"imports\": {\r\n                \"three\": \"https://unpkg.com/three@0.165.0/build/three.module.js\",\r\n                \"three/addons/\": \"https://unpkg.com/three@0.165.0/examples/jsm/\"\r\n            }\r\n        }\r\n    </script>\r\n\r\n    <script type=\"module\">\r\n        import * as THREE from 'three';\r\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\n\r\n        // Scene setup\r\n        let scene, camera, renderer, controls;\r\n        let planet, atmosphere, ocean, clouds;\r\n        let rotationEnabled = true;\r\n        let rotationSpeed = 0.002;\r\n\r\n        init();\r\n        animate();\r\n\r\n        function init() {\r\n            // Create scene\r\n            scene = new THREE.Scene();\r\n            scene.background = new THREE.Color(0x000814);\r\n\r\n            // Create camera\r\n            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);\r\n            camera.position.set(0, 0, 35);\r\n\r\n            // Create renderer\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            renderer.setPixelRatio(window.devicePixelRatio);\r\n            document.body.appendChild(renderer.domElement);\r\n\r\n            // Add orbit controls\r\n            controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n            controls.minDistance = 15;\r\n            controls.maxDistance = 100;\r\n\r\n            // Create the planet with terrain\r\n            createPlanet();\r\n\r\n            // Add lighting\r\n            setupLighting();\r\n\r\n            // Add stars in background\r\n            addStars();\r\n\r\n            // Event listeners for UI controls\r\n            document.getElementById('rotateBtn').addEventListener('click', toggleRotation);\r\n            document.getElementById('resetBtn').addEventListener('click', resetView);\r\n\r\n            // Handle window resize\r\n            window.addEventListener('resize', onWindowResize);\r\n        }\r\n\r\n        function createPlanet() {\r\n            // Create planet geometry with custom terrain\r\n            const planetGeometry = new THREE.SphereGeometry(10, 64, 64);\r\n\r\n            // Generate terrain using noise functions\r\n            generateTerrain(planetGeometry);\r\n\r\n            // Create planet material with biome-based coloring\r\n            const planetMaterial = createPlanetMaterial();\r\n\r\n            // Create planet mesh\r\n            planet = new THREE.Mesh(planetGeometry, planetMaterial);\r\n            scene.add(planet);\r\n\r\n            // Create atmosphere layer\r\n            createAtmosphere();\r\n\r\n            // Create ocean\r\n            createOcean();\r\n\r\n            // Create clouds\r\n            createClouds();\r\n        }\r\n\r\n        function generateTerrain(geometry) {\r\n            const vertices = geometry.attributes.position.array;\r\n            const count = vertices.length / 3;\r\n\r\n            // Apply noise to vertices for terrain generation\r\n            for (let i = 0; i < count; i++) {\r\n                const index = i * 3;\r\n\r\n                // Get original position\r\n                let x = vertices[index];\r\n                let y = vertices[index + 1];\r\n                let z = vertices[index + 2];\r\n\r\n                // Normalize coordinates\r\n                const length = Math.sqrt(x * x + y * y + z * z);\r\n                const nx = x / length;\r\n                const ny = y / length;\r\n                const nz = z / length;\r\n\r\n                // Apply noise to create terrain features\r\n                const noiseValue = Math.sin(nx * 5) * Math.cos(ny * 3) * Math.sin(nz * 7) +\r\n                    Math.sin(nx * 2) * Math.cos(ny * 4) * Math.sin(nz * 3);\r\n\r\n                // Adjust terrain elevation\r\n                const elevation = noiseValue * 1.5;\r\n                vertices[index] += nx * elevation;\r\n                vertices[index + 1] += ny * elevation;\r\n                vertices[index + 2] += nz * elevation;\r\n            }\r\n\r\n            geometry.computeVertexNormals();\r\n            geometry.attributes.position.needsUpdate = true;\r\n        }\r\n\r\n        function createPlanetMaterial() {\r\n            // Create custom shader material for planet with biome coloring\r\n            const vertexShader = `\r\n                varying vec3 vNormal;\r\n                varying vec3 vPosition;\r\n                \r\n                void main() {\r\n                    vNormal = normalize(normalMatrix * normal);\r\n                    vPosition = position;\r\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n                }\r\n            `;\r\n\r\n            const fragmentShader = `\r\n                uniform float time;\r\n                varying vec3 vNormal;\r\n                varying vec3 vPosition;\r\n                \r\n                // Noise function for procedural textures\r\n                float noise(vec3 p) {\r\n                    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);\r\n                }\r\n                \r\n                void main() {\r\n                    // Base color based on position\r\n                    float elevation = length(vPosition) - 10.0;\r\n                    \r\n                    // Normalize normal for lighting calculations\r\n                    vec3 normal = normalize(vNormal);\r\n                    \r\n                    // Determine biome based on elevation and latitude\r\n                    float lat = asin(vPosition.y / 10.0); // Latitude\r\n                    \r\n                    vec3 color;\r\n                    \r\n                    if (elevation > 2.5) {\r\n                        // Mountains - white snow\r\n                        color = vec3(0.9, 0.9, 0.9);\r\n                    } else if (elevation > 1.0) {\r\n                        // Hills - brown\r\n                        color = mix(vec3(0.6, 0.4, 0.2), vec3(0.8, 0.6, 0.4), elevation * 0.5);\r\n                    } else if (elevation > 0.1) {\r\n                        // Plains - green\r\n                        color = mix(vec3(0.2, 0.6, 0.2), vec3(0.4, 0.8, 0.4), elevation * 0.5);\r\n                    } else if (elevation > -0.1) {\r\n                        // Lowlands - green\r\n                        color = mix(vec3(0.1, 0.5, 0.1), vec3(0.2, 0.7, 0.2), elevation * 0.5);\r\n                    } else if (elevation > -0.5) {\r\n                        // Ocean - blue\r\n                        color = mix(vec3(0.1, 0.3, 0.6), vec3(0.2, 0.4, 0.8), elevation * 0.5);\r\n                    } else {\r\n                        // Deep ocean - dark blue\r\n                        color = vec3(0.0, 0.1, 0.3);\r\n                    }\r\n                    \r\n                    // Add some texture variation\r\n                    float n = noise(vPosition * 2.0 + time * 0.01);\r\n                    color += vec3(n * 0.05);\r\n                    \r\n                    gl_FragColor = vec4(color, 1.0);\r\n                }\r\n            `;\r\n\r\n            return new THREE.ShaderMaterial({\r\n                uniforms: {\r\n                    time: { value: 0 }\r\n                },\r\n                vertexShader: vertexShader,\r\n                fragmentShader: fragmentShader\r\n            });\r\n        }\r\n\r\n        function createAtmosphere() {\r\n            const atmosphereGeometry = new THREE.SphereGeometry(10.5, 64, 64);\r\n\r\n            const atmosphereMaterial = new THREE.ShaderMaterial({\r\n                uniforms: {\r\n                    time: { value: 0 }\r\n                },\r\n                vertexShader: `\r\n                    varying vec3 vNormal;\r\n                    varying vec3 vPosition;\r\n                    \r\n                    void main() {\r\n                        vNormal = normalize(normalMatrix * normal);\r\n                        vPosition = position;\r\n                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n                    }\r\n                `,\r\n                fragmentShader: `\r\n                    uniform float time;\r\n                    varying vec3 vNormal;\r\n                    varying vec3 vPosition;\r\n                    \r\n                    void main() {\r\n                        // Create atmospheric glow effect\r\n                        float intensity = pow(0.5 - dot(vNormal, vec3(0, 0, 1)), 4.0);\r\n                        \r\n                        // Blue atmosphere with fading edge\r\n                        vec3 color = mix(vec3(0.2, 0.4, 0.8), vec3(0.0, 0.0, 0.0), intensity * 0.5 + 0.1);\r\n                        \r\n                        gl_FragColor = vec4(color, intensity * 0.7);\r\n                    }\r\n                `,\r\n                transparent: true,\r\n                side: THREE.BackSide\r\n            });\r\n\r\n            atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);\r\n            scene.add(atmosphere);\r\n        }\r\n\r\n        function createOcean() {\r\n            const oceanGeometry = new THREE.SphereGeometry(9.8, 64, 64);\r\n\r\n            // Create ocean material with reflective properties\r\n            const oceanMaterial = new THREE.MeshPhongMaterial({\r\n                color: 0x1a5fb4,\r\n                transparent: true,\r\n                opacity: 0.7,\r\n                specular: 0xffffff,\r\n                shininess: 100,\r\n                side: THREE.DoubleSide\r\n            });\r\n\r\n            ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);\r\n            scene.add(ocean);\r\n        }\r\n\r\n        function createClouds() {\r\n            const cloudGeometry = new THREE.SphereGeometry(10.3, 64, 64);\r\n\r\n            // Create procedural cloud material\r\n            const cloudMaterial = new THREE.ShaderMaterial({\r\n                uniforms: {\r\n                    time: { value: 0 }\r\n                },\r\n                vertexShader: `\r\n                    varying vec3 vNormal;\r\n                    varying vec3 vPosition;\r\n                    \r\n                    void main() {\r\n                        vNormal = normalize(normalMatrix * normal);\r\n                        vPosition = position;\r\n                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n                    }\r\n                `,\r\n                fragmentShader: `\r\n                    uniform float time;\r\n                    varying vec3 vNormal;\r\n                    varying vec3 vPosition;\r\n                    \r\n                    // Simple noise function\r\n                    float noise(vec3 p) {\r\n                        return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);\r\n                    }\r\n                    \r\n                    void main() {\r\n                        // Create cloud pattern with noise\r\n                        float n = noise(vPosition * 2.0 + time * 0.01);\r\n                        \r\n                        // Simple cloud shape - denser in center, thinner at edges\r\n                        vec3 cloudColor = vec3(1.0, 1.0, 1.0) * (n * 0.8 + 0.2);\r\n                        \r\n                        // Create some variation with distance from center\r\n                        float distFromCenter = length(vPosition) - 10.3;\r\n                        float density = max(0.0, 1.0 - abs(distFromCenter));\r\n                        \r\n                        // Combine noise and distance for cloud shape\r\n                        float alpha = clamp(n * density * 0.5 + 0.2, 0.0, 1.0);\r\n                        \r\n                        gl_FragColor = vec4(cloudColor, alpha * 0.3);\r\n                    }\r\n                `,\r\n                transparent: true,\r\n                side: THREE.DoubleSide\r\n            });\r\n\r\n            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);\r\n            scene.add(clouds);\r\n        }\r\n\r\n        function setupLighting() {\r\n            // Create directional light (sun)\r\n            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);\r\n            sunLight.position.set(5, 3, 5);\r\n            scene.add(sunLight);\r\n\r\n            // Add ambient light for better visibility\r\n            const ambientLight = new THREE.AmbientLight(0x222222);\r\n            scene.add(ambientLight);\r\n        }\r\n\r\n        function addStars() {\r\n            const starGeometry = new THREE.BufferGeometry();\r\n            const starMaterial = new THREE.PointsMaterial({\r\n                color: 0xffffff,\r\n                size: 0.2,\r\n                transparent: true\r\n            });\r\n\r\n            const starVertices = [];\r\n            for (let i = 0; i < 10000; i++) {\r\n                const x = (Math.random() - 0.5) * 2000;\r\n                const y = (Math.random() - 0.5) * 2000;\r\n                const z = (Math.random() - 0.5) * 2000;\r\n                starVertices.push(x, y, z);\r\n            }\r\n\r\n            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));\r\n            const stars = new THREE.Points(starGeometry, starMaterial);\r\n            scene.add(stars);\r\n        }\r\n\r\n        function toggleRotation() {\r\n            rotationEnabled = !rotationEnabled;\r\n            document.getElementById('rotateBtn').textContent =\r\n                rotationEnabled ? 'Pause Rotation' : 'Resume Rotation';\r\n        }\r\n\r\n        function resetView() {\r\n            camera.position.set(0, 0, 35);\r\n            controls.reset();\r\n        }\r\n\r\n        function onWindowResize() {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n\r\n            // Update time for shaders\r\n            const elapsedTime = performance.now() * 0.001;\r\n\r\n            if (planet) planet.material.uniforms.time.value = elapsedTime;\r\n            if (atmosphere) atmosphere.material.uniforms.time.value = elapsedTime;\r\n            if (clouds) clouds.material.uniforms.time.value = elapsedTime;\r\n\r\n            // Rotate planet and clouds\r\n            if (rotationEnabled) {\r\n                if (planet) planet.rotation.y += rotationSpeed;\r\n                if (ocean) ocean.rotation.y += rotationSpeed * 0.8;\r\n                if (clouds) clouds.rotation.y += rotationSpeed * 1.2;\r\n            }\r\n\r\n            // Update controls\r\n            controls.update();\r\n\r\n            renderer.render(scene, camera);\r\n        }\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "biome-qwen-coder-30b-a3b",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Procedural Generation",
      "Astronomy",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:58.100Z",
    "model": "qwen-coder-30b-a3b",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, procedural generation, astronomy, architecture."
  }
}
