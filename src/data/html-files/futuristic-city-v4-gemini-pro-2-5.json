{
  "title": "Futuristic Cityscape Simulation",
  "htmlContent": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Futuristic Cityscape Simulation</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000;\n            color: #fff;\n            font-family: Arial, sans-serif;\n        }\n\n        canvas {\n            display: block;\n        }\n\n        #ui-controls {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            background: rgba(20, 20, 30, 0.85);\n            padding: 15px;\n            border-radius: 8px;\n            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);\n            border: 1px solid rgba(0, 255, 255, 0.3);\n        }\n\n        #ui-controls h3 {\n            margin-top: 0;\n            color: #00ffff;\n            text-align: center;\n            border-bottom: 1px solid #00ffff;\n            padding-bottom: 5px;\n        }\n\n        #ui-controls div {\n            margin-bottom: 10px;\n        }\n\n        #ui-controls label {\n            display: inline-block;\n            width: 150px;\n            color: #ccc;\n        }\n\n        #ui-controls input[type=\"number\"] {\n            width: 60px;\n            background-color: #111;\n            color: #0f0;\n            border: 1px solid #00ffff;\n            border-radius: 3px;\n            padding: 3px;\n        }\n\n        #ui-controls button {\n            display: block;\n            width: 100%;\n            padding: 8px;\n            background-color: #007bff;\n            color: white;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n            margin-top: 10px;\n        }\n\n        #ui-controls button:hover {\n            background-color: #0056b3;\n        }\n\n        #timeDisplay {\n            margin-top: 10px;\n            font-size: 0.9em;\n            color: #0f0;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"ui-controls\">\n        <h3>City Controls</h3>\n        <div>\n            <label for=\"gridSizeInput\">Grid Size (N x N):</label>\n            <input type=\"number\" id=\"gridSizeInput\" value=\"12\" min=\"5\" max=\"25\" step=\"1\">\n        </div>\n        <div>\n            <label for=\"cityScaleInput\">Max Building Height:</label>\n            <input type=\"number\" id=\"cityScaleInput\" value=\"30\" min=\"10\" max=\"60\" step=\"1\">\n        </div>\n        <div>\n            <label for=\"vehicleCountInput\">Vehicle Count:</label>\n            <input type=\"number\" id=\"vehicleCountInput\" value=\"25\" min=\"0\" max=\"100\" step=\"1\">\n        </div>\n        <div>\n            <label for=\"buildingDensityInput\">Building Density:</label>\n            <input type=\"range\" id=\"buildingDensityInput\" value=\"60\" min=\"0\" max=\"90\" step=\"1\">\n        </div>\n        <div>\n            <label for=\"peopleCountInput\">People Count:</label>\n            <input type=\"number\" id=\"peopleCountInput\" value=\"50\" min=\"0\" max=\"200\" step=\"1\">\n        </div>\n        <button id=\"regenerateButton\">Regenerate City</button>\n        <div id=\"timeDisplay\">Time: 00:00</div>\n    </div>\n\n    <!-- Import map for three.js and its addons -->\n    <script type=\"importmap\">\n    {\n      \"imports\": {\n        \"three\": \"https://unpkg.com/three@0.165.0/build/three.module.js\",\n        \"three/addons/\": \"https://unpkg.com/three@0.165.0/examples/jsm/\"\n      }\n    }\n  </script>\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n        let scene, camera, renderer, controls;\n        const clock = new THREE.Clock();\n\n        const config = {\n            gridSize: 12,\n            cityScale: 30, // Max additional building height\n            vehicleCount: 25,\n            peopleCount: 50,\n            buildingDensity: 60, // Percentage\n            cellSize: 8,\n            dayDuration: 240, // seconds for a full 24h cycle (4 minutes)\n            maxBuildingSegments: 4,\n            buildingBaseMinHeight: 3,\n            buildingSegmentMinHeight: 2,\n        };\n\n        let cityGroup = new THREE.Group();\n        let vehicleGroup = new THREE.Group();\n        let peopleGroup = new THREE.Group();\n        let sewerGroup = new THREE.Group();\n        let streetLightMeshes = []; // For emissive meshes\n        let streetLightSources = []; // For actual lights\n\n        let sunLight, ambientLight;\n        let timeOfDay = 0.25; // 0 (midnight) to 1 (next midnight), start at sunrise (6 AM)\n\n        const vehicles = [];\n        const vehiclePaths = [];\n        const people = [];\n        const peoplePaths = [];\n\n        // Building materials\n        const buildingMaterials = [\n            new THREE.MeshStandardMaterial({ color: 0x606070, roughness: 0.7, metalness: 0.3 }),\n            new THREE.MeshStandardMaterial({ color: 0x707080, roughness: 0.6, metalness: 0.4 }),\n            new THREE.MeshStandardMaterial({ color: 0x505060, roughness: 0.8, metalness: 0.2 }),\n        ];\n        const windowMaterial = new THREE.MeshStandardMaterial({ emissive: 0x000000, emissiveIntensity: 1, color: 0x111122 }); // Emissive turns on at night\n\n        init();\n        animate();\n\n        function init() {\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(0x000000); // Initial background\n            scene.fog = new THREE.Fog(0x050515, 50, 400);\n\n            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);\n\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.shadowMap.enabled = true;\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows\n            document.body.appendChild(renderer.domElement);\n\n            controls = new OrbitControls(camera, renderer.domElement);\n            controls.enableDamping = true;\n            controls.dampingFactor = 0.05;\n            controls.screenSpacePanning = false;\n            controls.minDistance = 20;\n            controls.maxDistance = 600;\n\n            setupLights();\n\n            // Initial city generation based on default config\n            document.getElementById('gridSizeInput').value = config.gridSize;\n            document.getElementById('cityScaleInput').value = config.cityScale;\n            document.getElementById('vehicleCountInput').value = config.vehicleCount;\n            document.getElementById('buildingDensityInput').value = config.buildingDensity;\n            document.getElementById('peopleCountInput').value = config.peopleCount;\n\n            regenerateWorld();\n\n            setupUI();\n\n            window.addEventListener('resize', onWindowResize, false);\n        }\n\n        function setupLights() {\n            ambientLight = new THREE.AmbientLight(0x404050, 0.5); // Soft ambient light\n            scene.add(ambientLight);\n\n            sunLight = new THREE.DirectionalLight(0xffffff, 1);\n            sunLight.castShadow = true;\n            sunLight.shadow.mapSize.width = 2048;\n            sunLight.shadow.mapSize.height = 2048;\n            sunLight.shadow.camera.near = 0.5;\n            sunLight.shadow.camera.far = 500; // Adjust based on city size\n            scene.add(sunLight);\n            scene.add(sunLight.target); // Target for directional light\n        }\n\n        function updateCameraAndControls() {\n            const cityDimension = config.gridSize * config.cellSize;\n            camera.position.set(cityDimension * 0.7, cityDimension * 0.5, cityDimension * 0.9);\n            controls.target.set(cityDimension * 0.2, 0, cityDimension * 0.2); // Look towards city center\n            controls.maxDistance = cityDimension * 2;\n            sunLight.shadow.camera.far = cityDimension * 2.5;\n            const shadowCamSize = cityDimension * 0.75;\n            sunLight.shadow.camera.left = -shadowCamSize;\n            sunLight.shadow.camera.right = shadowCamSize;\n            sunLight.shadow.camera.top = shadowCamSize;\n            sunLight.shadow.camera.bottom = -shadowCamSize;\n            sunLight.shadow.camera.updateProjectionMatrix();\n            scene.fog.near = cityDimension * 0.2;\n            scene.fog.far = cityDimension * 2;\n        }\n\n        function clearSceneGroup(group) {\n            while (group.children.length > 0) {\n                const child = group.children[0];\n                if (child.geometry) child.geometry.dispose();\n                if (child.material) {\n                    if (Array.isArray(child.material)) {\n                        child.material.forEach(m => m.dispose());\n                    } else {\n                        child.material.dispose();\n                    }\n                }\n                group.remove(child);\n            }\n        }\n\n        function cleanupCity() {\n            clearSceneGroup(cityGroup);\n            clearSceneGroup(vehicleGroup);\n            clearSceneGroup(peopleGroup);\n            clearSceneGroup(sewerGroup);\n\n            streetLightMeshes.forEach(mesh => {\n                if (mesh.geometry) mesh.geometry.dispose();\n                if (mesh.material) mesh.material.dispose();\n            });\n            streetLightMeshes = [];\n\n            streetLightSources.forEach(light => {\n                scene.remove(light); // If they were added to scene directly\n                light.dispose();\n            });\n            streetLightSources = [];\n\n            vehicles.length = 0;\n            vehiclePaths.length = 0;\n            people.length = 0;\n            peoplePaths.length = 0;\n        }\n\n        function regenerateWorld() {\n            cleanupCity();\n\n            scene.remove(cityGroup);\n            cityGroup = new THREE.Group();\n            scene.add(cityGroup);\n\n            scene.remove(vehicleGroup);\n            vehicleGroup = new THREE.Group();\n            scene.add(vehicleGroup);\n\n            scene.remove(peopleGroup);\n            peopleGroup = new THREE.Group();\n            scene.add(peopleGroup);\n\n            scene.remove(sewerGroup);\n            sewerGroup = new THREE.Group();\n            scene.add(sewerGroup);\n\n            updateCameraAndControls();\n            createCity();\n            createSewerSystem();\n            createVehiclePaths();\n            spawnVehicles();\n            createPeoplePaths();\n            spawnPeople();\n        }\n\n\n        function createCity() {\n            const groundSize = config.gridSize * config.cellSize;\n            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);\n            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x303030, roughness: 0.9 });\n            const ground = new THREE.Mesh(groundGeometry, groundMaterial);\n            ground.rotation.x = -Math.PI / 2;\n            ground.receiveShadow = true;\n            cityGroup.add(ground);\n\n            // Create water plane (optional, can be part of grid logic)\n            const waterSize = groundSize * 1.5; // Larger than ground\n            const waterGeometry = new THREE.PlaneGeometry(waterSize, waterSize);\n            const waterMaterial = new THREE.MeshStandardMaterial({\n                color: 0x003060,\n                transparent: true,\n                opacity: 0.7,\n                roughness: 0.2,\n                metalness: 0.1\n            });\n            const water = new THREE.Mesh(waterGeometry, waterMaterial);\n            water.rotation.x = -Math.PI / 2;\n            water.position.y = -0.5; // Slightly below ground\n            cityGroup.add(water);\n\n\n            for (let i = 0; i < config.gridSize; i++) {\n                for (let j = 0; j < config.gridSize; j++) {\n                    const x = (i - config.gridSize / 2 + 0.5) * config.cellSize;\n                    const z = (j - config.gridSize / 2 + 0.5) * config.cellSize;\n                    const rand = Math.random() * 100;\n\n                    if (rand < 5) { // Park\n                        createPark(x, z);\n                    } else if (rand < 10) { // Beach-like area (sandy color)\n                        createRecreationalArea(x, z, new THREE.Color(0xC2B280)); // Sandy color\n                    } else if (rand < 10 + config.buildingDensity) { // Building\n                        createBuilding(x, z);\n                    }\n                    // Else: empty space / road\n                }\n            }\n            // After creating the grid, define paths for people\n            createPeoplePaths();\n        }\n\n        function createPark(x, z) {\n            const parkSize = config.cellSize * 0.8;\n            const parkGeo = new THREE.PlaneGeometry(parkSize, parkSize);\n            const parkMat = new THREE.MeshStandardMaterial({ color: 0x33691E, roughness: 1 }); // Dark green\n            const parkMesh = new THREE.Mesh(parkGeo, parkMat);\n            parkMesh.rotation.x = -Math.PI / 2;\n            parkMesh.position.set(x, 0.01, z);\n            parkMesh.receiveShadow = true;\n            cityGroup.add(parkMesh);\n\n            // Add some simple \"trees\"\n            for (let k = 0; k < 3; k++) {\n                const treeRadius = config.cellSize * 0.05 + Math.random() * config.cellSize * 0.05;\n                const treeHeight = config.cellSize * 0.2 + Math.random() * config.cellSize * 0.2;\n\n                const trunkGeo = new THREE.CylinderGeometry(treeRadius * 0.3, treeRadius * 0.4, treeHeight, 8);\n                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4A3B31 });\n                const trunk = new THREE.Mesh(trunkGeo, trunkMat);\n                trunk.castShadow = true;\n                trunk.position.set(\n                    x + (Math.random() - 0.5) * parkSize * 0.7,\n                    treeHeight / 2,\n                    z + (Math.random() - 0.5) * parkSize * 0.7\n                );\n                cityGroup.add(trunk);\n\n                const foliageGeo = new THREE.SphereGeometry(treeRadius, 8, 6);\n                const foliageMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });\n                const foliage = new THREE.Mesh(foliageGeo, foliageMat);\n                foliage.castShadow = true;\n                foliage.position.set(trunk.position.x, treeHeight + treeRadius * 0.8, trunk.position.z);\n                cityGroup.add(foliage);\n            }\n        }\n\n        function createRecreationalArea(x, z, color) {\n            const areaSize = config.cellSize * 0.9;\n            const areaGeo = new THREE.PlaneGeometry(areaSize, areaSize);\n            const areaMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.9 });\n            const areaMesh = new THREE.Mesh(areaGeo, areaMat);\n            areaMesh.rotation.x = -Math.PI / 2;\n            areaMesh.position.set(x, 0.01, z);\n            areaMesh.receiveShadow = true;\n            cityGroup.add(areaMesh);\n        }\n\n        function createSewerSystem() {\n            const sewerY = -5; // How far below ground\n            const pipeRadius = 0.5;\n            const mainPipeMaterial = new THREE.MeshStandardMaterial({ color: 0x404040, roughness: 0.8, metalness: 0.5 });\n            const groundSize = config.gridSize * config.cellSize;\n\n            // Create a grid of pipes along the cell edges\n            for (let i = 0; i <= config.gridSize; i++) {\n                const pos = (i - config.gridSize / 2) * config.cellSize;\n\n                // Pipes along Z-axis (like vertical lines on the grid)\n                const pipeGeoZ = new THREE.CylinderGeometry(pipeRadius, pipeRadius, groundSize, 8);\n                const pipeZ = new THREE.Mesh(pipeGeoZ, mainPipeMaterial);\n                pipeZ.rotation.x = Math.PI / 2;\n                pipeZ.position.set(pos - config.cellSize / 2, sewerY, 0);\n                sewerGroup.add(pipeZ);\n\n                // Pipes along X-axis (like horizontal lines on the grid)\n                const pipeGeoX = new THREE.CylinderGeometry(pipeRadius, pipeRadius, groundSize, 8);\n                const pipeX = new THREE.Mesh(pipeGeoX, mainPipeMaterial);\n                pipeX.rotation.z = Math.PI / 2;\n                pipeX.position.set(0, sewerY, pos - config.cellSize / 2);\n                sewerGroup.add(pipeX);\n            }\n\n            // Create two sewer stations\n            const stationSize = config.cellSize * 0.75;\n            const stationHeight = 4;\n            const stationGeo = new THREE.CylinderGeometry(stationSize, stationSize, stationHeight, 16);\n            const stationMat = new THREE.MeshStandardMaterial({ color: 0x506050, roughness: 0.9 });\n\n            const station1 = new THREE.Mesh(stationGeo, stationMat);\n            // Position at a grid intersection corner\n            const station1X = (0 - config.gridSize / 2) * config.cellSize - config.cellSize / 2;\n            const station1Z = (0 - config.gridSize / 2) * config.cellSize - config.cellSize / 2;\n            station1.position.set(station1X, sewerY - stationHeight / 2, station1Z);\n            sewerGroup.add(station1);\n\n            const station2 = new THREE.Mesh(stationGeo, stationMat.clone());\n            // Position at the opposite corner\n            const station2X = (config.gridSize - config.gridSize / 2) * config.cellSize - config.cellSize / 2;\n            const station2Z = (config.gridSize - config.gridSize / 2) * config.cellSize - config.cellSize / 2;\n            station2.position.set(station2X, sewerY - stationHeight / 2, station2Z);\n            sewerGroup.add(station2);\n        }\n\n\n        function createBuilding(x, z) {\n            const building = new THREE.Group();\n            let currentHeight = 0;\n            const numSegments = 1 + Math.floor(Math.random() * config.maxBuildingSegments);\n            let baseWidth = config.cellSize * (0.5 + Math.random() * 0.4);\n            let baseDepth = config.cellSize * (0.5 + Math.random() * 0.4);\n\n            for (let i = 0; i < numSegments; i++) {\n                const segmentHeight = config.buildingSegmentMinHeight + Math.random() * (config.cityScale / numSegments);\n                const segmentWidth = baseWidth * (1 - i * 0.15); // Tapering\n                const segmentDepth = baseDepth * (1 - i * 0.15);\n\n                if (segmentWidth < 1 || segmentDepth < 1) break;\n\n                const segmentGeo = new THREE.BoxGeometry(segmentWidth, segmentHeight, segmentDepth);\n                const material = buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)];\n                const segmentMesh = new THREE.Mesh(segmentGeo, material.clone()); // Clone material for potential window modification\n\n                segmentMesh.castShadow = true;\n                segmentMesh.receiveShadow = true;\n                segmentMesh.position.y = currentHeight + segmentHeight / 2;\n                building.add(segmentMesh);\n\n                // Add \"windows\" - simple emissive planes that light up at night\n                if (Math.random() < 0.7) { // 70% chance of windows on a segment\n                    const windowRows = Math.floor(segmentHeight / 1.5);\n                    const windowCols = Math.floor(segmentWidth / 1.5);\n                    const windowDepth = 0.1;\n                    const windowPlaneGeo = new THREE.PlaneGeometry(0.8, 0.8); // Small window\n\n                    for (let face = 0; face < 4; face++) { // 4 sides\n                        for (let r = 0; r < windowRows; r++) {\n                            for (let c = 0; c < windowCols; c++) {\n                                const windowMesh = new THREE.Mesh(windowPlaneGeo, windowMaterial);\n                                const pos = {\n                                    x: (c - (windowCols - 1) / 2) * 1.5,\n                                    y: (r - (windowRows - 1) / 2) * 1.5\n                                };\n\n                                if (face === 0) windowMesh.position.set(pos.x, pos.y, segmentDepth / 2 + windowDepth);\n                                else if (face === 1) windowMesh.position.set(pos.x, pos.y, -segmentDepth / 2 - windowDepth);\n                                else if (face === 2) {\n                                    windowMesh.position.set(segmentWidth / 2 + windowDepth, pos.y, pos.x);\n                                    windowMesh.rotation.y = Math.PI / 2;\n                                } else {\n                                    windowMesh.position.set(-segmentWidth / 2 - windowDepth, pos.y, pos.x);\n                                    windowMesh.rotation.y = -Math.PI / 2;\n                                }\n\n                                segmentMesh.add(windowMesh);\n                            }\n                        }\n                    }\n                }\n                currentHeight += segmentHeight;\n            }\n\n            building.position.set(x, 0, z);\n            cityGroup.add(building);\n\n            // Add sewer connection pipe\n            const sewerY = -5;\n            const connectionPipeRadius = 0.3;\n            const connectionPipeHeight = Math.abs(sewerY);\n            const connectionPipeGeo = new THREE.CylinderGeometry(connectionPipeRadius, connectionPipeRadius, connectionPipeHeight, 8);\n            const connectionPipeMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });\n            const connectionPipe = new THREE.Mesh(connectionPipeGeo, connectionPipeMat);\n            connectionPipe.position.set(x, -connectionPipeHeight / 2, z);\n            sewerGroup.add(connectionPipe);\n\n            // Add streetlight if building is not too tall\n            if (currentHeight < config.cityScale * 0.4 && Math.random() < 0.3) {\n                createStreetLight(x, z, currentHeight + 2);\n            }\n        }\n\n        function createStreetLight(x, z, height) {\n            const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, height, 8);\n            const poleMat = new THREE.MeshStandardMaterial({ color: 0x444444 });\n            const pole = new THREE.Mesh(poleGeo, poleMat);\n            pole.position.set(x, height / 2, z);\n            pole.castShadow = true;\n            cityGroup.add(pole);\n\n            const lightBulbGeo = new THREE.SphereGeometry(0.3, 8, 8);\n            const lightBulbMat = new THREE.MeshStandardMaterial({ emissive: 0xffff00, emissiveIntensity: 0, color: 0xffff00 }); // Emissive off initially\n            const lightBulbMesh = new THREE.Mesh(lightBulbGeo, lightBulbMat);\n            lightBulbMesh.position.set(x, height + 0.3, z);\n            cityGroup.add(lightBulbMesh);\n            streetLightMeshes.push(lightBulbMesh);\n\n            const pointLight = new THREE.PointLight(0xffffaa, 0, 20, 1); // Intensity 0 initially, decay 1\n            pointLight.position.set(x, height + 0.5, z);\n            pointLight.castShadow = false; // Performance: streetlights don't cast shadows\n            cityGroup.add(pointLight);\n            streetLightSources.push(pointLight);\n        }\n\n\n        function createVehicleModel() {\n            const group = new THREE.Group();\n            const bodyMat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, metalness: 0.6, roughness: 0.4 });\n            const bodyGeo = new THREE.BoxGeometry(2.5, 0.6, 1.2);\n            const body = new THREE.Mesh(bodyGeo, bodyMat);\n            body.castShadow = true;\n            group.add(body);\n\n            const cockpitGeo = new THREE.BoxGeometry(0.8, 0.4, 0.7);\n            const cockpitMat = new THREE.MeshStandardMaterial({ color: 0x3333dd, transparent: true, opacity: 0.6 });\n            const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);\n            cockpit.position.set(0.5, 0.3, 0);\n            body.add(cockpit);\n\n            // Headlights\n            const headlightMat = new THREE.MeshStandardMaterial({ emissive: 0xffffff, color: 0xffffff, emissiveIntensity: 0 });\n            const headlightGeo = new THREE.SphereGeometry(0.15, 8, 8);\n            const headlightL = new THREE.Mesh(headlightGeo, headlightMat);\n            headlightL.position.set(1.25, 0, 0.4);\n            body.add(headlightL);\n            const headlightR = new THREE.Mesh(headlightGeo, headlightMat);\n            headlightR.position.set(1.25, 0, -0.4);\n            body.add(headlightR);\n            group.userData.headlights = [headlightL, headlightR];\n\n\n            // Taillights\n            const taillightMat = new THREE.MeshStandardMaterial({ emissive: 0xff0000, color: 0xff0000, emissiveIntensity: 0 });\n            const taillightGeo = new THREE.BoxGeometry(0.1, 0.2, 0.4);\n            const taillightL = new THREE.Mesh(taillightGeo, taillightMat);\n            taillightL.position.set(-1.25, 0, 0.3);\n            body.add(taillightL);\n            const taillightR = new THREE.Mesh(taillightGeo, taillightMat);\n            taillightR.position.set(-1.25, 0, -0.3);\n            body.add(taillightR);\n            group.userData.taillights = [taillightL, taillightR];\n\n            return group;\n        }\n\n        function createVehiclePaths() {\n            const numPaths = Math.max(5, Math.floor(config.vehicleCount / 3));\n            const cityWidth = config.gridSize * config.cellSize;\n            const minHeight = config.cityScale + 10; // Above highest possible building segment\n            const maxHeight = minHeight + 30;\n\n            for (let i = 0; i < numPaths; i++) {\n                const points = [];\n                const numPoints = 5 + Math.floor(Math.random() * 5);\n                for (let j = 0; j < numPoints; j++) {\n                    points.push(new THREE.Vector3(\n                        (Math.random() - 0.5) * cityWidth * 1.2, // Slightly outside grid\n                        minHeight + Math.random() * (maxHeight - minHeight),\n                        (Math.random() - 0.5) * cityWidth * 1.2\n                    ));\n                }\n                points.push(points[0]); // Close the loop\n                const curve = new THREE.CatmullRomCurve3(points);\n                curve.curveType = 'catmullrom';\n                curve.tension = 0.5;\n                vehiclePaths.push(curve);\n\n                // Optional: visualize paths\n                // const lineGeo = new THREE.BufferGeometry().setFromPoints(curve.getPoints(50));\n                // const lineMat = new THREE.LineBasicMaterial({ color: 0xff0000 });\n                // const curveObject = new THREE.Line(lineGeo, lineMat);\n                // cityGroup.add(curveObject);\n            }\n        }\n\n        function spawnVehicles() {\n            if (vehiclePaths.length === 0) return;\n            for (let i = 0; i < config.vehicleCount; i++) {\n                const model = createVehicleModel();\n                const path = vehiclePaths[Math.floor(Math.random() * vehiclePaths.length)];\n                const speed = 0.01 + Math.random() * 0.02; // Speed as fraction of path per second\n                const progress = Math.random(); // Start at random point on path\n\n                vehicles.push({ model, path, speed, progress });\n                vehicleGroup.add(model);\n            }\n        }\n\n        function updateVehicles(delta) {\n            vehicles.forEach(v => {\n                v.progress = (v.progress + v.speed * delta) % 1;\n                const position = v.path.getPointAt(v.progress);\n                v.model.position.copy(position);\n\n                const tangent = v.path.getTangentAt(v.progress).normalize();\n                const nextPosition = v.path.getPointAt((v.progress + 0.001) % 1); // Look slightly ahead\n                v.model.lookAt(nextPosition);\n            });\n        }\n\n        function createPersonModel() {\n            const personHeight = 1.8;\n            const group = new THREE.Group();\n\n            // Body\n            const bodyGeo = new THREE.CylinderGeometry(0.2, 0.15, personHeight * 0.5, 8);\n            const bodyMat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, roughness: 0.8 });\n            const body = new THREE.Mesh(bodyGeo, bodyMat);\n            body.position.y = personHeight * 0.45;\n            body.castShadow = true;\n            group.add(body);\n\n            // Head\n            const headGeo = new THREE.SphereGeometry(0.2, 16, 16);\n            const headMat = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.7 });\n            const head = new THREE.Mesh(headGeo, headMat);\n            head.position.y = personHeight * 0.85;\n            head.castShadow = true;\n            group.add(head);\n\n            group.userData.mixer = null; // To store animation mixer\n\n            return group;\n        }\n\n        function createPeoplePaths() {\n            const cityWidth = config.gridSize * config.cellSize;\n            const halfWidth = cityWidth / 2;\n\n            // Create paths along the grid lines (sidewalks)\n            for (let i = 0; i <= config.gridSize; i++) {\n                const x = (i - config.gridSize / 2) * config.cellSize;\n                // Horizontal path\n                let pointsH = [new THREE.Vector3(x, 0.1, -halfWidth), new THREE.Vector3(x, 0.1, halfWidth)];\n                peoplePaths.push(new THREE.LineCurve3(pointsH[0], pointsH[1]));\n\n                // Vertical path\n                let pointsV = [new THREE.Vector3(-halfWidth, 0.1, x), new THREE.Vector3(halfWidth, 0.1, x)];\n                peoplePaths.push(new THREE.LineCurve3(pointsV[0], pointsV[1]));\n            }\n        }\n\n        function spawnPeople() {\n            if (peoplePaths.length === 0) return;\n\n            for (let i = 0; i < config.peopleCount; i++) {\n                const model = createPersonModel();\n                const path = peoplePaths[Math.floor(Math.random() * peoplePaths.length)];\n                const speed = 0.5 + Math.random() * 0.5; // Units per second\n                const progress = Math.random(); // Start at random point\n                const direction = Math.random() < 0.5 ? 1 : -1; // Walk in either direction\n\n                people.push({ model, path, speed, progress, direction });\n                peopleGroup.add(model);\n            }\n        }\n\n        function updatePeople(delta) {\n            people.forEach(p => {\n                const pathLength = p.path.getLength();\n                let distance = p.speed * delta;\n\n                p.progress += (distance / pathLength) * p.direction;\n\n                if (p.progress > 1 || p.progress < 0) {\n                    // Reverse direction or pick a new path\n                    p.direction *= -1;\n                    p.progress = THREE.MathUtils.clamp(p.progress, 0, 1);\n\n                    // Optional: 20% chance to switch to an intersecting path\n                    if (Math.random() < 0.2) {\n                        const newPath = peoplePaths[Math.floor(Math.random() * peoplePaths.length)];\n                        p.path = newPath;\n                        p.progress = Math.random(); // Start at a random spot on the new path\n                    }\n                }\n\n                const position = p.path.getPointAt(p.progress);\n                p.model.position.copy(position);\n\n                // Make them look where they are going\n                const nextProgress = THREE.MathUtils.clamp(p.progress + 0.01 * p.direction, 0, 1);\n                const nextPosition = p.path.getPointAt(nextProgress);\n                p.model.lookAt(nextPosition.x, 0.1, nextPosition.z);\n\n                // Simple walking animation\n                const time = clock.getElapsedTime();\n                p.model.children[0].position.y = 0.9 + Math.sin(time * p.speed * 5) * 0.05; // Bobbing body\n            });\n        }\n\n        function updateDayNightCycle(delta) {\n            timeOfDay = (timeOfDay + delta / config.dayDuration) % 1;\n\n            const hours = Math.floor(timeOfDay * 24);\n            const minutes = Math.floor((timeOfDay * 24 * 60) % 60);\n            document.getElementById('timeDisplay').textContent = `Time: ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;\n\n            // Sun position (simple circular path)\n            const sunAngle = timeOfDay * Math.PI * 2 - Math.PI / 2; // Offset to have noon at top\n            const cityCenter = config.gridSize * config.cellSize / 2;\n            sunLight.position.set(\n                cityCenter + Math.cos(sunAngle) * cityCenter * 2,\n                Math.sin(sunAngle) * cityCenter * 1.5, // Sun height\n                cityCenter + Math.sin(sunAngle) * cityCenter * 0.5 // Some Z variation\n            );\n            sunLight.target.position.set(cityCenter * 0.5, 0, cityCenter * 0.5); // Target center of city\n\n            // Light intensity and color\n            let sunIntensity, ambientIntensityFactor;\n            let skyColor = new THREE.Color();\n            let fogColor = new THREE.Color();\n            let windowEmissive = 0x000000;\n            let vehicleLightIntensity = 0;\n            let streetLightIntensity = 0;\n            let streetLightSourceIntensity = 0;\n\n            if (timeOfDay > 0.23 && timeOfDay < 0.27) { // Sunrise (5:30 - 6:30 AM)\n                const t = (timeOfDay - 0.23) / 0.04; // Normalize 0-1\n                sunIntensity = THREE.MathUtils.lerp(0.0, 1.2, t);\n                ambientIntensityFactor = THREE.MathUtils.lerp(0.3, 0.6, t);\n                skyColor.lerpColors(new THREE.Color(0x101020), new THREE.Color(0xffa500), t); // Dark blue to orange\n                fogColor.lerpColors(new THREE.Color(0x050510), new THREE.Color(0x886644), t);\n                vehicleLightIntensity = THREE.MathUtils.lerp(1, 0.5, t);\n                streetLightIntensity = THREE.MathUtils.lerp(2, 0.5, t);\n                streetLightSourceIntensity = THREE.MathUtils.lerp(1, 0.2, t);\n            } else if (timeOfDay >= 0.27 && timeOfDay < 0.73) { // Daytime (6:30 AM - 5:30 PM)\n                sunIntensity = 1.2;\n                ambientIntensityFactor = 0.6;\n                skyColor.set(0x87CEEB); // Sky blue\n                fogColor.set(0xaaaaee);\n                windowEmissive = 0x000000;\n                vehicleLightIntensity = 0;\n                streetLightIntensity = 0;\n                streetLightSourceIntensity = 0;\n            } else if (timeOfDay >= 0.73 && timeOfDay < 0.77) { // Sunset (5:30 PM - 6:30 PM)\n                const t = (timeOfDay - 0.73) / 0.04; // Normalize 0-1\n                sunIntensity = THREE.MathUtils.lerp(1.2, 0.0, t);\n                ambientIntensityFactor = THREE.MathUtils.lerp(0.6, 0.3, t);\n                skyColor.lerpColors(new THREE.Color(0xffa500), new THREE.Color(0x101020), t); // Orange to dark blue\n                fogColor.lerpColors(new THREE.Color(0x886644), new THREE.Color(0x050510), t);\n                windowEmissive = new THREE.Color(0xffffaa).multiplyScalar(t * 0.5).getHex();\n                vehicleLightIntensity = THREE.MathUtils.lerp(0.5, 1, t);\n                streetLightIntensity = THREE.MathUtils.lerp(0.5, 2, t);\n                streetLightSourceIntensity = THREE.MathUtils.lerp(0.2, 1, t);\n            } else { // Nighttime\n                sunIntensity = 0.0;\n                ambientIntensityFactor = 0.2; // Darker ambient for night\n                skyColor.set(0x050515); // Very dark blue\n                fogColor.set(0x020205);\n                windowEmissive = 0xffffaa; // Bright windows\n                vehicleLightIntensity = 1;\n                streetLightIntensity = 2;\n                streetLightSourceIntensity = 1;\n            }\n\n            sunLight.intensity = sunIntensity;\n            ambientLight.intensity = ambientIntensityFactor;\n            scene.background.copy(skyColor);\n            scene.fog.color.copy(fogColor);\n\n            // Update window emissive material\n            windowMaterial.emissive.setHex(windowEmissive);\n            windowMaterial.emissiveIntensity = (windowEmissive === 0x000000) ? 0 : 1;\n\n\n            // Update vehicle lights\n            vehicles.forEach(v => {\n                v.model.userData.headlights.forEach(light => light.material.emissiveIntensity = vehicleLightIntensity);\n                v.model.userData.taillights.forEach(light => light.material.emissiveIntensity = vehicleLightIntensity);\n            });\n\n            // Update street lights\n            streetLightMeshes.forEach(mesh => mesh.material.emissiveIntensity = streetLightIntensity);\n            streetLightSources.forEach(light => light.intensity = streetLightSourceIntensity);\n        }\n\n        function setupUI() {\n            document.getElementById('regenerateButton').addEventListener('click', () => {\n                config.gridSize = parseInt(document.getElementById('gridSizeInput').value);\n                config.cityScale = parseInt(document.getElementById('cityScaleInput').value);\n                config.vehicleCount = parseInt(document.getElementById('vehicleCountInput').value);\n                config.buildingDensity = parseInt(document.getElementById('buildingDensityInput').value);\n                config.peopleCount = parseInt(document.getElementById('peopleCountInput').value);\n                regenerateWorld();\n            });\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n            const delta = clock.getDelta();\n\n            updateDayNightCycle(delta);\n            updateVehicles(delta);\n            updatePeople(delta);\n\n            controls.update();\n            renderer.render(scene, camera);\n        }\n    </script>\n</body>\n\n</html>",
  "id": "futuristic-city-v4-gemini-pro-2-5",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.941Z",
    "model": "gemini-pro-2.5",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, astronomy, simulation, architecture."
  }
}
