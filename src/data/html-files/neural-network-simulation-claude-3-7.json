{
  "title": "3D Neural Network Simulation",
  "htmlContent": "<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <title>3D Neural Network Simulation</title>\r\n  <style>\r\n    body {\r\n      margin: 0;\r\n      overflow: hidden;\r\n      font-family: Arial, sans-serif;\r\n    }\r\n    #info {\r\n      position: absolute;\r\n      top: 10px;\r\n      left: 10px;\r\n      background: rgba(0, 0, 0, 0.7);\r\n      color: white;\r\n      padding: 10px;\r\n      border-radius: 5px;\r\n      z-index: 100;\r\n    }\r\n    #controls {\r\n      position: absolute;\r\n      bottom: 10px;\r\n      left: 10px;\r\n      background: rgba(0, 0, 0, 0.7);\r\n      color: white;\r\n      padding: 10px;\r\n      border-radius: 5px;\r\n      z-index: 100;\r\n    }\r\n    button {\r\n      margin: 5px;\r\n      padding: 5px 10px;\r\n      background: #3498db;\r\n      color: white;\r\n      border: none;\r\n      border-radius: 4px;\r\n      cursor: pointer;\r\n    }\r\n  </style>\r\n</head>\r\n<body>\r\n  <div id=\"info\">\r\n    <h2>Neural Network Simulation</h2>\r\n    <p>Click and drag to rotate. Scroll to zoom.</p>\r\n    <p>Click on a node to fire it.</p>\r\n  </div>\r\n  \r\n  <div id=\"controls\">\r\n    <button id=\"randomFire\">Fire Random Node</button>\r\n    <button id=\"resetNetwork\">Reset Network</button>\r\n  </div>\r\n\r\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\r\n  <script>\r\n    // Main variables\r\n    let scene, camera, renderer;\r\n    let nodes = [];\r\n    let connections = [];\r\n    let signals = [];\r\n    \r\n    // Initialize\r\n    init();\r\n    animate();\r\n    \r\n    function init() {\r\n      // Create scene\r\n      scene = new THREE.Scene();\r\n      scene.background = new THREE.Color(0x111827);\r\n      \r\n      // Create camera\r\n      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n      camera.position.z = 40;\r\n      \r\n      // Create renderer\r\n      renderer = new THREE.WebGLRenderer({ antialias: true });\r\n      renderer.setSize(window.innerWidth, window.innerHeight);\r\n      document.body.appendChild(renderer.domElement);\r\n      \r\n      // Add lights\r\n      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);\r\n      scene.add(ambientLight);\r\n      \r\n      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\r\n      directionalLight.position.set(0, 10, 10);\r\n      scene.add(directionalLight);\r\n      \r\n      // Create neural network\r\n      createNetwork(4, 5);\r\n      \r\n      // Setup controls\r\n      setupMouseControls();\r\n      \r\n      // Setup UI controls\r\n      document.getElementById('randomFire').addEventListener('click', fireRandomNode);\r\n      document.getElementById('resetNetwork').addEventListener('click', resetNetwork);\r\n      \r\n      // Handle window resize\r\n      window.addEventListener('resize', onWindowResize);\r\n    }\r\n    \r\n    function createNetwork(layers, nodesPerLayer) {\r\n      const layerDistance = 15;\r\n      \r\n      // Create nodes in layers\r\n      for (let layer = 0; layer < layers; layer++) {\r\n        const layerNodes = [];\r\n        const nodesInThisLayer = layer === 0 || layer === layers - 1 ? nodesPerLayer : nodesPerLayer + Math.floor(Math.random() * 3) - 1;\r\n        \r\n        for (let i = 0; i < nodesInThisLayer; i++) {\r\n          // Position nodes in a grid pattern\r\n          const x = (layer - (layers - 1) / 2) * layerDistance;\r\n          const y = (i - (nodesInThisLayer - 1) / 2) * 8;\r\n          const z = 0;\r\n          \r\n          const node = createNode(x, y, z, `L${layer}-N${i}`);\r\n          node.userData.layer = layer;\r\n          node.userData.index = i;\r\n          nodes.push(node);\r\n          layerNodes.push(node);\r\n        }\r\n        \r\n        // Connect to previous layer\r\n        if (layer > 0) {\r\n          const prevLayerNodes = nodes.filter(n => n.userData.layer === layer - 1);\r\n          \r\n          layerNodes.forEach(targetNode => {\r\n            // Each node connects to 1-3 nodes in previous layer\r\n            const connectionCount = 1 + Math.floor(Math.random() * 3);\r\n            \r\n            for (let c = 0; c < connectionCount; c++) {\r\n              const sourceNode = prevLayerNodes[Math.floor(Math.random() * prevLayerNodes.length)];\r\n              createConnection(sourceNode, targetNode);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    function createNode(x, y, z, id) {\r\n      const geometry = new THREE.SphereGeometry(1.5, 16, 16);\r\n      const material = new THREE.MeshPhongMaterial({\r\n        color: 0x3498db,\r\n        emissive: 0x0,\r\n        specular: 0xffffff,\r\n        shininess: 30\r\n      });\r\n      \r\n      const node = new THREE.Mesh(geometry, material);\r\n      node.position.set(x, y, z);\r\n      node.userData = {\r\n        id: id,\r\n        isActive: false,\r\n        connections: []\r\n      };\r\n      \r\n      scene.add(node);\r\n      return node;\r\n    }\r\n    \r\n    function createConnection(sourceNode, targetNode) {\r\n      // Create line between nodes\r\n      const points = [\r\n        sourceNode.position,\r\n        targetNode.position\r\n      ];\r\n      \r\n      const geometry = new THREE.BufferGeometry().setFromPoints(points);\r\n      const material = new THREE.LineBasicMaterial({\r\n        color: 0x4a5568,\r\n        opacity: 0.4,\r\n        transparent: true\r\n      });\r\n      \r\n      const connection = new THREE.Line(geometry, material);\r\n      connection.userData = {\r\n        sourceId: sourceNode.userData.id,\r\n        targetId: targetNode.userData.id\r\n      };\r\n      \r\n      // Store connection references\r\n      sourceNode.userData.connections.push(targetNode.userData.id);\r\n      targetNode.userData.connections.push(sourceNode.userData.id);\r\n      \r\n      scene.add(connection);\r\n      connections.push(connection);\r\n      \r\n      return connection;\r\n    }\r\n    \r\n    function fireNode(node, strength = 1.0) {\r\n      if (node.userData.isActive) return;\r\n      \r\n      // Activate node\r\n      node.userData.isActive = true;\r\n      \r\n      // Visual effect\r\n      const originalColor = node.material.color.clone();\r\n      const originalEmissive = node.material.emissive.clone();\r\n      const originalScale = node.scale.clone();\r\n      \r\n      // Change color to orange/yellow\r\n      node.material.color.set(0xf39c12);\r\n      node.material.emissive.set(0x663300);\r\n      \r\n      // Scale up\r\n      node.scale.set(1.3, 1.3, 1.3);\r\n      \r\n      // Propagate to connected nodes in next layer\r\n      const currentLayer = node.userData.layer;\r\n      \r\n      // Find connected nodes in next layer\r\n      const connectedNodeIds = node.userData.connections;\r\n      connectedNodeIds.forEach(targetId => {\r\n        const targetNode = nodes.find(n => n.userData.id === targetId);\r\n        \r\n        if (targetNode && targetNode.userData.layer > currentLayer) {\r\n          // Create visual signal\r\n          createSignal(node, targetNode, strength);\r\n          \r\n          // Schedule target firing with delay\r\n          setTimeout(() => {\r\n            if (strength > 0.2) { // Only fire if signal is strong enough\r\n              fireNode(targetNode, strength * 0.8);\r\n            }\r\n          }, 500);\r\n        }\r\n      });\r\n      \r\n      // Reset node after delay\r\n      setTimeout(() => {\r\n        // Reset color and scale\r\n        node.material.color.copy(originalColor);\r\n        node.material.emissive.copy(originalEmissive);\r\n        node.scale.copy(originalScale);\r\n        node.userData.isActive = false;\r\n      }, 1000);\r\n    }\r\n    \r\n    function createSignal(sourceNode, targetNode, strength = 1.0) {\r\n      // Create a glowing pulse that travels from source to target\r\n      const signalGeometry = new THREE.SphereGeometry(0.5, 8, 8);\r\n      const signalMaterial = new THREE.MeshBasicMaterial({\r\n        color: 0xffaa00,\r\n        transparent: true,\r\n        opacity: 0.8\r\n      });\r\n      \r\n      const signal = new THREE.Mesh(signalGeometry, signalMaterial);\r\n      \r\n      // Set initial position at source node\r\n      signal.position.copy(sourceNode.position);\r\n      \r\n      signal.userData = {\r\n        sourcePos: sourceNode.position.clone(),\r\n        targetPos: targetNode.position.clone(),\r\n        progress: 0,\r\n        speed: 0.02,\r\n        strength: strength\r\n      };\r\n      \r\n      scene.add(signal);\r\n      signals.push(signal);\r\n      \r\n      return signal;\r\n    }\r\n    \r\n    function updateSignals() {\r\n      // Update all active signals\r\n      for (let i = signals.length - 1; i >= 0; i--) {\r\n        const signal = signals[i];\r\n        \r\n        // Update progress\r\n        signal.userData.progress += signal.userData.speed;\r\n        \r\n        // Update position\r\n        signal.position.lerpVectors(\r\n          signal.userData.sourcePos,\r\n          signal.userData.targetPos,\r\n          signal.userData.progress\r\n        );\r\n        \r\n        // Update color based on strength\r\n        signal.material.color.setHSL(0.1, 0.8, 0.5 * signal.userData.strength + 0.3);\r\n        \r\n        // Remove if complete\r\n        if (signal.userData.progress >= 1) {\r\n          scene.remove(signal);\r\n          signals.splice(i, 1);\r\n        }\r\n      }\r\n    }\r\n    \r\n    function fireRandomNode() {\r\n      // Find all input layer nodes (layer 0)\r\n      const inputNodes = nodes.filter(node => node.userData.layer === 0);\r\n      \r\n      if (inputNodes.length > 0) {\r\n        // Pick a random input node\r\n        const randomNode = inputNodes[Math.floor(Math.random() * inputNodes.length)];\r\n        fireNode(randomNode);\r\n      }\r\n    }\r\n    \r\n    function resetNetwork() {\r\n      // Reset all nodes\r\n      nodes.forEach(node => {\r\n        node.userData.isActive = false;\r\n        node.material.color.set(0x3498db);\r\n        node.material.emissive.set(0x0);\r\n        node.scale.set(1, 1, 1);\r\n      });\r\n      \r\n      // Remove all signals\r\n      for (let i = signals.length - 1; i >= 0; i--) {\r\n        scene.remove(signals[i]);\r\n      }\r\n      signals = [];\r\n    }\r\n    \r\n    // Mouse controls\r\n    let isDragging = false;\r\n    let previousMousePosition = { x: 0, y: 0 };\r\n    let raycaster = new THREE.Raycaster();\r\n    let mouse = new THREE.Vector2();\r\n    \r\n    function setupMouseControls() {\r\n      // Mouse drag for rotation\r\n      renderer.domElement.addEventListener('mousedown', e => {\r\n        isDragging = true;\r\n        previousMousePosition = {\r\n          x: e.clientX,\r\n          y: e.clientY\r\n        };\r\n      });\r\n      \r\n      renderer.domElement.addEventListener('mouseup', () => {\r\n        isDragging = false;\r\n      });\r\n      \r\n      renderer.domElement.addEventListener('mousemove', e => {\r\n        if (isDragging) {\r\n          const deltaX = e.clientX - previousMousePosition.x;\r\n          const deltaY = e.clientY - previousMousePosition.y;\r\n          \r\n          scene.rotation.y += deltaX * 0.01;\r\n          scene.rotation.x += deltaY * 0.01;\r\n          \r\n          previousMousePosition = {\r\n            x: e.clientX,\r\n            y: e.clientY\r\n          };\r\n        }\r\n      });\r\n      \r\n      // Mouse wheel for zoom\r\n      renderer.domElement.addEventListener('wheel', e => {\r\n        const zoomSpeed = 0.1;\r\n        if (e.deltaY > 0) {\r\n          camera.position.z += zoomSpeed * 5;\r\n        } else {\r\n          camera.position.z -= zoomSpeed * 5;\r\n        }\r\n        // Limit zoom\r\n        camera.position.z = Math.max(10, Math.min(100, camera.position.z));\r\n      });\r\n      \r\n      // Click to fire nodes\r\n      renderer.domElement.addEventListener('click', e => {\r\n        // Calculate mouse position in normalized device coordinates\r\n        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;\r\n        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\r\n        \r\n        // Update the picking ray\r\n        raycaster.setFromCamera(mouse, camera);\r\n        \r\n        // Calculate objects intersecting the picking ray\r\n        const intersects = raycaster.intersectObjects(nodes);\r\n        \r\n        if (intersects.length > 0) {\r\n          // Fire the first intersected node\r\n          fireNode(intersects[0].object);\r\n        }\r\n      });\r\n    }\r\n    \r\n    function onWindowResize() {\r\n      camera.aspect = window.innerWidth / window.innerHeight;\r\n      camera.updateProjectionMatrix();\r\n      renderer.setSize(window.innerWidth, window.innerHeight);\r\n    }\r\n    \r\n    function animate() {\r\n      requestAnimationFrame(animate);\r\n      \r\n      // Update signals\r\n      updateSignals();\r\n      \r\n      // Render scene\r\n      renderer.render(scene, camera);\r\n    }\r\n  </script>\r\n</body>\r\n</html>",
  "id": "neural-network-simulation-claude-3-7",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.729Z",
    "model": "claude-3.7",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, astronomy, simulation, architecture."
  }
}
