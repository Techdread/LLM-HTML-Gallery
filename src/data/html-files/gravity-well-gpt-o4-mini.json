{
  "title": "3D Gravity Well Simulation",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>3D Gravity Well Simulation</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n            font-family: sans-serif;\r\n        }\r\n\r\n        #info {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            color: #fff;\r\n            z-index: 1;\r\n        }\r\n\r\n        .dg {\r\n            z-index: 2 !important;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"info\">Click on the scene to add a mass object.<br>Use GUI to adjust values.</div>\r\n\r\n    <!-- Load Three.js and dependencies as global scripts -->\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.148.0/examples/js/controls/OrbitControls.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js\"></script>\r\n\r\n    <script>\r\n        // Scene, camera, renderer\r\n        const scene = new THREE.Scene();\r\n        scene.background = new THREE.Color(0x000000);\r\n        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n        camera.position.set(0, 50, 100);\r\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\r\n        renderer.setSize(window.innerWidth, window.innerHeight);\r\n        document.body.appendChild(renderer.domElement);\r\n\r\n        // Controls\r\n        const controls = new THREE.OrbitControls(camera, renderer.domElement);\r\n        controls.minDistance = 10;\r\n        controls.maxDistance = 300;\r\n        controls.enableDamping = true; // Enable damping for smoother camera movements\r\n        controls.dampingFactor = 0.05; // Set the damping factor (lower is smoother, default is 0.05)\r\n\r\n        // Grid mesh for spacetime\r\n        const size = 100, segments = 100;\r\n        const gridGeometry = new THREE.PlaneGeometry(size, size, segments, segments);\r\n        gridGeometry.rotateX(-Math.PI / 2);\r\n        const gridMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffdd, wireframe: true });\r\n        const gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);\r\n        scene.add(gridMesh);\r\n\r\n        // Mass objects and particles\r\n        const masses = [];\r\n        const particles = [];\r\n\r\n        // GUI parameters\r\n        const params = {\r\n            massValue: 20,\r\n            initialSpeed: 5,\r\n            addParticle: function () { addParticle(); }\r\n        };\r\n        const gui = new dat.GUI();\r\n        gui.add(params, 'massValue', 1, 100).name('Mass Value');\r\n        gui.add(params, 'initialSpeed', 0, 20).name('Init Speed');\r\n        gui.add(params, 'addParticle').name('Launch Particle');\r\n\r\n        // Add mass on click\r\n        window.addEventListener('pointerdown', function (e) {\r\n            const raycaster = new THREE.Raycaster();\r\n            const mouse = new THREE.Vector2(\r\n                (e.clientX / window.innerWidth) * 2 - 1,\r\n                -(e.clientY / window.innerHeight) * 2 + 1\r\n            );\r\n            raycaster.setFromCamera(mouse, camera);\r\n            const intersects = raycaster.intersectObject(gridMesh);\r\n            if (intersects.length > 0) {\r\n                const pt = intersects[0].point;\r\n                addMass(pt, params.massValue);\r\n            }\r\n        });\r\n\r\n        function addMass(position, mass) {\r\n            const geom = new THREE.SphereGeometry(1, 16, 16);\r\n            const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });\r\n            const sphere = new THREE.Mesh(geom, mat);\r\n            sphere.position.copy(position);\r\n            sphere.mass = mass;\r\n            scene.add(sphere);\r\n            masses.push(sphere);\r\n        }\r\n\r\n        function addParticle() {\r\n            const geom = new THREE.SphereGeometry(0.5, 8, 8);\r\n            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });\r\n            const p = new THREE.Mesh(geom, mat);\r\n            p.position.set(0, 1, 0);\r\n            // random direction\r\n            const dir = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();\r\n            p.velocity = dir.multiplyScalar(params.initialSpeed);\r\n            scene.add(p);\r\n            // trajectory line\r\n            p.trajGeom = new THREE.BufferGeometry().setFromPoints([]);\r\n            p.trajMat = new THREE.LineBasicMaterial({ color: 0xffff00 });\r\n            p.trajLine = new THREE.Line(p.trajGeom, p.trajMat);\r\n            scene.add(p.trajLine);\r\n            particles.push(p);\r\n        }\r\n\r\n        function updateGrid() {\r\n            const vertices = gridGeometry.attributes.position;\r\n            for (let i = 0; i < vertices.count; i++) {\r\n                const x = vertices.getX(i);\r\n                const z = vertices.getZ(i);\r\n                let y = 0;\r\n                masses.forEach(function (m) {\r\n                    const dx = x - m.position.x;\r\n                    const dz = z - m.position.z;\r\n                    const r2 = dx * dx + dz * dz + 1;\r\n                    y -= m.mass / r2;\r\n                });\r\n                vertices.setY(i, y);\r\n            }\r\n            vertices.needsUpdate = true;\r\n            gridGeometry.computeVertexNormals();\r\n        }\r\n\r\n        function updateParticles(dt) {\r\n            particles.forEach(function (p) {\r\n                masses.forEach(function (m) {\r\n                    const force = new THREE.Vector3().subVectors(m.position, p.position);\r\n                    const dist2 = force.lengthSq() + 1;\r\n                    force.normalize().multiplyScalar(m.mass / dist2);\r\n                    p.velocity.add(force.clone().multiplyScalar(dt));\r\n                });\r\n                p.position.add(p.velocity.clone().multiplyScalar(dt));\r\n                // update trajectory\r\n                const oldArr = p.trajGeom.attributes.position ? Array.from(p.trajGeom.attributes.position.array) : [];\r\n                oldArr.push(p.position.x, p.position.y, p.position.z);\r\n                const newPoints = new THREE.Float32BufferAttribute(oldArr, 3);\r\n                p.trajGeom.setAttribute('position', newPoints);\r\n                p.trajGeom.setDrawRange(0, oldArr.length / 3);\r\n            });\r\n        }\r\n\r\n        // Animation loop\r\n        const clock = new THREE.Clock();\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n            const dt = clock.getDelta();\r\n            updateGrid();\r\n            updateParticles(dt);\r\n            controls.update();\r\n            renderer.render(scene, camera);\r\n        }\r\n        animate();\r\n\r\n        // Handle resize\r\n        window.addEventListener('resize', function () {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        });\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "gravity-well-gpt-o4-mini",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "Particles",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:58.064Z",
    "model": "gpt-o4-mini",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, particles, webgl, shaders, astronomy, simulation, architecture."
  }
}
