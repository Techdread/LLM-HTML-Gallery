{
  "title": "Galaxy Formation Simulation",
  "htmlContent": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Galaxy Formation Simulation</title>\n  <style>\n    /* Basic page reset and styling */\n    body {\n      margin: 0;\n      overflow: hidden;\n      font-family: Arial, sans-serif;\n    }\n    /* Control panel styling */\n    #gui {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      background: rgba(255, 255, 255, 0.85);\n      padding: 10px;\n      border-radius: 5px;\n      z-index: 10;\n      max-width: 200px;\n    }\n    #gui label {\n      display: block;\n      margin: 5px 0 2px;\n      font-size: 0.9em;\n    }\n    #gui input, #gui select, #gui button {\n      margin-bottom: 5px;\n      width: 100%;\n      box-sizing: border-box;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"gui\">\n    <button id=\"startBtn\">Start</button>\n    <button id=\"pauseBtn\">Pause</button>\n    <button id=\"resetBtn\">Reset</button>\n    <label for=\"gravity\">Gravity Strength:</label>\n    <input type=\"range\" id=\"gravity\" min=\"0\" max=\"5\" step=\"0.1\" value=\"1\">\n    <label for=\"distribution\">Particle Distribution:</label>\n    <select id=\"distribution\">\n      <option value=\"random\">Random</option>\n      <option value=\"uniform\">Uniform</option>\n      <option value=\"clustered\">Clustered</option>\n    </select>\n    <label for=\"particleSize\">Particle Size:</label>\n    <input type=\"range\" id=\"particleSize\" min=\"1\" max=\"10\" step=\"0.5\" value=\"2\">\n    <label for=\"particleColor\">Particle Color:</label>\n    <input type=\"color\" id=\"particleColor\" value=\"#ffffff\">\n  </div>\n\n  <script type=\"module\">\n    // Import necessary modules\n    import * as THREE from 'https://cdn.skypack.dev/three@0.128.0/build/three.module.js';\n    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';\n\n    // Global variables and constants\n    let scene, camera, renderer, controls;\n    let particles, particlePositions, velocities;\n    const numParticles = 5000;\n    let particleGeometry, particleMaterial;\n    let simulationRunning = false;\n    let gravityStrength = parseFloat(document.getElementById('gravity').value);\n    let distributionType = document.getElementById('distribution').value;\n    let particleSize = parseFloat(document.getElementById('particleSize').value);\n    let particleColor = document.getElementById('particleColor').value;\n    const dt = 0.016; // Time step for simulation (~60 FPS)\n    const softening = 0.1; // Softening parameter to avoid singularities\n\n    // Initialize Three.js scene, camera, renderer, and controls\n    function init() {\n      scene = new THREE.Scene();\n      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);\n      camera.position.z = 100;\n\n      renderer = new THREE.WebGLRenderer({ antialias: true });\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      document.body.appendChild(renderer.domElement);\n\n      controls = new OrbitControls(camera, renderer.domElement);\n      \n      // Create the particle system\n      createParticles();\n\n      window.addEventListener('resize', onWindowResize, false);\n    }\n\n    // Create particles with positions and velocities based on the selected distribution\n    function createParticles() {\n      // Remove existing particles if resetting\n      if (particles) {\n        scene.remove(particles);\n      }\n      particleGeometry = new THREE.BufferGeometry();\n      particlePositions = new Float32Array(numParticles * 3);\n      velocities = new Float32Array(numParticles * 3);\n\n      for (let i = 0; i < numParticles; i++) {\n        let x, y, z;\n        if (distributionType === \"random\") {\n          // Random positions within a cube\n          x = (Math.random() - 0.5) * 200;\n          y = (Math.random() - 0.5) * 200;\n          z = (Math.random() - 0.5) * 200;\n        } else if (distributionType === \"uniform\") {\n          // Uniform grid distribution\n          const gridSize = Math.cbrt(numParticles);\n          const ix = i % gridSize;\n          const iy = Math.floor(i / gridSize) % gridSize;\n          const iz = Math.floor(i / (gridSize * gridSize));\n          x = (ix / gridSize - 0.5) * 200;\n          y = (iy / gridSize - 0.5) * 200;\n          z = (iz / gridSize - 0.5) * 200;\n        } else if (distributionType === \"clustered\") {\n          // Clustered distribution near the center with random offsets\n          const r = Math.random() * 20;\n          const theta = Math.random() * Math.PI * 2;\n          const phi = Math.acos((Math.random() * 2) - 1);\n          x = r * Math.sin(phi) * Math.cos(theta);\n          y = r * Math.sin(phi) * Math.sin(theta);\n          z = r * Math.cos(phi);\n          x += (Math.random() - 0.5) * 50;\n          y += (Math.random() - 0.5) * 50;\n          z += (Math.random() - 0.5) * 50;\n        }\n        particlePositions[i * 3] = x;\n        particlePositions[i * 3 + 1] = y;\n        particlePositions[i * 3 + 2] = z;\n\n        // Give each particle a small tangential velocity to promote orbital motion\n        const vx = -y * 0.01 + (Math.random() - 0.5) * 0.1;\n        const vy =  x * 0.01 + (Math.random() - 0.5) * 0.1;\n        const vz = (Math.random() - 0.5) * 0.1;\n        velocities[i * 3] = vx;\n        velocities[i * 3 + 1] = vy;\n        velocities[i * 3 + 2] = vz;\n      }\n      particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));\n\n      // Create the material for the particles\n      particleMaterial = new THREE.PointsMaterial({\n        color: particleColor,\n        size: particleSize,\n      });\n\n      // Create and add the Points object to the scene\n      particles = new THREE.Points(particleGeometry, particleMaterial);\n      scene.add(particles);\n    }\n\n    // Adjust camera and renderer on window resize\n    function onWindowResize() {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n\n    // Update simulation: apply a central gravitational force to each particle\n    function updateSimulation() {\n      for (let i = 0; i < numParticles; i++) {\n        const idx = i * 3;\n        let x = particlePositions[idx];\n        let y = particlePositions[idx + 1];\n        let z = particlePositions[idx + 2];\n\n        // Compute distance from the center with softening to avoid division by zero\n        const r = Math.sqrt(x * x + y * y + z * z) + softening;\n        // Calculate acceleration (Newtonian gravity: a ∝ 1/r²)\n        const a = -gravityStrength / (r * r);\n\n        // Components of acceleration (directed toward the center)\n        const ax = a * (x / r);\n        const ay = a * (y / r);\n        const az = a * (z / r);\n\n        // Update velocities\n        velocities[idx]     += ax * dt;\n        velocities[idx + 1] += ay * dt;\n        velocities[idx + 2] += az * dt;\n\n        // Update positions\n        particlePositions[idx]     += velocities[idx] * dt;\n        particlePositions[idx + 1] += velocities[idx + 1] * dt;\n        particlePositions[idx + 2] += velocities[idx + 2] * dt;\n      }\n      // Inform Three.js that the positions have changed\n      particleGeometry.attributes.position.needsUpdate = true;\n    }\n\n    // Animation loop\n    function animate() {\n      requestAnimationFrame(animate);\n      if (simulationRunning) {\n        updateSimulation();\n      }\n      controls.update();\n      renderer.render(scene, camera);\n    }\n\n    // Event listeners for the UI controls\n    document.getElementById('startBtn').addEventListener('click', function() {\n      simulationRunning = true;\n    });\n\n    document.getElementById('pauseBtn').addEventListener('click', function() {\n      simulationRunning = false;\n    });\n\n    document.getElementById('resetBtn').addEventListener('click', function() {\n      simulationRunning = false;\n      distributionType = document.getElementById('distribution').value;\n      gravityStrength = parseFloat(document.getElementById('gravity').value);\n      particleSize = parseFloat(document.getElementById('particleSize').value);\n      particleColor = document.getElementById('particleColor').value;\n      createParticles();\n    });\n\n    document.getElementById('gravity').addEventListener('input', function(e) {\n      gravityStrength = parseFloat(e.target.value);\n    });\n\n    document.getElementById('particleSize').addEventListener('input', function(e) {\n      particleSize = parseFloat(e.target.value);\n      if (particleMaterial) {\n        particleMaterial.size = particleSize;\n      }\n    });\n\n    document.getElementById('particleColor').addEventListener('input', function(e) {\n      particleColor = e.target.value;\n      if (particleMaterial) {\n        particleMaterial.color.set(particleColor);\n      }\n    });\n\n    // Initialize and start the animation loop\n    init();\n    animate();\n  </script>\n</body>\n</html>\n",
  "id": "galaxy-simulation-gpt-o3-high",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "Particles",
      "WebGL",
      "Shaders",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:58.048Z",
    "model": "gpt-o3-high",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, particles, webgl, shaders, simulation, architecture."
  }
}
