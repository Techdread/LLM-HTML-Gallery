{
  "title": "Interactive 3D Solar System",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Interactive 3D Solar System</title>\r\n    <script src=\"https://cdn.tailwindcss.com\"></script>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n            background-color: #000;\r\n            color: #fff;\r\n            font-family: 'Inter', sans-serif;\r\n        }\r\n\r\n        canvas {\r\n            display: block;\r\n        }\r\n\r\n        #ui-controls {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            background-color: rgba(0, 0, 0, 0.7);\r\n            padding: 15px;\r\n            border-radius: 8px;\r\n            display: flex;\r\n            flex-direction: column;\r\n            gap: 10px;\r\n            max-width: 250px;\r\n            border: 1px solid rgba(255, 255, 255, 0.2);\r\n        }\r\n\r\n        #planet-info {\r\n            position: absolute;\r\n            bottom: 10px;\r\n            left: 10px;\r\n            background-color: rgba(0, 0, 0, 0.7);\r\n            padding: 10px;\r\n            border-radius: 8px;\r\n            font-size: 0.9em;\r\n            border: 1px solid rgba(255, 255, 255, 0.2);\r\n            min-width: 200px;\r\n        }\r\n\r\n        label {\r\n            display: block;\r\n            margin-bottom: 3px;\r\n            font-weight: 500;\r\n        }\r\n\r\n        select,\r\n        button,\r\n        input[type=\"range\"] {\r\n            width: 100%;\r\n            padding: 5px 8px;\r\n            border-radius: 4px;\r\n            background-color: rgba(255, 255, 255, 0.1);\r\n            border: 1px solid rgba(255, 255, 255, 0.3);\r\n            color: #fff;\r\n            cursor: pointer;\r\n        }\r\n\r\n        button {\r\n            background-color: rgba(79, 70, 229, 0.8);\r\n            /* Indigo */\r\n            transition: background-color 0.2s;\r\n        }\r\n\r\n        button:hover {\r\n            background-color: rgba(67, 56, 202, 0.9);\r\n        }\r\n\r\n        input[type=\"range\"] {\r\n            cursor: grab;\r\n        }\r\n\r\n        input[type=\"range\"]:active {\r\n            cursor: grabbing;\r\n        }\r\n\r\n        select option {\r\n            background-color: #333;\r\n            color: #fff;\r\n        }\r\n\r\n        h3 {\r\n            font-size: 1.1em;\r\n            margin-bottom: 5px;\r\n            border-bottom: 1px solid rgba(255, 255, 255, 0.2);\r\n            padding-bottom: 5px;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <canvas id=\"solarSystemCanvas\"></canvas>\r\n\r\n    <div id=\"ui-controls\">\r\n        <h3 class=\"text-lg font-semibold mb-2 border-b border-gray-600 pb-1\">Controls</h3>\r\n        <div>\r\n            <label for=\"timeSpeed\">Time Speed:</label>\r\n            <input type=\"range\" id=\"timeSpeed\" min=\"0\" max=\"10\" value=\"1\" step=\"0.1\">\r\n        </div>\r\n        <div>\r\n            <button id=\"pauseButton\">Pause</button>\r\n        </div>\r\n        <div>\r\n            <label for=\"focusSelect\">Focus:</label>\r\n            <select id=\"focusSelect\">\r\n                <option value=\"sun\">Sun</option>\r\n            </select>\r\n        </div>\r\n    </div>\r\n\r\n    <div id=\"planet-info\">\r\n        <h3>Selected Body</h3>\r\n        <p id=\"info-name\">Name: Sun</p>\r\n        <p id=\"info-distance\">Distance: N/A</p>\r\n        <p id=\"info-period\">Orbital Period: N/A</p>\r\n    </div>\r\n\r\n    <script type=\"importmap\">\r\n        {\r\n            \"imports\": {\r\n                \"three\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js\",\r\n                \"three/addons/\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/\"\r\n            }\r\n        }\r\n    </script>\r\n\r\n    <script type=\"module\">\r\n        import * as THREE from 'three';\r\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\n\r\n        // --- Scene Setup ---\r\n        const scene = new THREE.Scene();\r\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);\r\n        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('solarSystemCanvas'), antialias: true });\r\n        renderer.setSize(window.innerWidth, window.innerHeight);\r\n        renderer.setPixelRatio(window.devicePixelRatio); // Improve sharpness on high DPI screens\r\n\r\n        // --- Lighting ---\r\n        const ambientLight = new THREE.AmbientLight(0x333333); // Soft ambient light\r\n        scene.add(ambientLight);\r\n\r\n        // --- Controls ---\r\n        const controls = new OrbitControls(camera, renderer.domElement);\r\n        controls.enableDamping = true; // Smooth camera movement\r\n        controls.dampingFactor = 0.05;\r\n        controls.screenSpacePanning = false; // Pan moves parallel to ground plane\r\n        controls.minDistance = 1;\r\n        controls.maxDistance = 1000;\r\n\r\n        // --- Sun ---\r\n        const sunGeometry = new THREE.SphereGeometry(5, 32, 32); // Radius 5\r\n        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: false }); // Emissive yellow\r\n        const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);\r\n        scene.add(sunMesh);\r\n\r\n        // Add point light source at the sun's center\r\n        const pointLight = new THREE.PointLight(0xffffff, 3, 2000); // White light, intensity 3, range 2000\r\n        sunMesh.add(pointLight); // Attach light to the sun mesh\r\n\r\n        // --- Planets Data ---\r\n        // Simplified orbital data (distances scaled down)\r\n        // a = semi-major axis, e = eccentricity, period = orbital period (relative)\r\n        // size = visual radius in the simulation\r\n        const planetsData = [\r\n            { name: \"Mercury\", size: 0.5, color: 0xaaaaaa, a: 10, e: 0.206, period: 0.24 },\r\n            { name: \"Venus\", size: 0.9, color: 0xffe4b5, a: 15, e: 0.007, period: 0.62 },\r\n            { name: \"Earth\", size: 1.0, color: 0x4682b4, a: 20, e: 0.017, period: 1.0 },\r\n            { name: \"Mars\", size: 0.7, color: 0xff4500, a: 30, e: 0.093, period: 1.88 },\r\n            { name: \"Jupiter\", size: 3.5, color: 0xd2b48c, a: 50, e: 0.048, period: 11.86 },\r\n            { name: \"Saturn\", size: 3.0, color: 0xf4a460, a: 70, e: 0.056, period: 29.46 },\r\n            // Add Uranus and Neptune if desired\r\n        ];\r\n\r\n        const planetMeshes = [];\r\n        const orbitPaths = [];\r\n        const focusSelect = document.getElementById('focusSelect');\r\n        const planetInfoName = document.getElementById('info-name');\r\n        const planetInfoDistance = document.getElementById('info-distance');\r\n        const planetInfoPeriod = document.getElementById('info-period');\r\n\r\n        // --- Create Planets and Orbits ---\r\n        planetsData.forEach(data => {\r\n            // Planet Mesh\r\n            const geometry = new THREE.SphereGeometry(data.size, 32, 32);\r\n            // Use MeshStandardMaterial for better lighting effects\r\n            const material = new THREE.MeshStandardMaterial({\r\n                color: data.color,\r\n                metalness: 0.3, // Adjust for appearance\r\n                roughness: 0.8, // Adjust for appearance\r\n                wireframe: false\r\n            });\r\n            const planetMesh = new THREE.Mesh(geometry, material);\r\n            planetMesh.userData = data; // Store planet data in the mesh\r\n            scene.add(planetMesh);\r\n            planetMeshes.push(planetMesh);\r\n\r\n            // Orbit Path (Simplified Ellipse centered at Sun)\r\n            const semiMajorAxis = data.a;\r\n            const semiMinorAxis = data.a * Math.sqrt(1 - data.e * data.e); // b = a * sqrt(1 - e^2)\r\n            const curve = new THREE.EllipseCurve(\r\n                0, 0,             // Center x, y (Sun's position)\r\n                semiMajorAxis, semiMinorAxis, // xRadius, yRadius\r\n                0, 2 * Math.PI,   // StartAngle, EndAngle\r\n                false,            // Clockwise\r\n                0                 // Rotation\r\n            );\r\n\r\n            const points = curve.getPoints(100); // Get 100 points along the ellipse\r\n            const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);\r\n            const orbitMaterial = new THREE.LineBasicMaterial({ color: 0x555555 }); // Dim white/grey\r\n            const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);\r\n            orbitLine.rotation.x = Math.PI / 2; // Rotate to align with the XZ plane\r\n            scene.add(orbitLine);\r\n            orbitPaths.push(orbitLine);\r\n\r\n            // Add option to focus dropdown\r\n            const option = document.createElement('option');\r\n            option.value = data.name.toLowerCase();\r\n            option.textContent = data.name;\r\n            focusSelect.appendChild(option);\r\n        });\r\n\r\n        // --- Starfield Background ---\r\n        function createStarfield() {\r\n            const starVertices = [];\r\n            for (let i = 0; i < 10000; i++) {\r\n                const x = THREE.MathUtils.randFloatSpread(1500); // Spread stars across a large area\r\n                const y = THREE.MathUtils.randFloatSpread(1500);\r\n                const z = THREE.MathUtils.randFloatSpread(1500);\r\n                // Ensure stars are far enough away\r\n                if (Math.sqrt(x * x + y * y + z * z) > 100) { // Don't place stars too close to the center\r\n                    starVertices.push(x, y, z);\r\n                }\r\n            }\r\n            const starGeometry = new THREE.BufferGeometry();\r\n            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));\r\n            const starMaterial = new THREE.PointsMaterial({\r\n                color: 0xffffff,\r\n                size: 0.5, // Adjust size of stars\r\n                sizeAttenuation: true // Stars appear smaller further away\r\n            });\r\n            const stars = new THREE.Points(starGeometry, starMaterial);\r\n            scene.add(stars);\r\n        }\r\n        createStarfield();\r\n\r\n\r\n        // --- Camera Initial Position ---\r\n        camera.position.set(0, 50, 100); // Start looking from above and slightly away\r\n        controls.target.set(0, 0, 0); // Look at the sun initially\r\n        controls.update(); // Important after setting target\r\n\r\n        // --- Simulation State ---\r\n        let simulationTime = 0;\r\n        let simulationSpeed = 1; // Multiplier for time speed\r\n        let isPaused = false;\r\n        let focusedObject = sunMesh; // Start focused on the sun\r\n\r\n        // --- UI Event Listeners ---\r\n        const timeSpeedSlider = document.getElementById('timeSpeed');\r\n        const pauseButton = document.getElementById('pauseButton');\r\n\r\n        timeSpeedSlider.addEventListener('input', (event) => {\r\n            simulationSpeed = parseFloat(event.target.value);\r\n            if (simulationSpeed === 0) {\r\n                isPaused = true;\r\n                pauseButton.textContent = 'Resume';\r\n            } else if (isPaused) {\r\n                isPaused = false;\r\n                pauseButton.textContent = 'Pause';\r\n            }\r\n        });\r\n\r\n        pauseButton.addEventListener('click', () => {\r\n            isPaused = !isPaused;\r\n            pauseButton.textContent = isPaused ? 'Resume' : 'Pause';\r\n            if (!isPaused && simulationSpeed === 0) {\r\n                simulationSpeed = 0.1; // Set a small speed if resuming from 0\r\n                timeSpeedSlider.value = simulationSpeed;\r\n            } else if (isPaused) {\r\n                // Optionally set slider to 0 when pausing via button\r\n                // timeSpeedSlider.value = 0;\r\n            }\r\n        });\r\n\r\n        focusSelect.addEventListener('change', (event) => {\r\n            const selectedValue = event.target.value;\r\n            if (selectedValue === 'sun') {\r\n                focusedObject = sunMesh;\r\n                updatePlanetInfo(sunMesh, true); // Pass true for sun\r\n            } else {\r\n                const selectedPlanet = planetMeshes.find(p => p.userData.name.toLowerCase() === selectedValue);\r\n                if (selectedPlanet) {\r\n                    focusedObject = selectedPlanet;\r\n                    updatePlanetInfo(selectedPlanet);\r\n                }\r\n            }\r\n            // Don't immediately jump camera, let OrbitControls handle target update in loop\r\n        });\r\n\r\n        // --- Update Planet Info Display ---\r\n        function updatePlanetInfo(object, isSun = false) {\r\n            if (isSun) {\r\n                planetInfoName.textContent = \"Name: Sun\";\r\n                planetInfoDistance.textContent = \"Distance: N/A\";\r\n                planetInfoPeriod.textContent = \"Orbital Period: N/A\";\r\n            } else if (object && object.userData) {\r\n                const data = object.userData;\r\n                const currentDistance = object.position.distanceTo(sunMesh.position).toFixed(2);\r\n                planetInfoName.textContent = `Name: ${data.name}`;\r\n                planetInfoDistance.textContent = `Current Distance: ${currentDistance} units`;\r\n                planetInfoPeriod.textContent = `Orbital Period: ${data.period} (relative Earth years)`;\r\n            }\r\n        }\r\n        // Initial info display\r\n        updatePlanetInfo(sunMesh, true);\r\n\r\n\r\n        // --- Animation Loop ---\r\n        const clock = new THREE.Clock();\r\n\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n\r\n            const deltaTime = clock.getDelta(); // Time since last frame in seconds\r\n\r\n            if (!isPaused) {\r\n                simulationTime += deltaTime * simulationSpeed;\r\n\r\n                // Update planet positions (Simplified Elliptical Orbit)\r\n                planetMeshes.forEach(planetMesh => {\r\n                    const data = planetMesh.userData;\r\n                    const semiMajorAxis = data.a;\r\n                    const semiMinorAxis = data.a * Math.sqrt(1 - data.e * data.e);\r\n                    const period = data.period; // Relative period\r\n\r\n                    // Calculate angle based on time and period\r\n                    // Using mean anomaly approximation for angle: M = n * t\r\n                    // n = 2 * PI / Period (angular speed)\r\n                    // More accurate would involve Kepler's equation, this is simpler\r\n                    const meanAngularSpeed = (2 * Math.PI) / (period * 50); // Scale period for visual speed\r\n                    let currentAngle = (simulationTime * meanAngularSpeed) % (2 * Math.PI);\r\n\r\n                    // --- Approximation of Varying Speed (Kepler's 2nd Law) ---\r\n                    // Calculate distance for speed adjustment (simplified)\r\n                    // This part is tricky without solving Kepler's equation.\r\n                    // We can slightly adjust speed based on angle for an *effect*\r\n                    // Planets move faster near perihelion (closest point)\r\n                    // For ellipse x=a*cos(t), z=b*sin(t), closest point is at angle=0 (if sun at center)\r\n                    // Let's make speed slightly higher around angle 0 and PI\r\n                    // This is NOT physically accurate, just a visual approximation.\r\n                    const speedFactor = 1 + data.e * Math.cos(currentAngle); // Higher when cos(angle) is positive (closer to x-axis positive)\r\n                    currentAngle = (simulationTime * meanAngularSpeed * speedFactor) % (2 * Math.PI);\r\n\r\n\r\n                    // Calculate position on the ellipse centered at the sun (0,0,0)\r\n                    const x = semiMajorAxis * Math.cos(currentAngle);\r\n                    const z = semiMinorAxis * Math.sin(currentAngle); // Use semiMinorAxis for z\r\n\r\n                    planetMesh.position.set(x, 0, z);\r\n\r\n                    // Update info if this planet is selected\r\n                    if (focusedObject === planetMesh) {\r\n                        updatePlanetInfo(planetMesh);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Update camera target smoothly if focused object changed\r\n            if (focusedObject) {\r\n                controls.target.lerp(focusedObject.position, 0.1); // Smoothly move target towards focused object\r\n            }\r\n\r\n            controls.update(); // Required if controls.enableDamping or controls.autoRotate are set\r\n            renderer.render(scene, camera);\r\n        }\r\n\r\n        // --- Handle Window Resize ---\r\n        window.addEventListener('resize', () => {\r\n            // Update camera aspect ratio\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n\r\n            // Update renderer size\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            renderer.setPixelRatio(window.devicePixelRatio);\r\n        });\r\n\r\n        // --- Start Animation ---\r\n        // Ensure everything is loaded before starting\r\n        window.onload = () => {\r\n            animate();\r\n        }\r\n\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "interactive-3d-solar-system-gemini-pro-2-5",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Canvas",
      "Animation",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.960Z",
    "model": "gemini-pro-2.5",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, canvas, animation, webgl, shaders, astronomy, simulation, architecture."
  }
}
