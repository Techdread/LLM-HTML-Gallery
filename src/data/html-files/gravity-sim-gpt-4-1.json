{
  "title": "3D Gravity Well Simulation",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>3D Gravity Well Simulation</title>\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            font-family: 'Inter', Arial, sans-serif;\r\n            background: #101019;\r\n            color: #fff;\r\n            overflow: hidden;\r\n        }\r\n\r\n        #ui {\r\n            position: absolute;\r\n            top: 20px;\r\n            left: 20px;\r\n            z-index: 2;\r\n            background: rgba(24, 24, 32, 0.93);\r\n            padding: 20px 22px;\r\n            border-radius: 18px;\r\n            box-shadow: 0 2px 24px 0 #0006;\r\n            min-width: 290px;\r\n        }\r\n\r\n        #ui h2 {\r\n            font-size: 1.15rem;\r\n            margin: 0 0 12px 0;\r\n            letter-spacing: 0.01em;\r\n            font-weight: 500;\r\n        }\r\n\r\n        .control {\r\n            margin: 9px 0 15px 0;\r\n        }\r\n\r\n        label {\r\n            display: block;\r\n            font-size: 0.96em;\r\n            margin-bottom: 3px;\r\n            font-weight: 500;\r\n        }\r\n\r\n        input[type=\"range\"] {\r\n            width: 100%;\r\n        }\r\n\r\n        input,\r\n        button,\r\n        select {\r\n            font-family: inherit;\r\n            font-size: 1em;\r\n            border-radius: 7px;\r\n            border: none;\r\n            outline: none;\r\n            margin-bottom: 0.1em;\r\n        }\r\n\r\n        button {\r\n            margin-top: 5px;\r\n            padding: 8px 18px;\r\n            background: #294aff;\r\n            color: #fff;\r\n            border-radius: 10px;\r\n            box-shadow: 0 1px 8px 0 #0002;\r\n            font-weight: 600;\r\n            cursor: pointer;\r\n            border: none;\r\n            margin-right: 8px;\r\n        }\r\n\r\n        button:active {\r\n            background: #17369a;\r\n        }\r\n\r\n        .massive-objects-list {\r\n            margin-bottom: 12px;\r\n        }\r\n\r\n        .particle-launch {\r\n            margin-top: 14px;\r\n            border-top: 1px solid #3336;\r\n            padding-top: 14px;\r\n        }\r\n\r\n        #canvas {\r\n            position: fixed;\r\n            top: 0;\r\n            left: 0;\r\n            width: 100vw;\r\n            height: 100vh;\r\n            outline: none;\r\n            z-index: 0;\r\n            background: #171728;\r\n            display: block;\r\n        }\r\n\r\n        .desc {\r\n            color: #ccc;\r\n            font-size: 0.97em;\r\n            margin-bottom: 8px;\r\n            margin-top: -2px;\r\n            line-height: 1.34;\r\n        }\r\n\r\n        .slider-value {\r\n            display: inline-block;\r\n            min-width: 34px;\r\n            text-align: right;\r\n            margin-left: 6px;\r\n            color: #8ecaff;\r\n            font-size: 1em;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"ui\">\r\n        <h2>Gravity Well Simulation</h2>\r\n        <div class=\"desc\">\r\n            Place massive objects and launch particles to see how gravity warps spacetime.\r\n        </div>\r\n        <div class=\"control\">\r\n            <label>Place Massive Object:</label>\r\n            <button onclick=\"addMassiveObject()\">Add Star</button>\r\n            <button onclick=\"addMassiveObject(true)\">Add Black Hole</button>\r\n        </div>\r\n        <div class=\"massive-objects-list\" id=\"objectsList\"></div>\r\n\r\n        <div class=\"particle-launch\">\r\n            <label>Launch Particle:</label>\r\n            <div>\r\n                <label>Initial Velocity <span class=\"slider-value\" id=\"velValue\">1.0</span></label>\r\n                <input id=\"velSlider\" type=\"range\" min=\"0.2\" max=\"4.0\" step=\"0.05\" value=\"1.0\"\r\n                    oninput=\"document.getElementById('velValue').textContent=this.value\" />\r\n                <button onclick=\"enableLaunchMode()\">Click to Launch</button>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <canvas id=\"canvas\"></canvas>\r\n\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.125.0/build/three.min.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.125.0/examples/js/controls/OrbitControls.js\"></script>\r\n    <script>\r\n        // ==== SIMULATION CONFIGURABLES ====\r\n        const GRID_SIZE = 38;\r\n        const GRID_STEP = 1.7;\r\n        const WELL_DEPTH_SCALE = 21.5;   // how much each unit of mass deforms the grid\r\n        const MASSIVE_OBJECT_RADIUS = 1.6;\r\n        const PARTICLE_RADIUS = 0.22;\r\n        const G = 4.4;   // simulation 'gravitational constant', tweak for fun\r\n        const TIMESTEP = 0.021; // seconds per frame\r\n        const TRAIL_LENGTH = 270;  // how many steps to keep in particle trails\r\n\r\n        // ==== SCENE SETUP ====\r\n        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });\r\n        renderer.setSize(window.innerWidth, window.innerHeight);\r\n        renderer.setPixelRatio(window.devicePixelRatio);\r\n\r\n        const scene = new THREE.Scene();\r\n        scene.background = new THREE.Color(0x181828);\r\n\r\n        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 180);\r\n        camera.position.set(0, 26, 32);\r\n\r\n        const controls = new THREE.OrbitControls(camera, renderer.domElement);\r\n        controls.target.set(0, 0, 0);\r\n        controls.enablePan = false;\r\n        controls.minDistance = 14;\r\n        controls.maxDistance = 88;\r\n        controls.update();\r\n\r\n        window.addEventListener('resize', () => {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        });\r\n\r\n        // ==== LIGHTING ====\r\n        scene.add(new THREE.AmbientLight(0xffffff, 0.68));\r\n        const dLight = new THREE.DirectionalLight(0xaaccff, 0.52);\r\n        dLight.position.set(23, 32, 11);\r\n        scene.add(dLight);\r\n\r\n        // ==== GRID CREATION ====\r\n        const gridGeometry = new THREE.PlaneGeometry(GRID_SIZE * GRID_STEP, GRID_SIZE * GRID_STEP, GRID_SIZE, GRID_SIZE);\r\n        gridGeometry.rotateX(-Math.PI / 2);\r\n        const gridMaterial = new THREE.MeshPhysicalMaterial({\r\n            color: 0x274faa,\r\n            metalness: 0.05,\r\n            roughness: 0.45,\r\n            clearcoat: 0.47,\r\n            reflectivity: 0.11,\r\n            side: THREE.DoubleSide,\r\n            transparent: true,\r\n            opacity: 0.93,\r\n            wireframe: false,\r\n        });\r\n        const gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);\r\n        scene.add(gridMesh);\r\n\r\n        // Thin grid lines\r\n        const gridHelper = new THREE.GridHelper(GRID_SIZE * GRID_STEP, GRID_SIZE, 0x7aaaff, 0x1854aa);\r\n        gridHelper.position.y = 0.02;\r\n        scene.add(gridHelper);\r\n\r\n        // ==== MASSIVE OBJECTS (stars/black holes) ====\r\n        let massiveObjects = [];\r\n        function addMassiveObject(blackHole = false) {\r\n            // Place at random (x, z) within grid\r\n            const pos = [\r\n                (Math.random() - 0.5) * GRID_SIZE * GRID_STEP * 0.8,\r\n                (Math.random() - 0.5) * GRID_SIZE * GRID_STEP * 0.8\r\n            ];\r\n            let mass = blackHole ? 19 : 6 + Math.random() * 7;\r\n            const color = blackHole ? 0x13131a : 0xf9db39;\r\n            const obj = {\r\n                pos: new THREE.Vector2(pos[0], pos[1]),\r\n                mass: mass,\r\n                blackHole: blackHole,\r\n                mesh: null,\r\n                massInput: null\r\n            };\r\n            const geo = new THREE.SphereGeometry(MASSIVE_OBJECT_RADIUS * (blackHole ? 1.18 : 1.0), 28, 20);\r\n            const mat = new THREE.MeshPhysicalMaterial({\r\n                color: color,\r\n                metalness: blackHole ? 0.89 : 0.15,\r\n                roughness: blackHole ? 0.35 : 0.32,\r\n                transparent: false,\r\n                clearcoat: 0.23,\r\n                emissive: blackHole ? 0x181848 : 0x3f2f05,\r\n                opacity: 1.0,\r\n                wireframe: false,\r\n            });\r\n            obj.mesh = new THREE.Mesh(geo, mat);\r\n            obj.mesh.position.set(obj.pos.x, MASSIVE_OBJECT_RADIUS * 1.08, obj.pos.y);\r\n            obj.mesh.castShadow = false;\r\n            obj.mesh.userData.massiveObject = obj;\r\n\r\n            // Drag to move (handler logic set up below)\r\n            obj.mesh.cursor = 'pointer';\r\n            obj.mesh.onPointerDown = () => { };\r\n            massiveObjects.push(obj);\r\n            scene.add(obj.mesh);\r\n            updateObjectsList();\r\n            updateGridDeformation();\r\n        }\r\n\r\n        function updateObjectsList() {\r\n            const listDiv = document.getElementById('objectsList');\r\n            listDiv.innerHTML = '';\r\n            massiveObjects.forEach((obj, i) => {\r\n                const div = document.createElement('div');\r\n                div.style.display = 'flex';\r\n                div.style.alignItems = 'center';\r\n                div.style.marginBottom = '4px';\r\n                div.innerHTML = `\r\n      <span style=\"font-size:1.12em;margin-right:7px;color:${obj.blackHole ? '#8ae' : '#fd2'};\">${obj.blackHole ? 'üï≥Ô∏è' : '‚òÖ'}</span>\r\n      <span style=\"flex:1;\">M:</span>\r\n      <input type=\"range\" min=\"2\" max=\"26\" value=\"${obj.mass}\" step=\"0.1\" style=\"width:90px;\" oninput=\"massiveObjects[${i}].mass=parseFloat(this.value);updateGridDeformation();this.nextSibling.textContent=parseFloat(this.value).toFixed(1);\">\r\n      <span class=\"slider-value\" style=\"min-width:36px;\">${obj.mass.toFixed(1)}</span>\r\n      <button style=\"background:#c43c44;padding:3px 12px;margin-left:7px;font-size:1em;\" onclick=\"removeMassiveObject(${i})\">‚úï</button>\r\n    `;\r\n                listDiv.appendChild(div);\r\n            });\r\n        }\r\n        function removeMassiveObject(idx) {\r\n            scene.remove(massiveObjects[idx].mesh);\r\n            massiveObjects.splice(idx, 1);\r\n            updateObjectsList();\r\n            updateGridDeformation();\r\n        }\r\n\r\n        // ==== GRID DEFORMATION ====\r\n        function updateGridDeformation() {\r\n            // For each vertex, calculate the sum of deformations by all massive objects\r\n            const positions = gridGeometry.attributes.position;\r\n            for (let i = 0; i < positions.count; i++) {\r\n                // x,z are in-plane\r\n                let x = positions.getX(i);\r\n                let z = positions.getZ(i);\r\n                let y = 0;\r\n                for (const obj of massiveObjects) {\r\n                    let dx = x - obj.pos.x;\r\n                    let dz = z - obj.pos.y;\r\n                    let r = Math.sqrt(dx * dx + dz * dz) + 0.32; // avoid singularity\r\n                    // 1/r gravity well, with mass\r\n                    y -= obj.mass * WELL_DEPTH_SCALE / r;\r\n                }\r\n                positions.setY(i, y);\r\n            }\r\n            positions.needsUpdate = true;\r\n            gridGeometry.computeVertexNormals();\r\n        }\r\n\r\n        // ==== DRAG MASSIVE OBJECTS ====\r\n        let draggingObj = null, dragOffset = null;\r\n        const raycaster = new THREE.Raycaster();\r\n        const pointer = new THREE.Vector2();\r\n        renderer.domElement.addEventListener('pointerdown', onPointerDown);\r\n        renderer.domElement.addEventListener('pointerup', onPointerUp);\r\n        renderer.domElement.addEventListener('pointermove', onPointerMove);\r\n\r\n        function getPointerPos(event) {\r\n            const rect = renderer.domElement.getBoundingClientRect();\r\n            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n        }\r\n        function onPointerDown(event) {\r\n            getPointerPos(event);\r\n            raycaster.setFromCamera(pointer, camera);\r\n            const intersects = raycaster.intersectObjects(massiveObjects.map(o => o.mesh));\r\n            if (intersects.length > 0) {\r\n                draggingObj = intersects[0].object.userData.massiveObject;\r\n                // Compute drag offset in XZ\r\n                dragOffset = new THREE.Vector2(\r\n                    draggingObj.pos.x - intersects[0].point.x,\r\n                    draggingObj.pos.y - intersects[0].point.z\r\n                );\r\n                controls.enableRotate = false;\r\n            } else if (launchMode) {\r\n                launchParticleAtPointer(event);\r\n            }\r\n        }\r\n        function onPointerMove(event) {\r\n            if (draggingObj) {\r\n                // Raycast to plane Y=0\r\n                getPointerPos(event);\r\n                raycaster.setFromCamera(pointer, camera);\r\n                const planeY0 = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);\r\n                const intersect = new THREE.Vector3();\r\n                raycaster.ray.intersectPlane(planeY0, intersect);\r\n                draggingObj.pos.x = intersect.x + dragOffset.x;\r\n                draggingObj.pos.y = intersect.z + dragOffset.y;\r\n                draggingObj.mesh.position.set(draggingObj.pos.x, MASSIVE_OBJECT_RADIUS * 1.08, draggingObj.pos.y);\r\n                updateGridDeformation();\r\n            }\r\n        }\r\n        function onPointerUp(event) {\r\n            draggingObj = null;\r\n            controls.enableRotate = true;\r\n        }\r\n\r\n        // ==== PARTICLES AND TRAILS ====\r\n        let particles = [];\r\n        function enableLaunchMode() {\r\n            launchMode = true;\r\n            document.body.style.cursor = 'crosshair';\r\n        }\r\n        let launchMode = false;\r\n        function launchParticleAtPointer(event) {\r\n            // Find point on grid\r\n            getPointerPos(event);\r\n            raycaster.setFromCamera(pointer, camera);\r\n            const planeY0 = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);\r\n            const intersect = new THREE.Vector3();\r\n            raycaster.ray.intersectPlane(planeY0, intersect);\r\n            // Set velocity towards a random in-plane direction, user can enhance this logic!\r\n            const velMag = parseFloat(document.getElementById('velSlider').value);\r\n            let angle = Math.random() * Math.PI * 2;\r\n            let vx = velMag * Math.cos(angle);\r\n            let vz = velMag * Math.sin(angle);\r\n            const particle = {\r\n                pos: new THREE.Vector3(intersect.x, 0.22, intersect.z),\r\n                vel: new THREE.Vector3(vx, 0, vz),\r\n                mesh: null,\r\n                trail: [],\r\n                trailLine: null\r\n            };\r\n            const mat = new THREE.MeshPhysicalMaterial({ color: 0x59eaff, metalness: 0.18, roughness: 0.22, clearcoat: 0.6, emissive: 0x05415f });\r\n            const geo = new THREE.SphereGeometry(PARTICLE_RADIUS, 12, 8);\r\n            particle.mesh = new THREE.Mesh(geo, mat);\r\n            particle.mesh.position.copy(particle.pos);\r\n            scene.add(particle.mesh);\r\n            // Trail\r\n            const trailGeo = new THREE.BufferGeometry();\r\n            const trailVerts = new Float32Array(TRAIL_LENGTH * 3);\r\n            trailGeo.setAttribute('position', new THREE.BufferAttribute(trailVerts, 3));\r\n            const trailMat = new THREE.LineBasicMaterial({ color: 0x52f6d1 });\r\n            particle.trailLine = new THREE.Line(trailGeo, trailMat);\r\n            scene.add(particle.trailLine);\r\n            particles.push(particle);\r\n            launchMode = false;\r\n            document.body.style.cursor = '';\r\n        }\r\n\r\n        // ==== PHYSICS LOOP ====\r\n        function computeAccel(pos) {\r\n            // Acceleration from all massive objects\r\n            let acc = new THREE.Vector3();\r\n            for (const obj of massiveObjects) {\r\n                let dx = obj.pos.x - pos.x;\r\n                let dz = obj.pos.y - pos.z;\r\n                let distSq = dx * dx + dz * dz + 0.41;\r\n                let dist = Math.sqrt(distSq);\r\n                let force = G * obj.mass / distSq;\r\n                acc.x += force * dx / dist;\r\n                acc.z += force * dz / dist;\r\n            }\r\n            return acc;\r\n        }\r\n\r\n        function animateParticles() {\r\n            for (const p of particles) {\r\n                // Runge-Kutta 4th order integration (one step)\r\n                let a1 = computeAccel(p.pos);\r\n                let v1 = p.vel.clone().multiplyScalar(TIMESTEP);\r\n\r\n                let a2 = computeAccel(p.pos.clone().add(v1.clone().multiplyScalar(0.5)));\r\n                let v2 = p.vel.clone().add(a1.clone().multiplyScalar(TIMESTEP / 2)).multiplyScalar(TIMESTEP);\r\n\r\n                let a3 = computeAccel(p.pos.clone().add(v2.clone().multiplyScalar(0.5)));\r\n                let v3 = p.vel.clone().add(a2.clone().multiplyScalar(TIMESTEP / 2)).multiplyScalar(TIMESTEP);\r\n\r\n                let a4 = computeAccel(p.pos.clone().add(v3));\r\n                let v4 = p.vel.clone().add(a3.clone().multiplyScalar(TIMESTEP)).multiplyScalar(TIMESTEP);\r\n\r\n                // RK4 weighted sums\r\n                let dx = v1.clone().add(v2.clone().multiplyScalar(2)).add(v3.clone().multiplyScalar(2)).add(v4).multiplyScalar(1 / 6);\r\n                let da = a1.clone().add(a2.clone().multiplyScalar(2)).add(a3.clone().multiplyScalar(2)).add(a4).multiplyScalar(1 / 6);\r\n\r\n                p.pos.add(dx);\r\n                p.vel.add(da.multiplyScalar(TIMESTEP));\r\n\r\n                // Clamp to grid boundary (optional)\r\n                let rmax = GRID_SIZE * GRID_STEP * 0.48;\r\n                if (Math.abs(p.pos.x) > rmax || Math.abs(p.pos.z) > rmax) {\r\n                    p.vel.set(0, 0, 0);\r\n                }\r\n                // Update mesh position\r\n                p.mesh.position.copy(p.pos);\r\n\r\n                // Update trail\r\n                p.trail.push(p.pos.clone());\r\n                if (p.trail.length > TRAIL_LENGTH) p.trail.shift();\r\n                let positions = p.trailLine.geometry.attributes.position;\r\n                for (let i = 0; i < TRAIL_LENGTH; i++) {\r\n                    let t = p.trail[i] || p.trail[0] || p.pos;\r\n                    positions.setXYZ(i, t.x, t.y + 0.03, t.z);\r\n                }\r\n                positions.needsUpdate = true;\r\n            }\r\n        }\r\n\r\n        // ==== MAIN ANIMATION LOOP ====\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n            animateParticles();\r\n            controls.update();\r\n            renderer.render(scene, camera);\r\n        }\r\n        animate();\r\n\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "gravity-sim-gpt-4-1",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Canvas",
      "Animation",
      "Particles",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:58.036Z",
    "model": "gpt-4.1",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, canvas, animation, particles, webgl, shaders, astronomy, simulation, architecture."
  }
}
