{
  "title": "3D Lennard-Jones Simulation",
  "htmlContent": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>3D Lennard-Jones Simulation</title>\n    \n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://cdn.skypack.dev/three@0.128.0\",\n                \"three/addons/\": \"https://cdn.skypack.dev/three@0.128.0/examples/jsm/\",\n                \"stats.js\": \"https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js\"\n            }\n        }\n    </script>\n    \n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js\"></script>\n    \n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n            font-family: Arial, sans-serif;\n            background-color: #f0f0f0;\n            color: #333;\n        }\n        \n        #container {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n        }\n        \n        #info {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            background-color: rgba(255, 255, 255, 0.8);\n            padding: 15px;\n            border-radius: 5px;\n            max-width: 300px;\n            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);\n        }\n        \n        #info h1 {\n            margin: 0 0 15px 0;\n            font-size: 18px;\n        }\n        \n        .data-display {\n            margin-top: 15px;\n            font-size: 14px;\n        }\n        \n        .data-display p {\n            margin: 5px 0;\n        }\n        \n        .controls {\n            margin-top: 15px;\n        }\n        \n        button {\n            padding: 8px 12px;\n            margin-right: 8px;\n            border: none;\n            border-radius: 4px;\n            background-color: #4285f4;\n            color: white;\n            cursor: pointer;\n            font-size: 14px;\n        }\n        \n        button:hover {\n            background-color: #357ae8;\n        }\n        \n        button:active {\n            background-color: #2a56c6;\n        }\n        \n        .button-group {\n            margin-bottom: 10px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"container\"></div>\n    <div id=\"info\">\n        <h1>3D Lennard-Jones Simulation</h1>\n        <div class=\"button-group\">\n            <button id=\"start-pause\">Pause</button>\n            <button id=\"reset\">Reset</button>\n        </div>\n        <div class=\"data-display\">\n            <p>Particles: <span id=\"particle-count\">64</span></p>\n            <p>Temperature: <span id=\"temperature\">0.0</span> K</p>\n            <p>Potential Energy: <span id=\"potential-energy\">0.0</span></p>\n            <p>Kinetic Energy: <span id=\"kinetic-energy\">0.0</span></p>\n            <p>Total Energy: <span id=\"total-energy\">0.0</span></p>\n            <p>Simulation Time: <span id=\"sim-time\">0.0</span></p>\n        </div>\n    </div>\n    \n    <script type=\"module\">\n        import Stats from 'stats.js';\n        import * as THREE from 'three';\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n        // dat.gui is loaded globally via script tag now\n\n        // Main simulation parameters\n        const params = {\n            numParticles: 64,\n            boxSize: 12,\n            temperature: 1.0,\n            epsilon: 1.0,\n            sigma: 1.0,\n            timeStep: 0.005,\n            cutoffRadius: 2.5,\n            running: true,\n            displayBox: true,\n            showVelocityArrows: false,\n            targetTemperature: 1.0,\n            useNoseHooverThermostat: false,\n            thermostatStrength: 1.0\n        };\n\n        // Particle data structures\n        let particles = [];\n        let positions = [];\n        let velocities = [];\n        let forces = [];\n        let masses = [];\n\n        // ThreeJS objects\n        let scene, camera, renderer, controls;\n        let spheres = [];\n        let box;\n        let stats;\n        let gui;\n        \n        // Simulation variables\n        let simTime = 0;\n        let kineticEnergy = 0;\n        let potentialEnergy = 0;\n        let totalEnergy = 0;\n        \n        // Boltzmann constant (in reduced units)\n        const kB = 1.0;\n        \n        // Initialize the simulation\n        function init() {\n            // Set up ThreeJS scene\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(0xcccccc);\n            \n            // Set up camera\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n            camera.position.set(params.boxSize * 2, params.boxSize * 2, params.boxSize * 2);\n            camera.lookAt(new THREE.Vector3(0, 0, 0));\n            \n            // Set up renderer\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            document.getElementById('container').appendChild(renderer.domElement);\n            \n            // Set up orbit controls\n            controls = new OrbitControls(camera, renderer.domElement);\n            controls.enableDamping = true;\n            controls.dampingFactor = 0.25;\n            \n            // Add lighting\n            const ambientLight = new THREE.AmbientLight(0x404040);\n            scene.add(ambientLight);\n            \n            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n            directionalLight.position.set(1, 1, 1);\n            scene.add(directionalLight);\n            \n            // Add a box to represent the simulation boundaries\n            createSimulationBox();\n            \n            // Create particles\n            initializeParticles();\n            \n            // Set up stats\n            stats = new Stats();\n            document.body.appendChild(stats.dom);\n            \n            // Set up GUI\n            gui = new dat.GUI({ autoPlace: false });\n            document.getElementById('info').appendChild(gui.domElement);\n            gui.domElement.style.marginTop = '15px'; // Add some spacing\n            \n            // Set up event listeners\n            document.getElementById('start-pause').addEventListener('click', toggleSimulation);\n            document.getElementById('reset').addEventListener('click', resetSimulation);\n            \n            // Add window resize handler\n            window.addEventListener('resize', onWindowResize);\n            \n            // Start the animation loop\n            animate();\n        }\n        \n        // Create a wireframe box to represent the simulation boundaries\n        function createSimulationBox() {\n            if (box) scene.remove(box);\n            \n            const halfSize = params.boxSize / 2;\n            const geometry = new THREE.BoxGeometry(params.boxSize, params.boxSize, params.boxSize);\n            const edges = new THREE.EdgesGeometry(geometry);\n            box = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));\n            \n            if (params.displayBox) {\n                scene.add(box);\n            }\n        }\n        \n        // Initialize particles in a lattice arrangement\n        function initializeParticles() {\n            // Clear existing particles\n            for (let sphere of spheres) {\n                scene.remove(sphere);\n            }\n            \n            particles = [];\n            positions = [];\n            velocities = [];\n            forces = [];\n            masses = [];\n            spheres = [];\n            \n            // Calculate particles per dimension for a cubic lattice\n            const particlesPerDim = Math.ceil(Math.pow(params.numParticles, 1/3));\n            const spacing = params.boxSize / particlesPerDim;\n            const offset = params.boxSize / 2 - spacing / 2;\n            \n            let count = 0;\n            // Create particles on a grid\n            for (let i = 0; i < particlesPerDim && count < params.numParticles; i++) {\n                for (let j = 0; j < particlesPerDim && count < params.numParticles; j++) {\n                    for (let k = 0; k < particlesPerDim && count < params.numParticles; k++) {\n                        const x = i * spacing - offset;\n                        const y = j * spacing - offset;\n                        const z = k * spacing - offset;\n                        \n                        // Create ThreeJS sphere\n                        const radius = params.sigma / 2; // Radius based on sigma\n                        const geometry = new THREE.SphereGeometry(radius, 16, 16);\n                        const material = new THREE.MeshPhongMaterial({ \n                            color: 0x3399ff, \n                            specular: 0x555555, \n                            shininess: 30 \n                        });\n                        const sphere = new THREE.Mesh(geometry, material);\n                        sphere.position.set(x, y, z);\n                        scene.add(sphere);\n                        spheres.push(sphere);\n                        \n                        // Add to particle data\n                        particles.push({ id: count });\n                        positions.push(new THREE.Vector3(x, y, z));\n                        masses.push(1.0); // All particles have the same mass (1.0 in reduced units)\n                        \n                        count++;\n                    }\n                }\n            }\n            \n            // Initialize velocities from Maxwell-Boltzmann distribution\n            initializeVelocities();\n            \n            // Calculate initial forces\n            forces = new Array(params.numParticles).fill().map(() => new THREE.Vector3(0, 0, 0));\n            calculateForces();\n            \n            // Update display\n            document.getElementById('particle-count').textContent = params.numParticles;\n        }\n        \n        // Initialize particle velocities based on Maxwell-Boltzmann distribution\n        function initializeVelocities() {\n            velocities = [];\n            \n            // Generate velocities using Box-Muller transform\n            for (let i = 0; i < params.numParticles; i++) {\n                const vx = boxMullerTransform() * Math.sqrt(params.temperature);\n                const vy = boxMullerTransform() * Math.sqrt(params.temperature);\n                const vz = boxMullerTransform() * Math.sqrt(params.temperature);\n                \n                velocities.push(new THREE.Vector3(vx, vy, vz));\n            }\n            \n            // Remove any net momentum\n            removeNetMomentum();\n            \n            // Scale velocities to match target temperature\n            scaleVelocitiesToTemperature(params.temperature);\n        }\n        \n        // Box-Muller transform for generating normal distribution\n        function boxMullerTransform() {\n            const u1 = Math.random();\n            const u2 = Math.random();\n            \n            const z = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);\n            return z;\n        }\n        \n        // Remove net momentum from the system\n        function removeNetMomentum() {\n            const totalMomentum = new THREE.Vector3(0, 0, 0);\n            const totalMass = masses.reduce((sum, mass) => sum + mass, 0);\n            \n            // Calculate total momentum\n            for (let i = 0; i < params.numParticles; i++) {\n                totalMomentum.add(velocities[i].clone().multiplyScalar(masses[i]));\n            }\n            \n            // Calculate center of mass velocity\n            const comVelocity = totalMomentum.clone().divideScalar(totalMass);\n            \n            // Subtract COM velocity from each particle\n            for (let i = 0; i < params.numParticles; i++) {\n                velocities[i].sub(comVelocity);\n            }\n        }\n        \n        // Scale velocities to match target temperature\n        function scaleVelocitiesToTemperature(targetTemp) {\n            // Calculate current kinetic energy\n            const currentKE = calculateKineticEnergy();\n            \n            // Calculate target kinetic energy: KE = 3/2 * N * kB * T\n            const targetKE = 1.5 * params.numParticles * kB * targetTemp;\n            \n            // Calculate scaling factor\n            const scaleFactor = Math.sqrt(targetKE / currentKE);\n            \n            // Scale all velocities\n            for (let i = 0; i < params.numParticles; i++) {\n                velocities[i].multiplyScalar(scaleFactor);\n            }\n            \n            // Recalculate kinetic energy\n            kineticEnergy = calculateKineticEnergy();\n        }\n        \n        // Calculate kinetic energy of the system\n        function calculateKineticEnergy() {\n            let ke = 0;\n            \n            for (let i = 0; i < params.numParticles; i++) {\n                const v2 = velocities[i].lengthSq();\n                ke += 0.5 * masses[i] * v2;\n            }\n            \n            return ke;\n        }\n        \n        // Calculate forces using Lennard-Jones potential\n        function calculateForces() {\n            // Reset forces\n            for (let i = 0; i < params.numParticles; i++) {\n                forces[i].set(0, 0, 0);\n            }\n            \n            // Reset potential energy\n            potentialEnergy = 0;\n            \n            // Calculate pairwise interactions\n            for (let i = 0; i < params.numParticles - 1; i++) {\n                for (let j = i + 1; j < params.numParticles; j++) {\n                    // Calculate distance vector with minimum image convention\n                    const rij = positions[i].clone().sub(positions[j]);\n                    \n                    // Apply periodic boundary conditions to distance vector\n                    applyMinimumImageConvention(rij);\n                    \n                    // Calculate squared distance\n                    const r2 = rij.lengthSq();\n                    \n                    // Check if within cutoff radius\n                    if (r2 < params.cutoffRadius * params.cutoffRadius) {\n                        // Calculate normalized direction vector\n                        const r = Math.sqrt(r2);\n                        const dir = rij.clone().divideScalar(r);\n                        \n                        // Calculate LJ force magnitude\n                        const force = calculateLennardJonesForce(r, params.epsilon, params.sigma);\n                        \n                        // Apply force to particles (F_ij = -F_ji)\n                        const forceVector = dir.multiplyScalar(force);\n                        forces[i].add(forceVector);\n                        forces[j].sub(forceVector);\n                        \n                        // Calculate potential energy contribution\n                        const pe = calculateLennardJonesPotential(r, params.epsilon, params.sigma);\n                        potentialEnergy += pe;\n                    }\n                }\n            }\n        }\n        \n        // Calculate Lennard-Jones force between two particles\n        function calculateLennardJonesForce(r, epsilon, sigma) {\n            // F(r) = 48 * epsilon / sigma^2 * [(sigma/r)^14 - 0.5 * (sigma/r)^8]\n            const sr = sigma / r;\n            const sr6 = Math.pow(sr, 6);\n            const sr8 = sr6 * sr * sr;\n            const sr14 = sr8 * sr6;\n            \n            return 48.0 * epsilon / (sigma * sigma) * (sr14 - 0.5 * sr8);\n        }\n        \n        // Calculate Lennard-Jones potential energy\n        function calculateLennardJonesPotential(r, epsilon, sigma) {\n            // V(r) = 4 * epsilon * [(sigma/r)^12 - (sigma/r)^6]\n            const sr = sigma / r;\n            const sr6 = Math.pow(sr, 6);\n            const sr12 = sr6 * sr6;\n            \n            return 4.0 * epsilon * (sr12 - sr6);\n        }\n        \n        // Apply minimum image convention for periodic boundary conditions\n        function applyMinimumImageConvention(rij) {\n            // Adjust each component to find shortest distance across periodic boundaries\n            if (rij.x > params.boxSize / 2) rij.x -= params.boxSize;\n            else if (rij.x < -params.boxSize / 2) rij.x += params.boxSize;\n            \n            if (rij.y > params.boxSize / 2) rij.y -= params.boxSize;\n            else if (rij.y < -params.boxSize / 2) rij.y += params.boxSize;\n            \n            if (rij.z > params.boxSize / 2) rij.z -= params.boxSize;\n            else if (rij.z < -params.boxSize / 2) rij.z += params.boxSize;\n        }\n        \n        // Apply periodic boundary conditions to particle position\n        function applyPeriodicBoundary() {\n            const halfSize = params.boxSize / 2;\n            \n            for (let i = 0; i < params.numParticles; i++) {\n                // X-dimension\n                if (positions[i].x < -halfSize) positions[i].x += params.boxSize;\n                else if (positions[i].x > halfSize) positions[i].x -= params.boxSize;\n                \n                // Y-dimension\n                if (positions[i].y < -halfSize) positions[i].y += params.boxSize;\n                else if (positions[i].y > halfSize) positions[i].y -= params.boxSize;\n                \n                // Z-dimension\n                if (positions[i].z < -halfSize) positions[i].z += params.boxSize;\n                else if (positions[i].z > halfSize) positions[i].z -= params.boxSize;\n            }\n        }\n        \n        // Velocity Verlet integrator\n        function integrateDynamics() {\n            const dt = params.timeStep;\n            const halfdt = dt / 2;\n            \n            // Step 1: v(t + dt/2) = v(t) + a(t) * dt/2\n            for (let i = 0; i < params.numParticles; i++) {\n                const acceleration = forces[i].clone().divideScalar(masses[i]);\n                velocities[i].addScaledVector(acceleration, halfdt);\n            }\n            \n            // Step 2: x(t + dt) = x(t) + v(t + dt/2) * dt\n            for (let i = 0; i < params.numParticles; i++) {\n                positions[i].addScaledVector(velocities[i], dt);\n            }\n            \n            // Apply periodic boundary conditions\n            applyPeriodicBoundary();\n            \n            // Step 3: Calculate forces at new positions\n            calculateForces();\n            \n            // Step 4: v(t + dt) = v(t + dt/2) + a(t + dt) * dt/2\n            for (let i = 0; i < params.numParticles; i++) {\n                const acceleration = forces[i].clone().divideScalar(masses[i]);\n                velocities[i].addScaledVector(acceleration, halfdt);\n            }\n            \n            // Apply thermostat if enabled\n            if (params.useNoseHooverThermostat) {\n                applyThermostat();\n            }\n            \n            // Calculate kinetic energy\n            kineticEnergy = calculateKineticEnergy();\n            \n            // Calculate total energy\n            totalEnergy = kineticEnergy + potentialEnergy;\n            \n            // Update simulation time\n            simTime += dt;\n        }\n        \n        // Apply a simple velocity scaling thermostat\n        function applyThermostat() {\n            // Calculate current temperature from kinetic energy\n            const currentKE = calculateKineticEnergy();\n            const currentTemp = (2.0 / 3.0) * currentKE / (params.numParticles * kB);\n            \n            // Calculate scaling factor using Nose-Hoover approach\n            // This is a simplified version that uses direct velocity scaling\n            if (currentTemp > 0) {\n                const scaleFactor = Math.sqrt(params.targetTemperature / currentTemp);\n                const alpha = 1.0 + params.thermostatStrength * params.timeStep * (scaleFactor - 1.0);\n                \n                // Scale velocities gradually towards target temperature\n                for (let i = 0; i < params.numParticles; i++) {\n                    velocities[i].multiplyScalar(alpha);\n                }\n            }\n        }\n        \n        // Calculate instantaneous temperature from kinetic energy\n        function calculateTemperature() {\n            // T = 2K / (3NkB)\n            return (2.0 / 3.0) * kineticEnergy / (params.numParticles * kB);\n        }\n        \n        // Update particle positions in the visualization\n        function updateParticlePositions() {\n            for (let i = 0; i < params.numParticles; i++) {\n                spheres[i].position.copy(positions[i]);\n            }\n        }\n        \n        // Update data display\n        function updateDataDisplay() {\n            const temperature = calculateTemperature();\n            \n            document.getElementById('temperature').textContent = temperature.toFixed(2);\n            document.getElementById('potential-energy').textContent = potentialEnergy.toFixed(2);\n            document.getElementById('kinetic-energy').textContent = kineticEnergy.toFixed(2);\n            document.getElementById('total-energy').textContent = totalEnergy.toFixed(2);\n            document.getElementById('sim-time').textContent = simTime.toFixed(2);\n        }\n        \n        // Toggle simulation running state\n        function toggleSimulation() {\n            params.running = !params.running;\n            const button = document.getElementById('start-pause');\n            button.textContent = params.running ? 'Pause' : 'Start';\n        }\n        \n        // Reset the simulation\n        function resetSimulation() {\n            simTime = 0;\n            initializeParticles();\n        }\n        \n        // Handle window resize\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n        \n        // Main animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n            \n            if (params.running) {\n                // Perform integration step\n                integrateDynamics();\n                \n                // Update positions in the visualization\n                updateParticlePositions();\n                \n                // Update data display\n                updateDataDisplay();\n            }\n            \n            // Update controls\n            controls.update();\n            \n            // Update stats\n            stats.update();\n            \n            // Render scene\n            renderer.render(scene, camera);\n        }\n        \n        // Start simulation when the page loads\n        window.onload = function() {\n            // Initialize the simulation\n            init();\n        };\n    </script>\n</body>\n</html>",
  "id": "3d-lennard-jones-fluid-gas-simulation-claude-3-7",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "Particles",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.706Z",
    "model": "claude-3.7",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, particles, webgl, shaders, astronomy, simulation, architecture."
  }
}
