{
  "title": "Voxel Fire Simulation",
  "htmlContent": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Voxel Fire Simulation</title>\n  <style>\n    /* Basic CSS styling */\n    body {\n      margin: 0;\n      overflow: hidden;\n      background: #000;\n    }\n    canvas {\n      display: block;\n    }\n    #ui {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      z-index: 100;\n      color: #fff;\n    }\n    button {\n      font-size: 16px;\n      padding: 8px 12px;\n      cursor: pointer;\n    }\n  </style>\n</head>\n<body>\n  <!-- UI Section: Reset button -->\n  <div id=\"ui\">\n    <button id=\"resetBtn\">Reset Simulation</button>\n  </div>\n  \n  <!-- The canvas element for Three.js -->\n  <canvas id=\"sceneCanvas\"></canvas>\n  \n  <script type=\"module\">\n    // Import necessary modules from Skypack CDN\n    import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';\n    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';\n\n    // Global variables and parameters\n    let scene, camera, renderer, controls, raycaster;\n    let voxelGrid = [];     // 3D array storing our voxels and state\n    let voxelMeshes = [];   // Array to hold the mesh objects for raycasting\n    let smokeParticles = []; // To hold our smoke sprite particles\n    \n    // Grid parameters\n    const GRID_SIZE   = 10;\n    const voxelSize   = 1;\n    const spacing     = 1.1;         // Extra spacing to visualize gaps between voxels\n    const initialFuel = 100;         // How long each voxel burns\n    const fireDecay   = 0.5;         // Fuel reduction per frame for burning voxels\n    const fireSpreadProbability = 0.005; // Chance per frame to ignite each neighbor\n    \n    // Define materials for each voxel state:\n    const flammableMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // wood/brown\n    const burningMaterial   = new THREE.MeshLambertMaterial({ color: 0xff4500 }); // orange-red fire\n    const burntMaterial     = new THREE.MeshLambertMaterial({ color: 0x222222 }); // dark grey/black\n    \n    // Initialize scene, camera, renderer, lights, and controls\n    init();\n    animate();\n    \n    function init() {\n      const canvas = document.getElementById('sceneCanvas');\n      \n      // Create scene\n      scene = new THREE.Scene();\n      scene.background = new THREE.Color(0x000000);\n      \n      // Create camera\n      camera = new THREE.PerspectiveCamera(\n        45,\n        window.innerWidth / window.innerHeight,\n        0.1,\n        1000\n      );\n      // Position camera so the entire grid is in view\n      camera.position.set(GRID_SIZE * 1.5, GRID_SIZE * 1.5, GRID_SIZE * 1.5);\n      \n      // Create renderer and attach to the canvas element\n      renderer = new THREE.WebGLRenderer({ canvas: canvas });\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      \n      // Add orbit controls for easy navigation\n      controls = new OrbitControls(camera, renderer.domElement);\n      \n      // Add ambient and directional lighting\n      const ambientLight = new THREE.AmbientLight(0x404040);\n      scene.add(ambientLight);\n      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n      directionalLight.position.set(1, 2, 3);\n      scene.add(directionalLight);\n      \n      // Initialize raycaster for detecting mouse clicks on voxels\n      raycaster = new THREE.Raycaster();\n      \n      // Build the voxel grid\n      createVoxelGrid();\n      \n      // Event listeners for window resize, mouse clicks, and reset button\n      window.addEventListener('resize', onWindowResize, false);\n      window.addEventListener('click', onMouseClick, false);\n      document.getElementById('resetBtn').addEventListener('click', resetSimulation);\n    }\n    \n    function createVoxelGrid() {\n      // Use a single BoxGeometry for all voxels\n      const geometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);\n      \n      // Create a 3D grid of voxels\n      for (let i = 0; i < GRID_SIZE; i++) {\n        voxelGrid[i] = [];\n        for (let j = 0; j < GRID_SIZE; j++) {\n          voxelGrid[i][j] = [];\n          for (let k = 0; k < GRID_SIZE; k++) {\n            // Create a new mesh with its own instance of the flammable material\n            const mesh = new THREE.Mesh(geometry, flammableMaterial.clone());\n            // Center the grid around the origin:\n            const offset = (GRID_SIZE - 1) * spacing / 2;\n            mesh.position.set(i * spacing - offset, j * spacing - offset, k * spacing - offset);\n            scene.add(mesh);\n            voxelMeshes.push(mesh);\n            \n            // Each voxel stores its state and will later receive neighbor references\n            const voxel = {\n              mesh: mesh,\n              state: {\n                isFlammable: true,\n                isOnFire: false,\n                fuel: initialFuel\n              },\n              neighbors: [] // Will be populated in the next loop\n            };\n            voxelGrid[i][j][k] = voxel;\n          }\n        }\n      }\n      \n      // Set up neighbor references (6-directional: +/-x, +/-y, +/-z)\n      for (let i = 0; i < GRID_SIZE; i++) {\n        for (let j = 0; j < GRID_SIZE; j++) {\n          for (let k = 0; k < GRID_SIZE; k++) {\n            let neighbors = [];\n            const directions = [\n              [1, 0, 0],\n              [-1, 0, 0],\n              [0, 1, 0],\n              [0, -1, 0],\n              [0, 0, 1],\n              [0, 0, -1]\n            ];\n            directions.forEach(dir => {\n              const ni = i + dir[0],\n                    nj = j + dir[1],\n                    nk = k + dir[2];\n              if (ni >= 0 && ni < GRID_SIZE &&\n                  nj >= 0 && nj < GRID_SIZE &&\n                  nk >= 0 && nk < GRID_SIZE) {\n                neighbors.push(voxelGrid[ni][nj][nk]);\n              }\n            });\n            voxelGrid[i][j][k].neighbors = neighbors;\n          }\n        }\n      }\n    }\n    \n    // Keep the camera and renderer in sync when the window size changes.\n    function onWindowResize() {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n    \n    // Handle mouse clicks by using raycasting to detect a voxel click.\n    function onMouseClick(event) {\n      const mouse = new THREE.Vector2();\n      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n      \n      raycaster.setFromCamera(mouse, camera);\n      const intersects = raycaster.intersectObjects(voxelMeshes);\n      \n      if (intersects.length > 0) {\n        const mesh = intersects[0].object;\n        const voxel = getVoxelByMesh(mesh);\n        if (voxel && voxel.state.isFlammable && !voxel.state.isOnFire) {\n          igniteVoxel(voxel);\n        }\n      }\n    }\n    \n    // Helper function to retrieve the voxel corresponding to a clicked mesh.\n    function getVoxelByMesh(mesh) {\n      for (let i = 0; i < GRID_SIZE; i++) {\n        for (let j = 0; j < GRID_SIZE; j++) {\n          for (let k = 0; k < GRID_SIZE; k++) {\n            if (voxelGrid[i][j][k].mesh === mesh) {\n              return voxelGrid[i][j][k];\n            }\n          }\n        }\n      }\n      return null;\n    }\n    \n    // Ignite a voxel (set its state and change its material to the burning material)\n    function igniteVoxel(voxel) {\n      voxel.state.isOnFire = true;\n      voxel.state.fuel = initialFuel;\n      voxel.mesh.material = burningMaterial;\n    }\n    \n    // Update the simulation for each frame:\n    // - Decrease fuel for burning voxels.\n    // - Change states to burnt once fuel is exhausted.\n    // - Attempt fire spread to adjacent flammable voxels.\n    function updateVoxels() {\n      for (let i = 0; i < GRID_SIZE; i++) {\n        for (let j = 0; j < GRID_SIZE; j++) {\n          for (let k = 0; k < GRID_SIZE; k++) {\n            const voxel = voxelGrid[i][j][k];\n            if (voxel.state.isOnFire) {\n              // Decrease fuel and spawn occasional smoke particles\n              voxel.state.fuel -= fireDecay;\n              if (Math.random() < 0.1) spawnSmokeParticle(voxel);\n              \n              // When the voxel runs out of fuel, mark it as burnt\n              if (voxel.state.fuel <= 0) {\n                voxel.state.isOnFire = false;\n                voxel.state.isFlammable = false;\n                voxel.mesh.material = burntMaterial;\n              } else {\n                // For each neighbor, try to spread the fire based on probability\n                voxel.neighbors.forEach(neighbor => {\n                  if (neighbor.state.isFlammable && !neighbor.state.isOnFire) {\n                    if (Math.random() < fireSpreadProbability) {\n                      igniteVoxel(neighbor);\n                    }\n                  }\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // --- Smoke Particle System (Optional) ---\n    // Each smoke particle is a small sprite that slowly rises and fades.\n    function spawnSmokeParticle(voxel) {\n      const spriteMaterial = new THREE.SpriteMaterial({ color: 0x555555, opacity: 0.6 });\n      const sprite = new THREE.Sprite(spriteMaterial);\n      sprite.scale.set(0.5, 0.5, 0.5);\n      sprite.position.copy(voxel.mesh.position);\n      scene.add(sprite);\n      smokeParticles.push({ sprite: sprite, lifetime: 100 });\n    }\n    \n    // Update smoke particles: move them upward, fade their opacity, and remove when expired.\n    function updateSmokeParticles() {\n      for (let i = smokeParticles.length - 1; i >= 0; i--) {\n        const particle = smokeParticles[i];\n        particle.lifetime -= 1;\n        particle.sprite.position.y += 0.01;         // Slowly rise upward\n        particle.sprite.material.opacity *= 0.98;     // Gradually fade\n        if (particle.lifetime <= 0 || particle.sprite.material.opacity < 0.05) {\n          scene.remove(particle.sprite);\n          smokeParticles.splice(i, 1);\n        }\n      }\n    }\n    \n    // Main animation loop – updates the simulation and renders the scene\n    function animate() {\n      requestAnimationFrame(animate);\n      updateVoxels();\n      updateSmokeParticles();\n      controls.update();\n      renderer.render(scene, camera);\n    }\n    \n    // Reset the simulation so that every voxel goes back to its initial flammable state.\n    function resetSimulation() {\n      for (let i = 0; i < GRID_SIZE; i++) {\n        for (let j = 0; j < GRID_SIZE; j++) {\n          for (let k = 0; k < GRID_SIZE; k++) {\n            const voxel = voxelGrid[i][j][k];\n            voxel.state.isFlammable = true;\n            voxel.state.isOnFire   = false;\n            voxel.state.fuel       = initialFuel;\n            voxel.mesh.material    = flammableMaterial;\n          }\n        }\n      }\n      // Remove any remaining smoke particles from the scene.\n      smokeParticles.forEach(p => scene.remove(p.sprite));\n      smokeParticles = [];\n    }\n  </script>\n</body>\n</html>\n",
  "id": "voxel-fire-simulation-gpt-o3-high",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Canvas",
      "Animation",
      "Particles",
      "WebGL",
      "Shaders",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:58.053Z",
    "model": "gpt-o3-high",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, canvas, animation, particles, webgl, shaders, simulation, architecture."
  }
}
