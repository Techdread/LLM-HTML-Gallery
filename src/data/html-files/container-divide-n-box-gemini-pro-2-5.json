{
  "title": "3D Container with N Boxes - JSON Output",
  "htmlContent": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>3D Container with N Boxes - JSON Output</title>\n    <style>\n        /* Basic page styling */\n        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #111; color: #fff; }\n        canvas { display: block; } /* Prevent scrollbars */\n\n        /* Styling for the information panel (top-left) */\n        #info {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            background-color: rgba(0, 0, 0, 0.7);\n            padding: 10px;\n            border-radius: 5px;\n            border: 1px solid #555;\n            min-width: 200px;\n            z-index: 10;\n        }\n        #info h3 { margin-top: 0; }\n        #info p { margin: 5px 0; }\n\n        /* Styling for the controls panel (bottom-left) */\n        #controls {\n            position: absolute;\n            bottom: 10px;\n            left: 10px;\n            background-color: rgba(0, 0, 0, 0.7);\n            padding: 10px;\n            border-radius: 5px;\n            border: 1px solid #555;\n            z-index: 10;\n            display: flex; /* Arrange items horizontally */\n            align-items: center; /* Vertically align items */\n            gap: 10px; /* Space between elements */\n        }\n        /* Style for new input/button */\n        #controls label, #controls input, #controls button {\n             font-size: 0.9em;\n        }\n         #controls input[type=\"number\"] {\n            width: 60px; /* Adjust width */\n            padding: 4px;\n            border-radius: 3px;\n            border: 1px solid #555;\n            background-color: #333;\n            color: #fff;\n         }\n         #controls button {\n             padding: 5px 10px;\n             border-radius: 3px;\n             border: 1px solid #555;\n             background-color: #444;\n             color: #fff;\n             cursor: pointer;\n         }\n         #controls button:hover {\n             background-color: #555;\n         }\n\n\n        /* Styling for the JSON output container (above controls) */\n         #jsonOutputContainer {\n            position: absolute;\n            /* Adjusted bottom position to make space for controls */\n            bottom: 75px;\n            left: 10px;\n            width: 350px;\n            max-height: 600px;\n            height: 400px;\n            background-color: rgba(0, 0, 0, 0.7);\n            padding: 10px;\n            border-radius: 5px;\n            border: 1px solid #555;\n            z-index: 5;\n            display: flex;\n            flex-direction: column;\n        }\n        #jsonOutputContainer label {\n            margin-bottom: 5px;\n            font-weight: bold;\n            color: #ccc;\n        }\n        #jsonDataOutput {\n            width: 100%;\n            flex-grow: 1;\n            background-color: #222;\n            color: #ddd;\n            border: 1px solid #444;\n            border-radius: 3px;\n            font-family: monospace;\n            font-size: 0.8em;\n            resize: none;\n            white-space: pre;\n            overflow: auto;\n            box-sizing: border-box;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"info\">\n        <h3>Box Information</h3>\n        <p>Click on a box to see its details.</p>\n        <p id=\"box-id\">ID: -</p>\n        <p id=\"box-dims\">Dimensions: -</p>\n        <p id=\"box-vol\">Volume: -</p>\n    </div>\n\n    <div id=\"controls\">\n        <label>\n            <input type=\"checkbox\" id=\"visibilityToggle\" disabled> Toggle Selected Visibility\n        </label>\n        <label for=\"boxCountInput\">Boxes (n):</label>\n        <input type=\"number\" id=\"boxCountInput\" value=\"55\" min=\"2\" max=\"1000\">\n        <button id=\"regenerateButton\">Generate</button>\n    </div>\n\n    <div id=\"jsonOutputContainer\">\n        <label for=\"jsonDataOutput\">Generated Box Data (JSON):</label>\n        <textarea id=\"jsonDataOutput\" readonly></textarea>\n    </div>\n\n\n    <script async src=\"https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js\"></script>\n\n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js\",\n                \"three/addons/\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/\"\n            }\n        }\n    </script>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n        // --- Configuration ---\n        const containerDimensions = { w: 1200, h: 1000, d: 1200 };\n        // Default box count removed, will be read from input\n        const highlightColor = 0xffff00; // Yellow for selected box\n\n        // --- Global Variables ---\n        let scene, camera, renderer, controls;\n        let raycaster, mouse;\n        let containerMesh, containerWireframe; // References to container parts\n        let internalBoxesGroup; // Group to hold the smaller boxes\n        let clickableBoxes = []; // Array for raycasting interaction\n        let selectedBoxMesh = null; // Currently selected box\n\n        // References to HTML UI elements\n        const infoPanel = {\n            id: document.getElementById('box-id'),\n            dims: document.getElementById('box-dims'),\n            vol: document.getElementById('box-vol'),\n            title: document.querySelector('#info h3'),\n            defaultText: document.querySelector('#info p'),\n        };\n        const visibilityToggle = document.getElementById('visibilityToggle');\n        const jsonOutputTextarea = document.getElementById('jsonDataOutput');\n        const boxCountInput = document.getElementById('boxCountInput'); // Input for n\n        const regenerateButton = document.getElementById('regenerateButton'); // Button\n\n        // --- Algorithm: Generate Box Data ---\n        // (Function remains the same as before, accepting 'count' as parameter)\n        function generateBoxes(containerW, containerH, containerD, count) {\n            let boxIdCounter = 0;\n            const boxes = [];\n            let spaces = [ { x: 0, y: 0, z: 0, w: containerW, h: containerH, d: containerD } ];\n\n            while (spaces.length < count && spaces.length > 0) {\n                let largestSpaceIndex = -1;\n                let largestVolume = -1;\n                for (let i = 0; i < spaces.length; i++) {\n                    const vol = spaces[i].w * spaces[i].h * spaces[i].d;\n                    if (vol > largestVolume) {\n                        largestVolume = vol;\n                        largestSpaceIndex = i;\n                    }\n                }\n                 if (largestSpaceIndex === -1) break; // Should not happen if spaces exist\n\n                const spaceToSplit = spaces.splice(largestSpaceIndex, 1)[0];\n\n                let axis;\n                const dims = [spaceToSplit.w, spaceToSplit.h, spaceToSplit.d];\n                const maxDim = Math.max(...dims);\n\n                // Prioritize splitting along the longest dimension that is >= 2\n                if (maxDim === spaceToSplit.w && spaceToSplit.w >= 2) axis = 'x';\n                else if (maxDim === spaceToSplit.h && spaceToSplit.h >= 2) axis = 'y';\n                else if (maxDim === spaceToSplit.d && spaceToSplit.d >= 2) axis = 'z';\n                else { // Fallback: Find *any* dimension >= 2 to split\n                    if (spaceToSplit.w >= 2) axis = 'x';\n                    else if (spaceToSplit.h >= 2) axis = 'y';\n                    else if (spaceToSplit.d >= 2) axis = 'z';\n                    else { // Cannot split this space further\n                        spaces.push(spaceToSplit); // Put it back\n                        console.warn(\"Cannot split space further (all dims < 2):\", spaceToSplit);\n                        // If we keep failing to split, we might enter an infinite loop.\n                        // Break if no progress is made (e.g., check if spaces.length decreased).\n                        // For simplicity here, we rely on the outer loop condition.\n                        // A more robust solution might remove unsplittable spaces.\n                        continue; // Try splitting another space\n                    }\n                }\n\n                let splitCoord;\n                let dimSize;\n                switch (axis) {\n                    case 'x': dimSize = spaceToSplit.w; break;\n                    case 'y': dimSize = spaceToSplit.h; break;\n                    case 'z': dimSize = spaceToSplit.d; break;\n                }\n\n                // Recalculate dimSize in case fallback axis was chosen\n                // dimSize = spaceToSplit[axis]; // Alternative using axis string as key\n\n                if (dimSize < 2) { // Should ideally be caught above\n                     spaces.push(spaceToSplit);\n                     console.warn(\"Dimension < 2 on selected axis:\", axis, dimSize);\n                     continue;\n                }\n\n                const randomFactor = 0.4 + Math.random() * 0.2;\n                splitCoord = Math.floor(dimSize * randomFactor);\n                if (splitCoord <= 0) splitCoord = 1;\n                if (splitCoord >= dimSize) splitCoord = dimSize - 1;\n\n                const space1 = { ...spaceToSplit };\n                const space2 = { ...spaceToSplit };\n\n                switch (axis) {\n                    case 'x':\n                        space1.w = splitCoord;\n                        space2.x = spaceToSplit.x + splitCoord;\n                        space2.w = spaceToSplit.w - splitCoord;\n                        break;\n                    case 'y':\n                        space1.h = splitCoord;\n                        space2.y = spaceToSplit.y + splitCoord;\n                        space2.h = spaceToSplit.h - splitCoord;\n                        break;\n                    case 'z':\n                        space1.d = splitCoord;\n                        space2.z = spaceToSplit.z + splitCoord;\n                        space2.d = spaceToSplit.d - splitCoord;\n                        break;\n                }\n\n                 if(space1.w > 0 && space1.h > 0 && space1.d > 0) spaces.push(space1);\n                 if(space2.w > 0 && space2.h > 0 && space2.d > 0) spaces.push(space2);\n            }\n\n             // Convert final spaces to boxes\n             spaces.forEach(space => {\n                  if (boxes.length < count) { // Ensure we don't exceed count due to edge cases\n                     boxes.push({\n                         id: boxIdCounter++,\n                         x: space.x, y: space.y, z: space.z,\n                         w: space.w, h: space.h, d: space.d,\n                         volume: space.w * space.h * space.d\n                     });\n                  }\n             });\n\n            // --- Verification Logs ---\n            let totalVolume = 0;\n            boxes.forEach(b => totalVolume += b.volume);\n            const expectedVolume = containerW * containerH * containerD;\n            console.log(`--- Box Generation Complete ---`);\n            console.log(`Target Count: ${count}, Generated Count: ${boxes.length}`);\n            console.log(`Target Volume: ${expectedVolume.toLocaleString()}`);\n            console.log(`Sum of Box Volumes: ${totalVolume.toLocaleString()}`);\n            if (boxes.length !== count && spaces.length > 0) {\n                console.warn(`Could only generate ${boxes.length} boxes. Smallest remaining space might be unsplittable.`);\n            }\n            if (totalVolume !== expectedVolume && boxes.length === count) {\n                 console.warn(\"Volume mismatch detected!\");\n            }\n            // Uniqueness check (optional)\n            // ... (same uniqueness check code as before) ...\n            console.log(`-----------------------------`);\n\n            return boxes;\n        }\n\n        // --- Clear Old Boxes ---\n        // Removes existing internal boxes from the scene and disposes resources\n        function clearOldBoxes() {\n            console.log(`Clearing ${internalBoxesGroup.children.length} old boxes...`);\n            // Deselect any currently selected box\n            deselectBox();\n\n            // Remove meshes from the group and dispose geometry/material\n            // Iterate backwards when removing items from an array/group\n            for (let i = internalBoxesGroup.children.length - 1; i >= 0; i--) {\n                const mesh = internalBoxesGroup.children[i];\n\n                // Dispose outline geometry/material (if it exists as the first child)\n                if (mesh.children.length > 0 && mesh.children[0].geometry && mesh.children[0].material) {\n                    mesh.children[0].geometry.dispose();\n                    mesh.children[0].material.dispose();\n                     // No need to explicitly remove child outline, it's removed with parent mesh\n                }\n\n                // Dispose main mesh geometry and material\n                if (mesh.geometry) mesh.geometry.dispose();\n                if (mesh.material) {\n                    // If material was cloned for highlighting, ensure original is disposed too (if stored)\n                    if (mesh.userData.originalMaterial && mesh.userData.originalMaterial !== mesh.material) {\n                         mesh.userData.originalMaterial.dispose();\n                    }\n                    mesh.material.dispose();\n                }\n                // Remove mesh from the group\n                internalBoxesGroup.remove(mesh);\n            }\n            // Clear the array used for raycasting\n            clickableBoxes = [];\n             console.log(\"Clearing complete.\");\n        }\n\n        // --- Regenerate Internal Boxes ---\n        // Clears old boxes, generates new ones based on 'n', and adds them to the scene\n        function regenerateInternalBoxes(n) {\n            if (typeof n !== 'number' || n < 2) {\n                console.error(\"Invalid number of boxes requested:\", n);\n                alert(\"Please enter a valid number of boxes (minimum 2).\");\n                return;\n            }\n            console.log(`Regenerating with ${n} boxes...`);\n\n            // 1. Clear existing boxes\n            clearOldBoxes();\n\n            // 2. Generate new box data\n            const boxData = generateBoxes(containerDimensions.w, containerDimensions.h, containerDimensions.d, n);\n\n            // 3. Output new data as JSON\n            const boxDataJson = JSON.stringify(boxData, null, 2);\n            jsonOutputTextarea.value = boxDataJson;\n            // Optionally log to console as well\n            // console.log(\"--- Generated Box Data (JSON) ---\");\n            // console.log(boxDataJson);\n            // console.log(\"---------------------------------\");\n\n            // 4. Create and add new meshes\n            boxData.forEach(box => {\n                const geometry = new THREE.BoxGeometry(box.w, box.h, box.d);\n                const randomColor = Math.random() * 0xffffff;\n                const material = new THREE.MeshStandardMaterial({\n                    color: randomColor,\n                    metalness: 0.2,\n                    roughness: 0.8,\n                });\n                const mesh = new THREE.Mesh(geometry, material);\n                mesh.position.set(\n                    box.x + box.w / 2,\n                    box.y + box.h / 2,\n                    box.z + box.d / 2\n                );\n\n                 const boxEdges = new THREE.EdgesGeometry( geometry );\n                 const boxOutlineMat = new THREE.LineBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.3 } );\n                 const boxOutline = new THREE.LineSegments( boxEdges, boxOutlineMat );\n                 mesh.add( boxOutline );\n\n                mesh.userData = {\n                    id: box.id,\n                    dimensions: { w: box.w, h: box.h, d: box.d },\n                    volume: box.volume,\n                    originalMaterial: material,\n                    outlineMaterial: boxOutlineMat\n                };\n\n                internalBoxesGroup.add(mesh);\n                clickableBoxes.push(mesh); // Add to array for interaction\n            });\n             console.log(`Added ${internalBoxesGroup.children.length} new meshes to the scene.`);\n        }\n\n\n        // --- ThreeJS Initialization ---\n        function init() {\n            // Scene setup\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(0x1a1a1a);\n\n            // Camera setup\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 10, 5000);\n             camera.position.set(containerDimensions.w * 0.8, containerDimensions.h * 1.0, containerDimensions.d * 0.8);\n             camera.lookAt(0, 0, 0);\n\n            // Renderer setup\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            document.body.appendChild(renderer.domElement);\n\n            // OrbitControls setup\n            controls = new OrbitControls(camera, renderer.domElement);\n            controls.enableDamping = true;\n             controls.target.set(containerDimensions.w / 2, containerDimensions.h / 2, containerDimensions.d / 2);\n             controls.update();\n\n            // Lighting setup\n            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);\n            scene.add(ambientLight);\n            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n            directionalLight.position.set(1, 1, 1).normalize();\n            scene.add(directionalLight);\n\n            // Raycaster setup\n            raycaster = new THREE.Raycaster();\n            mouse = new THREE.Vector2();\n\n            // --- Create Static Geometry (Container) ---\n            const containerGeo = new THREE.BoxGeometry(containerDimensions.w, containerDimensions.h, containerDimensions.d);\n            const containerMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.15, depthWrite: false });\n            containerMesh = new THREE.Mesh(containerGeo, containerMat);\n            containerMesh.position.set(containerDimensions.w / 2, containerDimensions.h / 2, containerDimensions.d / 2);\n            scene.add(containerMesh);\n\n             const edges = new THREE.EdgesGeometry( containerGeo );\n             const lineMat = new THREE.LineBasicMaterial( { color: 0xffffff } );\n             containerWireframe = new THREE.LineSegments( edges, lineMat );\n             containerWireframe.position.copy(containerMesh.position);\n             scene.add( containerWireframe );\n\n            // --- Setup Group for Internal Boxes ---\n            internalBoxesGroup = new THREE.Group();\n            scene.add(internalBoxesGroup);\n\n            // --- Initial Box Generation ---\n            const initialBoxCount = parseInt(boxCountInput.value, 10) || 55; // Read default value\n            regenerateInternalBoxes(initialBoxCount); // Generate initial set\n\n            // --- Event Listeners Setup ---\n            window.addEventListener('resize', onWindowResize);\n            window.addEventListener('pointerdown', onPointerDown);\n            visibilityToggle.addEventListener('change', onVisibilityToggleChange);\n\n            // Listener for the Regenerate Button\n            regenerateButton.addEventListener('click', () => {\n                const n = parseInt(boxCountInput.value, 10);\n                // Basic validation\n                const minBoxes = parseInt(boxCountInput.min, 10) || 2;\n                const maxBoxes = parseInt(boxCountInput.max, 10) || 1000; // Set a reasonable upper limit\n                if (isNaN(n) || n < minBoxes || n > maxBoxes) {\n                    alert(`Please enter a number of boxes between ${minBoxes} and ${maxBoxes}.`);\n                    boxCountInput.focus(); // Focus the input field\n                    return;\n                }\n                regenerateInternalBoxes(n);\n            });\n\n            // Initialize UI states\n            resetInfoPanel();\n            visibilityToggle.checked = false;\n            visibilityToggle.disabled = true;\n        }\n\n        // --- Event Handlers ---\n        // (onWindowResize, onPointerDown, onVisibilityToggleChange remain the same)\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        function onPointerDown(event) {\n            const rect = renderer.domElement.getBoundingClientRect();\n            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n            raycaster.setFromCamera(mouse, camera);\n            // IMPORTANT: Only intersect with the current clickableBoxes array\n            const intersects = raycaster.intersectObjects(clickableBoxes);\n\n            if (intersects.length > 0) {\n                const clickedObject = intersects[0].object;\n                 if (clickedObject !== selectedBoxMesh) {\n                     selectBox(clickedObject);\n                 } else {\n                     deselectBox();\n                 }\n            } else {\n                 if (selectedBoxMesh) {\n                     deselectBox();\n                 }\n            }\n        }\n\n        function onVisibilityToggleChange() {\n            if (selectedBoxMesh) {\n                const isVisible = !visibilityToggle.checked;\n                selectedBoxMesh.visible = isVisible;\n                 if (selectedBoxMesh.children.length > 0 && selectedBoxMesh.children[0] instanceof THREE.LineSegments) {\n                    selectedBoxMesh.children[0].visible = isVisible;\n                 }\n            }\n        }\n\n        // --- Interaction Logic ---\n        // (deselectBox, selectBox, resetInfoPanel remain the same)\n         function deselectBox() {\n             if (selectedBoxMesh) {\n                 // Restore original material if it was cloned/changed\n                 if (selectedBoxMesh.userData.originalMaterial) {\n                     selectedBoxMesh.material = selectedBoxMesh.userData.originalMaterial;\n                 }\n                  // Restore outline appearance\n                  if (selectedBoxMesh.userData.outlineMaterial) {\n                     selectedBoxMesh.userData.outlineMaterial.color.set(0xffffff);\n                     selectedBoxMesh.userData.outlineMaterial.opacity = 0.3;\n                  }\n                 selectedBoxMesh = null;\n                 resetInfoPanel();\n                 visibilityToggle.checked = false;\n                 visibilityToggle.disabled = true;\n             }\n         }\n\n         function selectBox(boxMesh) {\n             deselectBox();\n             selectedBoxMesh = boxMesh;\n\n              // Apply highlight effect (clone material before changing)\n              if (selectedBoxMesh.userData.originalMaterial) {\n                  selectedBoxMesh.material = selectedBoxMesh.userData.originalMaterial.clone();\n                  selectedBoxMesh.material.color.setHex(highlightColor);\n              } else { // Fallback if original wasn't stored properly\n                   selectedBoxMesh.material.color.setHex(highlightColor);\n              }\n              // Make outline more prominent\n               if (selectedBoxMesh.userData.outlineMaterial) {\n                  selectedBoxMesh.userData.outlineMaterial.color.setHex(highlightColor);\n                  selectedBoxMesh.userData.outlineMaterial.opacity = 0.9;\n               }\n\n             // Update Info Panel\n             infoPanel.title.textContent = `Selected Box Info`;\n             infoPanel.defaultText.style.display = 'none';\n             infoPanel.id.textContent = `ID: ${selectedBoxMesh.userData.id}`;\n             const dims = selectedBoxMesh.userData.dimensions;\n             infoPanel.dims.textContent = `Dimensions: ${dims.w} x ${dims.h} x ${dims.d}`;\n             infoPanel.vol.textContent = `Volume: ${selectedBoxMesh.userData.volume.toLocaleString()}`;\n\n             // Update and enable visibility toggle\n             visibilityToggle.checked = !selectedBoxMesh.visible;\n             visibilityToggle.disabled = false;\n         }\n\n         function resetInfoPanel() {\n             infoPanel.title.textContent = `Box Information`;\n             infoPanel.defaultText.style.display = 'block';\n             infoPanel.id.textContent = `ID: -`;\n             infoPanel.dims.textContent = `Dimensions: -`;\n             infoPanel.vol.textContent = `Volume: -`;\n         }\n\n        // --- Animation Loop ---\n        // (animate function remains the same)\n        function animate() {\n            requestAnimationFrame(animate);\n            controls.update();\n            renderer.render(scene, camera);\n        }\n\n        // --- Start Application ---\n        init();\n        animate();\n\n    </script>\n</body>\n</html>",
  "id": "container-divide-n-box-gemini-pro-2-5",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.912Z",
    "model": "gemini-pro-2.5",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, architecture."
  }
}
