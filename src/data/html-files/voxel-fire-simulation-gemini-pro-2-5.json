{
  "title": "Voxel Fire Simulation",
  "htmlContent": "<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <title>Voxel Fire Simulation</title>\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n            display: flex;\r\n            justify-content: center;\r\n            align-items: center;\r\n            height: 100vh;\r\n            background-color: #222;\r\n        }\r\n\r\n        #fireCanvas {\r\n            width: 100%;\r\n            height: 100%;\r\n            display: block;\r\n        }\r\n\r\n        #controls {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            display: flex;\r\n            gap: 10px;\r\n            z-index: 1; /* Ensure controls are above the canvas */\r\n        }\r\n\r\n        .button {\r\n            padding: 10px 15px;\r\n            border: none;\r\n            border-radius: 5px;\r\n            background-color: #4CAF50;\r\n            color: white;\r\n            font-size: 16px;\r\n            cursor: pointer;\r\n            box-shadow: 0 2px 5px rgba(0,0,0,0.2);\r\n            transition: background-color 0.3s ease, box-shadow 0.3s ease;\r\n        }\r\n\r\n        .button:hover {\r\n            background-color: #367c39;\r\n            box-shadow: 0 3px 7px rgba(0,0,0,0.3);\r\n        }\r\n\r\n        .button:active {\r\n            background-color: #2b5e2e;\r\n            box-shadow: 0 1px 2px rgba(0,0,0,0.2);\r\n        }\r\n\r\n        #paramControls {\r\n            position: absolute;\r\n            top: 10px;\r\n            right: 10px;\r\n            background-color: rgba(255, 255, 255, 0.7);\r\n            padding: 10px;\r\n            border-radius: 5px;\r\n            z-index: 1;\r\n            display: flex;\r\n            flex-direction: column;\r\n            gap: 5px;\r\n        }\r\n\r\n        #paramControls label {\r\n            color: #333;\r\n            font-size: 14px;\r\n        }\r\n\r\n        #paramControls input[type=\"range\"] {\r\n            width: 150px;\r\n        }\r\n\r\n        #message-box {\r\n            position: absolute;\r\n            bottom: 20px;\r\n            left: 50%;\r\n            transform: translateX(-50%);\r\n            background-color: rgba(0, 0, 0, 0.7);\r\n            color: white;\r\n            padding: 10px 20px;\r\n            border-radius: 5px;\r\n            z-index: 10;\r\n            font-size: 16px;\r\n            opacity: 0;\r\n            transition: opacity 0.3s ease-in-out;\r\n        }\r\n\r\n        .show-message {\r\n            opacity: 1;\r\n        }\r\n\r\n    </style>\r\n</head>\r\n<body>\r\n    <canvas id=\"fireCanvas\"></canvas>\r\n    <div id=\"controls\">\r\n        <button id=\"resetButton\" class=\"button\">Reset Fire</button>\r\n        <button id=\"startButton\" class=\"button\">Start Fire</button>\r\n    </div>\r\n    <div id=\"paramControls\">\r\n        <label for=\"fireSpeed\">Fire Speed:</label>\r\n        <input type=\"range\" id=\"fireSpeed\" min=\"0\" max=\"100\" value=\"50\">\r\n        <label for=\"spreadProbability\">Spread Probability:</label>\r\n        <input type=\"range\" id=\"spreadProbability\" min=\"0\" max=\"100\" value=\"50\">\r\n        <label for=\"smokeDensity\">Smoke Density:</label>\r\n        <input type=\"range\" id=\"smokeDensity\" min=\"0\" max=\"100\" value=\"50\">\r\n    </div>\r\n    <div id=\"message-box\"></div>\r\n\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.139.0/build/three.min.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.139.0/examples/js/controls/OrbitControls.js\"></script>\r\n\r\n    <script>\r\n        // --- DOM Elements ---\r\n        const canvas = document.getElementById('fireCanvas');\r\n        const resetButton = document.getElementById('resetButton');\r\n        const startButton = document.getElementById('startButton');\r\n        const fireSpeedSlider = document.getElementById('fireSpeed');\r\n        const spreadProbabilitySlider = document.getElementById('spreadProbability');\r\n        const smokeDensitySlider = document.getElementById('smokeDensity');\r\n        const messageBox = document.getElementById('message-box');\r\n\r\n        // --- Three.js Setup ---\r\n        const renderer = new THREE.WebGLRenderer({ canvas: canvas });\r\n        const scene = new THREE.Scene();\r\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n        const controls = new THREE.OrbitControls(camera, renderer.domElement);\r\n\r\n        // --- Simulation Constants and Variables ---\r\n        const gridSize = 20;\r\n        const voxelSize = 1;\r\n        const grid = [];\r\n        const fireSources = []; // Array to store initial fire positions\r\n        let voxels = []; // Array to store all voxel meshes for efficient raycasting\r\n        let burningCount = 0; // Keep track of burning voxels for performance\r\n        let frameCounter = 0; // Counter to regulate non-critical effects\r\n\r\n        // --- Materials ---\r\n        const flammableMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown (wood)\r\n        const burningMaterials = [ // Array for flickering effect\r\n            new THREE.MeshLambertMaterial({ color: 0xff4500 }), // Orange Red\r\n            new THREE.MeshLambertMaterial({ color: 0xff6347 }), // Tomato\r\n            new THREE.MeshLambertMaterial({ color: 0xffa500 })  // Orange\r\n        ];\r\n        const burntMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 }); // Very Dark Grey\r\n        // const waterMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5 }); // Blue, semi-transparent (unused currently)\r\n\r\n        // --- Lighting ---\r\n        const ambientLight = new THREE.AmbientLight(0x606060); // Slightly brighter ambient light\r\n        scene.add(ambientLight);\r\n\r\n        const pointLight = new THREE.PointLight(0xffffff, 1, gridSize * voxelSize * 3); // Adjusted intensity and distance\r\n        pointLight.position.set(gridSize * voxelSize / 2, gridSize * voxelSize * 1.5, gridSize * voxelSize * 1.5); // Adjusted position\r\n        scene.add(pointLight);\r\n\r\n        // --- Particle System (for smoke) ---\r\n        let smokeParticles;\r\n        let smokeGeometry;\r\n        let smokeMaterial;\r\n        const maxSmokeParticles = 5000; // Increased particle limit\r\n        let numSmokeParticles = 0;\r\n        // **FIX:** Changed from const to let to allow reassignment in initSmoke\r\n        let smokePositions = [];\r\n        let smokeVelocities = [];\r\n        let smokeLifetimes = [];\r\n        let smokeSizes = [];\r\n        let smokeOpacities = [];\r\n\r\n        /**\r\n         * Initializes the smoke particle system.\r\n         * Creates the BufferGeometry and PointsMaterial.\r\n         */\r\n        function initSmoke() {\r\n            // If smoke particles already exist, remove them from the scene and dispose of geometry/material\r\n            if (smokeParticles) {\r\n                scene.remove(smokeParticles);\r\n                smokeGeometry.dispose();\r\n                smokeMaterial.dispose();\r\n            }\r\n\r\n            smokeGeometry = new THREE.BufferGeometry();\r\n            // Assign new Float32Arrays to the 'let' variables\r\n            smokePositions = new Float32Array(maxSmokeParticles * 3);\r\n            smokeVelocities = new Float32Array(maxSmokeParticles * 3);\r\n            smokeLifetimes = new Float32Array(maxSmokeParticles);\r\n            smokeSizes = new Float32Array(maxSmokeParticles);\r\n            smokeOpacities = new Float32Array(maxSmokeParticles);\r\n\r\n            // Set attributes for the geometry\r\n            smokeGeometry.setAttribute('position', new THREE.BufferAttribute(smokePositions, 3));\r\n            smokeGeometry.setAttribute('velocity', new THREE.BufferAttribute(smokeVelocities, 3)); // Custom attribute for velocity\r\n            smokeGeometry.setAttribute('lifetime', new THREE.BufferAttribute(smokeLifetimes, 1)); // Custom attribute for lifetime\r\n            smokeGeometry.setAttribute('size', new THREE.BufferAttribute(smokeSizes, 1));\r\n            smokeGeometry.setAttribute('opacity', new THREE.BufferAttribute(smokeOpacities, 1));\r\n\r\n            // Define the material for the smoke particles\r\n            smokeMaterial = new THREE.PointsMaterial({\r\n                color: 0xaaaaaa, // Grey smoke\r\n                size: 0.1, // Initial size\r\n                transparent: true,\r\n                opacity: 0.6, // Initial opacity\r\n                sizeAttenuation: true, // Particles shrink with distance\r\n                depthWrite: false // Prevents particles from obscuring objects behind them incorrectly\r\n            });\r\n\r\n            // Create the Points object and add it to the scene\r\n            smokeParticles = new THREE.Points(smokeGeometry, smokeMaterial);\r\n            scene.add(smokeParticles);\r\n            numSmokeParticles = 0; // Reset particle count\r\n        }\r\n\r\n        /**\r\n         * Adds a single smoke particle to the system at a given position.\r\n         * @param {THREE.Vector3} position - The starting position of the particle.\r\n         */\r\n        function addSmokeParticle(position) {\r\n            if (numSmokeParticles >= maxSmokeParticles) return; // Don't add if max capacity reached\r\n\r\n            const particleIndex = numSmokeParticles;\r\n\r\n            // Position: Start near the voxel center with slight random offset\r\n            smokePositions[particleIndex * 3] = position.x + (Math.random() - 0.5) * 0.3;\r\n            smokePositions[particleIndex * 3 + 1] = position.y + (Math.random() - 0.5) * 0.3;\r\n            smokePositions[particleIndex * 3 + 2] = position.z + (Math.random() - 0.5) * 0.3;\r\n\r\n            // Velocity: Primarily upwards, with slight random horizontal drift\r\n            const baseVelocityY = 0.015;\r\n            const horizontalSpread = 0.008;\r\n            smokeVelocities[particleIndex * 3] = (Math.random() - 0.5) * horizontalSpread;\r\n            smokeVelocities[particleIndex * 3 + 1] = Math.random() * 0.02 + baseVelocityY; // Random upward speed\r\n            smokeVelocities[particleIndex * 3 + 2] = (Math.random() - 0.5) * horizontalSpread;\r\n\r\n            // Lifetime: Random duration\r\n            smokeLifetimes[particleIndex] = Math.random() * 4 + 3; // Lifespan between 3 and 7 seconds\r\n\r\n            // Size: Random initial size\r\n            smokeSizes[particleIndex] = Math.random() * 0.15 + 0.05; // Size between 0.05 and 0.2\r\n\r\n            // Opacity: Start semi-transparent\r\n            smokeOpacities[particleIndex] = Math.random() * 0.3 + 0.4; // Opacity between 0.4 and 0.7\r\n\r\n            numSmokeParticles++; // Increment the count of active particles\r\n        }\r\n\r\n        /**\r\n         * Updates the state of all active smoke particles (position, lifetime, size, opacity).\r\n         * Removes expired particles efficiently.\r\n         */\r\n        function updateSmoke() {\r\n            if (numSmokeParticles === 0) return; // Skip if no particles\r\n\r\n            const positionAttribute = smokeGeometry.attributes.position;\r\n            const velocityAttribute = smokeGeometry.attributes.velocity;\r\n            const lifetimeAttribute = smokeGeometry.attributes.lifetime;\r\n            const sizeAttribute = smokeGeometry.attributes.size;\r\n            const opacityAttribute = smokeGeometry.attributes.opacity;\r\n\r\n            const positions = positionAttribute.array;\r\n            const velocities = velocityAttribute.array;\r\n            const lifetimes = lifetimeAttribute.array;\r\n            const sizes = sizeAttribute.array;\r\n            const opacities = opacityAttribute.array;\r\n\r\n            const timeDelta = 0.016; // Approximate time per frame (adjust if needed)\r\n\r\n            let particleIndex = 0;\r\n            while (particleIndex < numSmokeParticles) {\r\n                // Update position based on velocity and time delta\r\n                positions[particleIndex * 3] += velocities[particleIndex * 3] * timeDelta * 60; // Scale velocity by frame rate\r\n                positions[particleIndex * 3 + 1] += velocities[particleIndex * 3 + 1] * timeDelta * 60;\r\n                positions[particleIndex * 3 + 2] += velocities[particleIndex * 3 + 2] * timeDelta * 60;\r\n\r\n                // Decrease lifetime\r\n                lifetimes[particleIndex] -= timeDelta;\r\n\r\n                if (lifetimes[particleIndex] <= 0) {\r\n                    // Remove particle by swapping with the last active particle\r\n                    const lastParticleIndex = numSmokeParticles - 1;\r\n                    if (particleIndex < lastParticleIndex) {\r\n                        // Copy data from the last particle to the current index\r\n                        positions[particleIndex * 3] = positions[lastParticleIndex * 3];\r\n                        positions[particleIndex * 3 + 1] = positions[lastParticleIndex * 3 + 1];\r\n                        positions[particleIndex * 3 + 2] = positions[lastParticleIndex * 3 + 2];\r\n\r\n                        velocities[particleIndex * 3] = velocities[lastParticleIndex * 3];\r\n                        velocities[particleIndex * 3 + 1] = velocities[lastParticleIndex * 3 + 1];\r\n                        velocities[particleIndex * 3 + 2] = velocities[lastParticleIndex * 3 + 2];\r\n\r\n                        lifetimes[particleIndex] = lifetimes[lastParticleIndex];\r\n                        sizes[particleIndex] = sizes[lastParticleIndex];\r\n                        opacities[particleIndex] = opacities[lastParticleIndex];\r\n                    }\r\n                    numSmokeParticles--; // Decrease the count of active particles\r\n                    // Don't increment particleIndex, as the swapped particle needs processing\r\n                } else {\r\n                    // Update size and opacity for living particles\r\n                    const maxLifetime = 7; // Should match the max possible lifetime in addSmokeParticle\r\n                    const normalizedLifetime = Math.max(0, lifetimes[particleIndex] / maxLifetime); // 0 to 1\r\n\r\n                    sizes[particleIndex] = Math.max(0, sizes[particleIndex] + 0.001); // Slightly expand over time\r\n                    opacities[particleIndex] = Math.max(0, normalizedLifetime * 0.8); // Fade out as lifetime decreases\r\n\r\n                    particleIndex++; // Move to the next particle\r\n                }\r\n            }\r\n\r\n            // Update the geometry attributes\r\n            positionAttribute.needsUpdate = true;\r\n            // velocityAttribute.needsUpdate = true; // Velocity doesn't change after creation in this simple model\r\n            lifetimeAttribute.needsUpdate = true;\r\n            sizeAttribute.needsUpdate = true;\r\n            opacityAttribute.needsUpdate = true;\r\n\r\n            // Important: Update the draw range to only render active particles\r\n            smokeGeometry.setDrawRange(0, numSmokeParticles);\r\n        }\r\n\r\n\r\n        // --- Voxel Grid Creation ---\r\n        /**\r\n         * Creates the 3D grid of voxels and initializes their properties.\r\n         */\r\n        function createVoxelGrid() {\r\n            voxels = []; // Clear previous voxels if any\r\n            for (let x = 0; x < gridSize; x++) {\r\n                grid[x] = [];\r\n                for (let y = 0; y < gridSize; y++) {\r\n                    grid[x][y] = [];\r\n                    for (let z = 0; z < gridSize; z++) {\r\n                        const voxelGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);\r\n                        const voxelMesh = new THREE.Mesh(voxelGeometry, flammableMaterial);\r\n                        voxelMesh.position.set(\r\n                            (x - gridSize / 2 + 0.5) * voxelSize, // Center the grid\r\n                            (y + 0.5) * voxelSize, // Start grid above y=0\r\n                            (z - gridSize / 2 + 0.5) * voxelSize // Center the grid\r\n                        );\r\n                        voxelMesh.castShadow = true;\r\n                        voxelMesh.receiveShadow = true;\r\n                        scene.add(voxelMesh);\r\n\r\n                        const voxelData = {\r\n                            mesh: voxelMesh,\r\n                            x: x, y: y, z: z, // Store grid coordinates\r\n                            isFlammable: true,\r\n                            isOnFire: false,\r\n                            fuel: Math.random() * 50 + 50, // Random fuel (50-100 frames)\r\n                            neighbors: [],\r\n                            // originalColor: flammableMaterial.color.clone(), // Not strictly needed if resetting material\r\n                        };\r\n                        grid[x][y][z] = voxelData;\r\n                        voxels.push(voxelMesh); // Store the mesh for efficient raycasting\r\n                    }\r\n                }\r\n            }\r\n\r\n            // --- Neighbor Assignment (after all voxels are created) ---\r\n            for (let x = 0; x < gridSize; x++) {\r\n                for (let y = 0; y < gridSize; y++) {\r\n                    for (let z = 0; z < gridSize; z++) {\r\n                        const voxelData = grid[x][y][z];\r\n                        // Get neighbors (6 directions), handling boundary conditions\r\n                        voxelData.neighbors.push(getNeighbor(x - 1, y, z));\r\n                        voxelData.neighbors.push(getNeighbor(x + 1, y, z));\r\n                        voxelData.neighbors.push(getNeighbor(x, y - 1, z));\r\n                        voxelData.neighbors.push(getNeighbor(x, y + 1, z));\r\n                        voxelData.neighbors.push(getNeighbor(x, y, z - 1));\r\n                        voxelData.neighbors.push(getNeighbor(x, y, z + 1));\r\n                        voxelData.neighbors = voxelData.neighbors.filter(n => n !== null); // Remove nulls for boundary voxels\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Retrieves a neighbor voxel data object from the grid, handling boundaries.\r\n         * @param {number} x - The x-coordinate of the potential neighbor.\r\n         * @param {number} y - The y-coordinate of the potential neighbor.\r\n         * @param {number} z - The z-coordinate of the potential neighbor.\r\n         * @returns {object|null} The neighbor voxel data object or null if out of bounds.\r\n         */\r\n        function getNeighbor(x, y, z) {\r\n            if (x >= 0 && x < gridSize && y >= 0 && y < gridSize && z >= 0 && z < gridSize) {\r\n                return grid[x][y][z];\r\n            }\r\n            return null; // Out of bounds\r\n        }\r\n\r\n\r\n        // --- Initialization ---\r\n        /**\r\n         * Initializes the entire simulation: grid, smoke, camera, controls.\r\n         */\r\n        function initialize() {\r\n            createVoxelGrid();\r\n            initSmoke(); // Initialize smoke system\r\n            // Set camera position further back and slightly elevated\r\n            camera.position.set(gridSize * voxelSize * 0.8, gridSize * voxelSize * 1.2, gridSize * voxelSize * 1.8);\r\n            // Target the center of the grid base\r\n            controls.target.set(0, gridSize * voxelSize / 3, 0);\r\n            controls.enableDamping = true; // Add smooth camera movement\r\n            controls.dampingFactor = 0.1;\r\n            controls.update();\r\n            resizeRendererToDisplaySize(renderer); // Initial resize\r\n        }\r\n\r\n        /**\r\n         * Resizes the renderer and updates the camera aspect ratio on window resize.\r\n         * @param {THREE.WebGLRenderer} renderer - The renderer instance.\r\n         * @returns {boolean} True if a resize occurred, false otherwise.\r\n         */\r\n        function resizeRendererToDisplaySize(renderer) {\r\n            const canvas = renderer.domElement;\r\n            const width = window.innerWidth;\r\n            const height = window.innerHeight;\r\n            const needResize = canvas.width !== width || canvas.height !== height;\r\n            if (needResize) {\r\n                renderer.setSize(width, height, false); // Use false to avoid setting style size\r\n                camera.aspect = width / height;\r\n                camera.updateProjectionMatrix();\r\n            }\r\n            return needResize;\r\n        }\r\n\r\n        /**\r\n         * Displays a temporary message in the message box.\r\n         * @param {string} text - The message to display.\r\n         * @param {number} [duration=3000] - How long to display the message (in milliseconds).\r\n         */\r\n        function showMessage(text, duration = 3000) {\r\n            messageBox.textContent = text;\r\n            messageBox.classList.add('show-message');\r\n            // Clear previous timeout if any\r\n            if (messageBox.timeoutId) {\r\n                clearTimeout(messageBox.timeoutId);\r\n            }\r\n            messageBox.timeoutId = setTimeout(() => {\r\n                messageBox.classList.remove('show-message');\r\n                messageBox.timeoutId = null;\r\n            }, duration);\r\n        }\r\n\r\n\r\n        // --- Raycasting for Interaction ---\r\n        const raycaster = new THREE.Raycaster();\r\n        const mouse = new THREE.Vector2();\r\n\r\n        /**\r\n         * Handles mouse click events to potentially start a fire on a voxel.\r\n         * @param {MouseEvent} event - The mouse click event.\r\n         */\r\n        function handleMouseClick(event) {\r\n            // Calculate mouse position in normalized device coordinates (-1 to +1)\r\n            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\r\n            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\r\n\r\n            // Update the picking ray with the camera and mouse position\r\n            raycaster.setFromCamera(mouse, camera);\r\n\r\n            // Calculate objects intersecting the picking ray\r\n            const intersects = raycaster.intersectObjects(voxels); // Use the stored voxel meshes\r\n\r\n            if (intersects.length > 0) {\r\n                const intersection = intersects[0];\r\n                const clickedMesh = intersection.object;\r\n                const gridVoxelData = findVoxelDataByMesh(clickedMesh); // Find the corresponding data object\r\n\r\n                if (gridVoxelData && gridVoxelData.isFlammable && !gridVoxelData.isOnFire) {\r\n                    startFire(gridVoxelData); // Ignite the clicked voxel\r\n                    showMessage(\"Fire started!\");\r\n                } else if (gridVoxelData && gridVoxelData.isOnFire) {\r\n                    // Optional: Click on burning voxel to extinguish?\r\n                    // extinguishVoxel(gridVoxelData);\r\n                    // showMessage(\"Fire extinguished!\");\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Finds the voxel data object in the grid corresponding to a given mesh.\r\n         * @param {THREE.Mesh} mesh - The mesh to search for.\r\n         * @returns {object|null} The voxel data object or null if not found.\r\n         */\r\n        function findVoxelDataByMesh(mesh) {\r\n            // This is inefficient for large grids. Consider storing a map from mesh.uuid to voxel data.\r\n            for (let x = 0; x < gridSize; x++) {\r\n                for (let y = 0; y < gridSize; y++) {\r\n                    for (let z = 0; z < gridSize; z++) {\r\n                        if (grid[x][y][z] && grid[x][y][z].mesh === mesh) {\r\n                            return grid[x][y][z];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return null; // Should not happen if mesh is from 'voxels' array\r\n        }\r\n\r\n        /**\r\n         * Sets a voxel's state to burning.\r\n         * @param {object} voxelData - The data object for the voxel to ignite.\r\n         */\r\n        function startFire(voxelData) {\r\n            if (!voxelData || !voxelData.isFlammable || voxelData.isOnFire) return; // Safety checks\r\n\r\n            voxelData.isOnFire = true;\r\n            voxelData.mesh.material = burningMaterials[Math.floor(Math.random() * burningMaterials.length)]; // Start with random burning color\r\n            voxelData.fuel = Math.random() * 50 + 50; // Reset fuel when ignited\r\n            burningCount++;\r\n\r\n            // Store the grid coordinates, not the mesh position, for reliable restart\r\n            const existingSource = fireSources.find(src => src.x === voxelData.x && src.y === voxelData.y && src.z === voxelData.z);\r\n            if (!existingSource) {\r\n                fireSources.push({ x: voxelData.x, y: voxelData.y, z: voxelData.z }); // Store grid coordinates\r\n            }\r\n        }\r\n\r\n\r\n        // --- Simulation Parameters ---\r\n        let fireSpeedFactor = 0.5; // Derived from slider (0 to 1)\r\n        let spreadProbability = 50; // Probability of fire spreading (0-100)\r\n        let smokeDensityFactor = 0.5; // Derived from slider (0 to 1)\r\n\r\n        // Update factors when sliders change\r\n        fireSpeedSlider.addEventListener('input', (event) => {\r\n            // Map slider value (0-100) to a factor (e.g., 0.1 to 2.0)\r\n            // Lower value = slower burn/spread\r\n            fireSpeedFactor = 0.1 + (parseInt(event.target.value) / 100) * 1.9;\r\n        });\r\n\r\n        spreadProbabilitySlider.addEventListener('input', (event) => {\r\n            spreadProbability = parseInt(event.target.value);\r\n        });\r\n\r\n        smokeDensitySlider.addEventListener('input', (event) => {\r\n            // Map slider value (0-100) to a factor (e.g., 0.0 to 1.0)\r\n            smokeDensityFactor = parseInt(event.target.value) / 100;\r\n        });\r\n\r\n\r\n       // --- Fire Spread Logic ---\r\n       /**\r\n        * Updates the fire simulation state for one frame.\r\n        * Handles fuel consumption, burning out, and spreading.\r\n        */\r\n       function updateFire() {\r\n            if (burningCount === 0) return; // Optimization: Don't update if no fire\r\n\r\n            let voxelsToIgnite = []; // Store neighbors to ignite in the next step\r\n\r\n            // Iterate through the grid - potentially optimize this later\r\n            for (let x = 0; x < gridSize; x++) {\r\n                for (let y = 0; y < gridSize; y++) {\r\n                    for (let z = 0; z < gridSize; z++) {\r\n                        const voxelData = grid[x][y][z];\r\n\r\n                        if (voxelData.isOnFire) {\r\n                            // --- Fuel Consumption ---\r\n                            voxelData.fuel -= (1 * fireSpeedFactor); // Consume fuel based on speed factor\r\n                            if (voxelData.fuel <= 0) {\r\n                                // --- Burn Out ---\r\n                                voxelData.isOnFire = false;\r\n                                voxelData.isFlammable = false; // Can't burn again\r\n                                voxelData.mesh.material = burntMaterial;\r\n                                burningCount--;\r\n                            } else {\r\n                                // --- Flicker Effect ---\r\n                                if (frameCounter % 10 === 0) { // Change color periodically\r\n                                     voxelData.mesh.material = burningMaterials[Math.floor(Math.random() * burningMaterials.length)];\r\n                                }\r\n\r\n                                // --- Spread Fire ---\r\n                                // Check neighbors for potential spread\r\n                                for (const neighborData of voxelData.neighbors) {\r\n                                    if (neighborData.isFlammable && !neighborData.isOnFire) {\r\n                                        // Probability check for spreading\r\n                                        const chance = spreadProbability * fireSpeedFactor; // Spread chance influenced by speed\r\n                                        if (Math.random() * 100 < chance) {\r\n                                            // Don't ignite immediately, add to list\r\n                                            if (!voxelsToIgnite.includes(neighborData)) {\r\n                                                voxelsToIgnite.push(neighborData);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // --- Ignite Queued Voxels ---\r\n            // Ignite neighbors after checking all current fires to prevent chain reactions within a single frame\r\n            voxelsToIgnite.forEach(neighborData => {\r\n                startFire(neighborData); // Ignite the neighbor\r\n            });\r\n        }\r\n\r\n\r\n        // --- Main Animation Loop ---\r\n        /**\r\n         * The main animation loop, called recursively via requestAnimationFrame.\r\n         */\r\n        function animate() {\r\n            requestAnimationFrame(animate); // Request the next frame\r\n\r\n            resizeRendererToDisplaySize(renderer); // Check for resize\r\n            controls.update(); // Update orbit controls (needed for damping)\r\n            updateFire(); // Update fire simulation logic\r\n\r\n            // --- Smoke Emission ---\r\n            // Emit smoke only from currently burning voxels, regulated by density and frame counter\r\n            if (frameCounter % 3 === 0) { // Emit smoke less frequently\r\n                for (let x = 0; x < gridSize; x++) {\r\n                    for (let y = 0; y < gridSize; y++) {\r\n                        for (let z = 0; z < gridSize; z++) {\r\n                            const voxelData = grid[x][y][z];\r\n                            // Emit smoke if burning and random chance based on density passes\r\n                            if (voxelData.isOnFire && Math.random() < smokeDensityFactor * 0.5) { // Adjust multiplier for desired density\r\n                                const pos = voxelData.mesh.position;\r\n                                addSmokeParticle(pos);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            updateSmoke(); // Update smoke particle positions and lifetimes\r\n\r\n            renderer.render(scene, camera); // Render the scene\r\n            frameCounter++; // Increment frame counter\r\n        }\r\n\r\n        // --- Event Listeners ---\r\n        window.addEventListener('resize', () => {\r\n            resizeRendererToDisplaySize(renderer);\r\n        });\r\n\r\n        canvas.addEventListener('click', handleMouseClick);\r\n\r\n        resetButton.addEventListener('click', () => {\r\n            // Reset the entire scene state\r\n            for (let x = 0; x < gridSize; x++) {\r\n                for (let y = 0; y < gridSize; y++) {\r\n                    for (let z = 0; z < gridSize; z++) {\r\n                        const voxelData = grid[x][y][z];\r\n                        voxelData.isOnFire = false;\r\n                        voxelData.isFlammable = true;\r\n                        voxelData.fuel = Math.random() * 50 + 50; // Reset fuel\r\n                        voxelData.mesh.material = flammableMaterial; // Reset material\r\n                        // Position is already set, no need to reset mesh position\r\n                    }\r\n                }\r\n            }\r\n            burningCount = 0; // Reset burning counter\r\n            fireSources.length = 0; // Clear stored fire start points\r\n            initSmoke(); // Re-initialize the smoke system (clears existing particles)\r\n            showMessage(\"Fire reset!\");\r\n        });\r\n\r\n        startButton.addEventListener('click', () => {\r\n            if (fireSources.length > 0) {\r\n                // Restart fire from the stored grid coordinates\r\n                fireSources.forEach(sourceCoords => {\r\n                    const voxelData = getNeighbor(sourceCoords.x, sourceCoords.y, sourceCoords.z);\r\n                    if (voxelData) { // Check if voxel still exists at that coordinate\r\n                         startFire(voxelData);\r\n                    }\r\n                });\r\n                showMessage(\"Restarting fire from initial points!\");\r\n            } else {\r\n                showMessage(\"Click on the grid to start a fire first.\");\r\n            }\r\n        });\r\n\r\n        // --- Start Everything ---\r\n        initialize(); // Set up the scene and grid\r\n        animate(); // Start the animation loop\r\n    </script>\r\n</body>\r\n</html>\r\n",
  "id": "voxel-fire-simulation-gemini-pro-2-5",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Canvas",
      "Animation",
      "Particles",
      "WebGL",
      "Shaders",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.977Z",
    "model": "gemini-pro-2.5",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, canvas, animation, particles, webgl, shaders, simulation, architecture."
  }
}
