{
  "title": "Futuristic Cityscape Simulation",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Futuristic Cityscape Simulation</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n            background-color: #000;\r\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n        }\r\n\r\n        canvas {\r\n            display: block;\r\n        }\r\n\r\n        #ui-panel {\r\n            position: absolute;\r\n            top: 10px;\r\n            right: 10px;\r\n            padding: 15px 20px;\r\n            background: rgba(0, 0, 0, 0.7);\r\n            border-radius: 8px;\r\n            color: #fff;\r\n            border: 1px solid #444;\r\n        }\r\n\r\n        #ui-panel h2 {\r\n            margin-top: 0;\r\n            margin-bottom: 15px;\r\n            font-size: 1.2em;\r\n            border-bottom: 1px solid #555;\r\n            padding-bottom: 5px;\r\n        }\r\n\r\n        .control-group {\r\n            margin-bottom: 10px;\r\n        }\r\n\r\n        .control-group label {\r\n            display: inline-block;\r\n            width: 120px;\r\n        }\r\n\r\n        .control-group input {\r\n            width: 80px;\r\n        }\r\n\r\n        #apply-button {\r\n            width: 100%;\r\n            padding: 8px;\r\n            background: #007bff;\r\n            color: white;\r\n            border: none;\r\n            border-radius: 4px;\r\n            cursor: pointer;\r\n            margin-top: 10px;\r\n            font-size: 1em;\r\n        }\r\n\r\n        #apply-button:hover {\r\n            background: #0056b3;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"ui-panel\">\r\n        <h2>City Controls</h2>\r\n        <div class=\"control-group\">\r\n            <label for=\"grid-size\">Grid Size:</label>\r\n            <input type=\"number\" id=\"grid-size\" value=\"10\" min=\"5\" max=\"20\">\r\n        </div>\r\n        <div class=\"control-group\">\r\n            <label for=\"city-size\">City Size:</label>\r\n            <input type=\"number\" id=\"city-size\" value=\"25\" min=\"10\" max=\"50\">\r\n        </div>\r\n        <div class=\"control-group\">\r\n            <label for=\"vehicle-count\">Vehicles:</label>\r\n            <input type=\"number\" id=\"vehicle-count\" value=\"50\" min=\"0\" max=\"200\">\r\n        </div>\r\n        <button id=\"apply-button\">Regenerate City</button>\r\n    </div>\r\n\r\n    <!-- Import map for three.js and its addons -->\r\n    <script type=\"importmap\">\r\n    {\r\n      \"imports\": {\r\n        \"three\": \"https://unpkg.com/three@0.165.0/build/three.module.js\",\r\n        \"three/addons/\": \"https://unpkg.com/three@0.165.0/examples/jsm/\"\r\n      }\r\n    }\r\n  </script>\r\n\r\n    <script type=\"module\">\r\n        import * as THREE from 'three';\r\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\n        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\r\n\r\n        let scene, camera, renderer, controls, clock;\r\n        let sun, ambientLight;\r\n        let cityObjects = [];\r\n        let vehicles = [];\r\n        let streetLights = [];\r\n\r\n        // --- CONFIG ---\r\n        const DAY_DURATION = 120; // seconds\r\n\r\n        init();\r\n        animate();\r\n\r\n        function init() {\r\n            // Scene\r\n            scene = new THREE.Scene();\r\n            scene.fog = new THREE.Fog(0x000000, 1, 1000);\r\n\r\n            // Camera\r\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);\r\n            camera.position.set(100, 150, 200);\r\n\r\n            // Renderer\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            renderer.setPixelRatio(window.devicePixelRatio);\r\n            renderer.shadowMap.enabled = true;\r\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n            document.body.appendChild(renderer.domElement);\r\n\r\n            // Controls\r\n            controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n            controls.maxPolarAngle = Math.PI / 2.1; // Don't go below ground\r\n            controls.target.set(0, 20, 0);\r\n\r\n            // Clock\r\n            clock = new THREE.Clock();\r\n\r\n            // Lighting\r\n            ambientLight = new THREE.AmbientLight(0xffffff, 0.2);\r\n            scene.add(ambientLight);\r\n\r\n            sun = new THREE.DirectionalLight(0xffffff, 2.5);\r\n            sun.castShadow = true;\r\n            sun.shadow.camera.left = -400;\r\n            sun.shadow.camera.right = 400;\r\n            sun.shadow.camera.top = 400;\r\n            sun.shadow.camera.bottom = -400;\r\n            sun.shadow.camera.near = 1;\r\n            sun.shadow.camera.far = 1500;\r\n            sun.shadow.mapSize.width = 2048;\r\n            sun.shadow.mapSize.height = 2048;\r\n            scene.add(sun);\r\n            scene.add(sun.target);\r\n\r\n            // Initial Scene Generation\r\n            generateScene();\r\n\r\n            // Event Listeners\r\n            window.addEventListener('resize', onWindowResize, false);\r\n            document.getElementById('apply-button').addEventListener('click', generateScene);\r\n        }\r\n\r\n        function clearScene() {\r\n            cityObjects.forEach(obj => {\r\n                if (obj.geometry) obj.geometry.dispose();\r\n                if (obj.material) {\r\n                    if (Array.isArray(obj.material)) {\r\n                        obj.material.forEach(m => m.dispose());\r\n                    } else {\r\n                        obj.material.dispose();\r\n                    }\r\n                }\r\n                scene.remove(obj);\r\n            });\r\n            cityObjects = [];\r\n\r\n            vehicles.forEach(v => scene.remove(v.mesh));\r\n            vehicles = [];\r\n\r\n            streetLights.forEach(light => scene.remove(light));\r\n            streetLights = [];\r\n        }\r\n\r\n        function generateScene() {\r\n            clearScene();\r\n\r\n            const gridSize = parseInt(document.getElementById('grid-size').value);\r\n            const citySize = parseInt(document.getElementById('city-size').value);\r\n            const vehicleCount = parseInt(document.getElementById('vehicle-count').value);\r\n            const worldSize = gridSize * citySize;\r\n\r\n            // Ground\r\n            const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 1 });\r\n            const groundGeo = new THREE.PlaneGeometry(worldSize, worldSize);\r\n            const ground = new THREE.Mesh(groundGeo, groundMat);\r\n            ground.rotation.x = -Math.PI / 2;\r\n            ground.receiveShadow = true;\r\n            scene.add(ground);\r\n            cityObjects.push(ground);\r\n\r\n            generateCity(gridSize, citySize);\r\n            generateVehicles(vehicleCount, worldSize);\r\n        }\r\n\r\n        function generateCity(gridSize, citySize) {\r\n            const noise = new ImprovedNoise();\r\n            const buildingMaterials = [\r\n                new THREE.MeshStandardMaterial({ color: 0x505060, roughness: 0.8, metalness: 0.2 }),\r\n                new THREE.MeshStandardMaterial({ color: 0x303040, roughness: 0.7, metalness: 0.3 }),\r\n                new THREE.MeshStandardMaterial({ color: 0x707080, roughness: 0.6, metalness: 0.1 }),\r\n            ];\r\n            const windowMaterial = new THREE.MeshStandardMaterial({\r\n                color: 0x000000,\r\n                emissive: 0xFFFF00,\r\n                emissiveIntensity: 0\r\n            });\r\n\r\n            const halfWorldSize = (gridSize * citySize) / 2;\r\n\r\n            for (let i = 0; i < citySize; i++) {\r\n                for (let j = 0; j < citySize; j++) {\r\n                    const x = i * gridSize - halfWorldSize;\r\n                    const z = j * gridSize - halfWorldSize;\r\n                    const n = noise.noise(i / 20, j / 20, 0);\r\n\r\n                    if (n > 0.6) { // Water/Beach\r\n                        const waterMat = new THREE.MeshStandardMaterial({ color: 0x0055aa, roughness: 0.1, metalness: 0.5 });\r\n                        const waterGeo = new THREE.BoxGeometry(gridSize * 0.95, 1, gridSize * 0.95);\r\n                        const water = new THREE.Mesh(waterGeo, waterMat);\r\n                        water.position.set(x, -0.5, z);\r\n                        scene.add(water);\r\n                        cityObjects.push(water);\r\n                    } else if (n > 0.5) { // Park\r\n                        const parkMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });\r\n                        const parkGeo = new THREE.BoxGeometry(gridSize * 0.95, 1, gridSize * 0.95);\r\n                        const park = new THREE.Mesh(parkGeo, parkMat);\r\n                        park.position.set(x, -0.5, z);\r\n                        park.receiveShadow = true;\r\n                        scene.add(park);\r\n                        cityObjects.push(park);\r\n                    } else if (Math.random() > 0.2) { // Building\r\n                        const height = (5 + Math.pow(Math.random(), 2) * 15) * gridSize;\r\n                        const width = gridSize * (0.6 + Math.random() * 0.3);\r\n                        const depth = gridSize * (0.6 + Math.random() * 0.3);\r\n\r\n                        const buildingGeo = new THREE.BoxGeometry(width, height, depth);\r\n                        const material = buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)];\r\n                        const building = new THREE.Mesh(buildingGeo, material);\r\n\r\n                        building.position.set(x, height / 2, z);\r\n                        building.castShadow = true;\r\n                        building.receiveShadow = true;\r\n                        scene.add(building);\r\n                        cityObjects.push(building);\r\n\r\n                        // Add emissive windows for night effect\r\n                        const windowGeo = new THREE.PlaneGeometry(width * 1.01, height * 1.01);\r\n                        const windows1 = new THREE.Mesh(windowGeo, windowMaterial);\r\n                        windows1.position.set(x, height / 2, z + depth / 2 * 1.01);\r\n                        scene.add(windows1);\r\n                        cityObjects.push(windows1);\r\n\r\n                        const windows2 = new THREE.Mesh(windowGeo, windowMaterial);\r\n                        windows2.rotation.y = Math.PI;\r\n                        windows2.position.set(x, height / 2, z - depth / 2 * 1.01);\r\n                        scene.add(windows2);\r\n                        cityObjects.push(windows2);\r\n\r\n                        // Streetlights at intersections\r\n                        if (i % 4 === 0 && j % 4 === 0) {\r\n                            const light = new THREE.PointLight(0xffaa00, 0, 100, 2); // Initially off\r\n                            light.position.set(x + gridSize / 2, 10, z + gridSize / 2);\r\n                            scene.add(light);\r\n                            streetLights.push(light);\r\n                            cityObjects.push(light);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function generateVehicles(count, worldSize) {\r\n            const vehicleGeo = new THREE.CapsuleGeometry(1, 4, 4, 8);\r\n            const vehicleMat = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.8, roughness: 0.2 });\r\n\r\n            for (let i = 0; i < count; i++) {\r\n                const mesh = new THREE.Mesh(vehicleGeo, vehicleMat);\r\n\r\n                // Headlight\r\n                const headLight = new THREE.SpotLight(0xffffff, 20, 150, Math.PI / 8, 0.5, 2);\r\n                headLight.position.set(0, 0, 2);\r\n                mesh.add(headLight);\r\n                mesh.add(headLight.target);\r\n                headLight.target.position.set(0, 0, 10);\r\n\r\n                const pathPoints = [];\r\n                const startPoint = new THREE.Vector3(\r\n                    (Math.random() - 0.5) * worldSize,\r\n                    Math.random() * 200 + 50,\r\n                    (Math.random() - 0.5) * worldSize\r\n                );\r\n                pathPoints.push(startPoint);\r\n\r\n                for (let j = 0; j < 5; j++) {\r\n                    pathPoints.push(\r\n                        new THREE.Vector3(\r\n                            (Math.random() - 0.5) * worldSize,\r\n                            Math.random() * 200 + 50,\r\n                            (Math.random() - 0.5) * worldSize\r\n                        )\r\n                    );\r\n                }\r\n                pathPoints.push(startPoint); // Loop back\r\n\r\n                const curve = new THREE.CatmullRomCurve3(pathPoints);\r\n                const speed = Math.random() * 0.05 + 0.02;\r\n                const offset = Math.random();\r\n\r\n                vehicles.push({ mesh, curve, speed, offset, headLight });\r\n                scene.add(mesh);\r\n            }\r\n        }\r\n\r\n        function updateDayNightCycle(time) {\r\n            const cycle = (time % DAY_DURATION) / DAY_DURATION; // 0 to 1\r\n            const sunAngle = cycle * Math.PI * 2;\r\n\r\n            // Sun position\r\n            sun.position.set(\r\n                Math.cos(sunAngle) * 500,\r\n                Math.sin(sunAngle) * 500,\r\n                Math.cos(sunAngle) * 200 - 200 // slight offset for more interesting shadows\r\n            );\r\n            sun.target.position.set(0, 0, 0);\r\n\r\n            // Day/Night determination\r\n            const isDay = sun.position.y > 0;\r\n            const isNight = sun.position.y < -50;\r\n            const transitionFactor = Math.smoothstep(sun.position.y, -50, 50); // 1 for day, 0 for night\r\n\r\n            // Sun color and intensity\r\n            const sunHighColor = new THREE.Color(0xffffff);\r\n            const sunLowColor = new THREE.Color(0xff8c00); // orange\r\n            sun.color.lerpColors(sunLowColor, sunHighColor, Math.max(0, sun.position.y / 500));\r\n            sun.intensity = transitionFactor * 2.5 + 0.1;\r\n\r\n            // Ambient light\r\n            ambientLight.intensity = transitionFactor * 0.4 + 0.05;\r\n\r\n            // Sky color (background and fog)\r\n            const daySky = new THREE.Color(0x87ceeb);\r\n            const nightSky = new THREE.Color(0x00001a);\r\n            const duskSky = new THREE.Color(0xff4500);\r\n\r\n            let currentSky;\r\n            if (sun.position.y > 50) currentSky = daySky;\r\n            else if (sun.position.y > -50) currentSky = duskSky;\r\n            else currentSky = nightSky;\r\n\r\n            let targetSky = isDay ? (sun.position.y < 50 ? duskSky : daySky) : nightSky;\r\n            let lerpFactor = isDay ? (1 - Math.abs(sun.position.y - 50) / 50) : (1 - Math.abs(sun.position.y + 50) / 50);\r\n            lerpFactor = Math.min(1, Math.max(0, lerpFactor));\r\n\r\n            const finalSky = new THREE.Color().lerpColors(currentSky, targetSky, lerpFactor);\r\n            scene.background = finalSky;\r\n            scene.fog.color.copy(finalSky);\r\n\r\n            // Streetlights and window lights\r\n            const lightIntensity = isNight ? 100 : 0;\r\n            const emissiveIntensity = isNight ? 1 : 0;\r\n\r\n            streetLights.forEach(light => light.intensity = lightIntensity);\r\n\r\n            cityObjects.forEach(obj => {\r\n                if (obj.material && obj.material.emissive) {\r\n                    obj.material.emissiveIntensity = emissiveIntensity;\r\n                }\r\n            });\r\n\r\n            // Vehicle headlights\r\n            vehicles.forEach(v => v.headLight.visible = isNight);\r\n        }\r\n\r\n        function updateVehicles(time) {\r\n            vehicles.forEach(v => {\r\n                const t = ((time * v.speed) + v.offset) % 1;\r\n                v.curve.getPointAt(t, v.mesh.position);\r\n\r\n                // Make vehicle look ahead\r\n                const tangent = v.curve.getTangentAt(t).normalize();\r\n                const lookAtPosition = new THREE.Vector3().copy(v.mesh.position).add(tangent);\r\n                v.mesh.lookAt(lookAtPosition);\r\n            });\r\n        }\r\n\r\n        function onWindowResize() {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n            const time = clock.getElapsedTime();\r\n\r\n            controls.update();\r\n\r\n            updateDayNightCycle(time);\r\n            updateVehicles(time);\r\n\r\n            renderer.render(scene, camera);\r\n        }\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "city-gemini-pro-2-5-06-05",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Procedural Generation",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.989Z",
    "model": "gemini-pro-2.5-06-05",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, procedural generation, simulation, architecture."
  }
}
