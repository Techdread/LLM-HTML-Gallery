{
  "title": "Futuristic Cityscape Simulation",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Futuristic Cityscape Simulation</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n            background-color: #000;\r\n            color: #fff;\r\n            font-family: Arial, sans-serif;\r\n        }\r\n\r\n        canvas {\r\n            display: block;\r\n        }\r\n\r\n        #ui-controls {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            background: rgba(20, 20, 30, 0.85);\r\n            padding: 15px;\r\n            border-radius: 8px;\r\n            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);\r\n            border: 1px solid rgba(0, 255, 255, 0.3);\r\n        }\r\n\r\n        #ui-controls h3 {\r\n            margin-top: 0;\r\n            color: #00ffff;\r\n            text-align: center;\r\n            border-bottom: 1px solid #00ffff;\r\n            padding-bottom: 5px;\r\n        }\r\n\r\n        #ui-controls div {\r\n            margin-bottom: 10px;\r\n        }\r\n\r\n        #ui-controls label {\r\n            display: inline-block;\r\n            width: 150px;\r\n            color: #ccc;\r\n        }\r\n\r\n        #ui-controls input[type=\"number\"] {\r\n            width: 60px;\r\n            background-color: #111;\r\n            color: #0f0;\r\n            border: 1px solid #00ffff;\r\n            border-radius: 3px;\r\n            padding: 3px;\r\n        }\r\n\r\n        #ui-controls button {\r\n            display: block;\r\n            width: 100%;\r\n            padding: 8px;\r\n            background-color: #007bff;\r\n            color: white;\r\n            border: none;\r\n            border-radius: 5px;\r\n            cursor: pointer;\r\n            margin-top: 10px;\r\n        }\r\n\r\n        #ui-controls button:hover {\r\n            background-color: #0056b3;\r\n        }\r\n\r\n        #timeDisplay {\r\n            margin-top: 10px;\r\n            font-size: 0.9em;\r\n            color: #0f0;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"ui-controls\">\r\n        <h3>City Controls</h3>\r\n        <div>\r\n            <label for=\"gridSizeInput\">Grid Size (N x N):</label>\r\n            <input type=\"number\" id=\"gridSizeInput\" value=\"12\" min=\"5\" max=\"25\" step=\"1\">\r\n        </div>\r\n        <div>\r\n            <label for=\"cityScaleInput\">Max Building Height:</label>\r\n            <input type=\"number\" id=\"cityScaleInput\" value=\"30\" min=\"10\" max=\"60\" step=\"1\">\r\n        </div>\r\n        <div>\r\n            <label for=\"vehicleCountInput\">Vehicle Count:</label>\r\n            <input type=\"number\" id=\"vehicleCountInput\" value=\"25\" min=\"0\" max=\"100\" step=\"1\">\r\n        </div>\r\n        <button id=\"regenerateButton\">Regenerate City</button>\r\n        <div id=\"timeDisplay\">Time: 00:00</div>\r\n    </div>\r\n\r\n    <!-- Import map for three.js and its addons -->\r\n    <script type=\"importmap\">\r\n    {\r\n      \"imports\": {\r\n        \"three\": \"https://unpkg.com/three@0.165.0/build/three.module.js\",\r\n        \"three/addons/\": \"https://unpkg.com/three@0.165.0/examples/jsm/\"\r\n      }\r\n    }\r\n  </script>\r\n    <script type=\"module\">\r\n        import * as THREE from 'three';\r\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\n\r\n        let scene, camera, renderer, controls;\r\n        const clock = new THREE.Clock();\r\n\r\n        const config = {\r\n            gridSize: 12,\r\n            cityScale: 30, // Max additional building height\r\n            vehicleCount: 25,\r\n            cellSize: 8,\r\n            dayDuration: 240, // seconds for a full 24h cycle (4 minutes)\r\n            maxBuildingSegments: 4,\r\n            buildingBaseMinHeight: 3,\r\n            buildingSegmentMinHeight: 2,\r\n        };\r\n\r\n        let cityGroup = new THREE.Group();\r\n        let vehicleGroup = new THREE.Group();\r\n        let streetLightMeshes = []; // For emissive meshes\r\n        let streetLightSources = []; // For actual lights\r\n\r\n        let sunLight, ambientLight;\r\n        let timeOfDay = 0.25; // 0 (midnight) to 1 (next midnight), start at sunrise (6 AM)\r\n\r\n        const vehicles = [];\r\n        const vehiclePaths = [];\r\n\r\n        // Building materials\r\n        const buildingMaterials = [\r\n            new THREE.MeshStandardMaterial({ color: 0x606070, roughness: 0.7, metalness: 0.3 }),\r\n            new THREE.MeshStandardMaterial({ color: 0x707080, roughness: 0.6, metalness: 0.4 }),\r\n            new THREE.MeshStandardMaterial({ color: 0x505060, roughness: 0.8, metalness: 0.2 }),\r\n        ];\r\n        const windowMaterial = new THREE.MeshStandardMaterial({ emissive: 0x000000, emissiveIntensity: 1, color: 0x111122 }); // Emissive turns on at night\r\n\r\n        init();\r\n        animate();\r\n\r\n        function init() {\r\n            scene = new THREE.Scene();\r\n            scene.background = new THREE.Color(0x000000); // Initial background\r\n            scene.fog = new THREE.Fog(0x050515, 50, 400);\r\n\r\n            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);\r\n\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            renderer.shadowMap.enabled = true;\r\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows\r\n            document.body.appendChild(renderer.domElement);\r\n\r\n            controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n            controls.screenSpacePanning = false;\r\n            controls.minDistance = 20;\r\n            controls.maxDistance = 600;\r\n\r\n            setupLights();\r\n\r\n            // Initial city generation based on default config\r\n            document.getElementById('gridSizeInput').value = config.gridSize;\r\n            document.getElementById('cityScaleInput').value = config.cityScale;\r\n            document.getElementById('vehicleCountInput').value = config.vehicleCount;\r\n\r\n            regenerateWorld();\r\n\r\n            setupUI();\r\n\r\n            window.addEventListener('resize', onWindowResize, false);\r\n        }\r\n\r\n        function setupLights() {\r\n            ambientLight = new THREE.AmbientLight(0x404050, 0.5); // Soft ambient light\r\n            scene.add(ambientLight);\r\n\r\n            sunLight = new THREE.DirectionalLight(0xffffff, 1);\r\n            sunLight.castShadow = true;\r\n            sunLight.shadow.mapSize.width = 2048;\r\n            sunLight.shadow.mapSize.height = 2048;\r\n            sunLight.shadow.camera.near = 0.5;\r\n            sunLight.shadow.camera.far = 500; // Adjust based on city size\r\n            scene.add(sunLight);\r\n            scene.add(sunLight.target); // Target for directional light\r\n        }\r\n\r\n        function updateCameraAndControls() {\r\n            const cityDimension = config.gridSize * config.cellSize;\r\n            camera.position.set(cityDimension * 0.7, cityDimension * 0.5, cityDimension * 0.9);\r\n            controls.target.set(cityDimension * 0.2, 0, cityDimension * 0.2); // Look towards city center\r\n            controls.maxDistance = cityDimension * 2;\r\n            sunLight.shadow.camera.far = cityDimension * 2.5;\r\n            const shadowCamSize = cityDimension * 0.75;\r\n            sunLight.shadow.camera.left = -shadowCamSize;\r\n            sunLight.shadow.camera.right = shadowCamSize;\r\n            sunLight.shadow.camera.top = shadowCamSize;\r\n            sunLight.shadow.camera.bottom = -shadowCamSize;\r\n            sunLight.shadow.camera.updateProjectionMatrix();\r\n            scene.fog.near = cityDimension * 0.2;\r\n            scene.fog.far = cityDimension * 2;\r\n        }\r\n\r\n        function clearSceneGroup(group) {\r\n            while (group.children.length > 0) {\r\n                const child = group.children[0];\r\n                if (child.geometry) child.geometry.dispose();\r\n                if (child.material) {\r\n                    if (Array.isArray(child.material)) {\r\n                        child.material.forEach(m => m.dispose());\r\n                    } else {\r\n                        child.material.dispose();\r\n                    }\r\n                }\r\n                group.remove(child);\r\n            }\r\n        }\r\n\r\n        function cleanupCity() {\r\n            clearSceneGroup(cityGroup);\r\n            clearSceneGroup(vehicleGroup);\r\n\r\n            streetLightMeshes.forEach(mesh => {\r\n                if (mesh.geometry) mesh.geometry.dispose();\r\n                if (mesh.material) mesh.material.dispose();\r\n            });\r\n            streetLightMeshes = [];\r\n\r\n            streetLightSources.forEach(light => {\r\n                scene.remove(light); // If they were added to scene directly\r\n                light.dispose();\r\n            });\r\n            streetLightSources = [];\r\n\r\n            vehicles.length = 0;\r\n            vehiclePaths.length = 0;\r\n        }\r\n\r\n        function regenerateWorld() {\r\n            cleanupCity();\r\n\r\n            scene.remove(cityGroup);\r\n            cityGroup = new THREE.Group();\r\n            scene.add(cityGroup);\r\n\r\n            scene.remove(vehicleGroup);\r\n            vehicleGroup = new THREE.Group();\r\n            scene.add(vehicleGroup);\r\n\r\n            updateCameraAndControls();\r\n            createCity();\r\n            createVehiclePaths();\r\n            spawnVehicles();\r\n        }\r\n\r\n\r\n        function createCity() {\r\n            const groundSize = config.gridSize * config.cellSize;\r\n            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);\r\n            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x303030, roughness: 0.9 });\r\n            const ground = new THREE.Mesh(groundGeometry, groundMaterial);\r\n            ground.rotation.x = -Math.PI / 2;\r\n            ground.receiveShadow = true;\r\n            cityGroup.add(ground);\r\n\r\n            // Create water plane (optional, can be part of grid logic)\r\n            const waterSize = groundSize * 1.5; // Larger than ground\r\n            const waterGeometry = new THREE.PlaneGeometry(waterSize, waterSize);\r\n            const waterMaterial = new THREE.MeshStandardMaterial({\r\n                color: 0x003060,\r\n                transparent: true,\r\n                opacity: 0.7,\r\n                roughness: 0.2,\r\n                metalness: 0.1\r\n            });\r\n            const water = new THREE.Mesh(waterGeometry, waterMaterial);\r\n            water.rotation.x = -Math.PI / 2;\r\n            water.position.y = -0.5; // Slightly below ground\r\n            cityGroup.add(water);\r\n\r\n\r\n            for (let i = 0; i < config.gridSize; i++) {\r\n                for (let j = 0; j < config.gridSize; j++) {\r\n                    const x = (i - config.gridSize / 2 + 0.5) * config.cellSize;\r\n                    const z = (j - config.gridSize / 2 + 0.5) * config.cellSize;\r\n                    const rand = Math.random();\r\n\r\n                    if (rand < 0.05) { // Park\r\n                        createPark(x, z);\r\n                    } else if (rand < 0.1) { // Beach-like area (sandy color)\r\n                        createRecreationalArea(x, z, new THREE.Color(0xC2B280)); // Sandy color\r\n                    } else if (rand < 0.70) { // Building\r\n                        createBuilding(x, z);\r\n                    }\r\n                    // Else: empty space / road\r\n                }\r\n            }\r\n        }\r\n\r\n        function createPark(x, z) {\r\n            const parkSize = config.cellSize * 0.8;\r\n            const parkGeo = new THREE.PlaneGeometry(parkSize, parkSize);\r\n            const parkMat = new THREE.MeshStandardMaterial({ color: 0x33691E, roughness: 1 }); // Dark green\r\n            const parkMesh = new THREE.Mesh(parkGeo, parkMat);\r\n            parkMesh.rotation.x = -Math.PI / 2;\r\n            parkMesh.position.set(x, 0.01, z);\r\n            parkMesh.receiveShadow = true;\r\n            cityGroup.add(parkMesh);\r\n\r\n            // Add some simple \"trees\"\r\n            for (let k = 0; k < 3; k++) {\r\n                const treeRadius = config.cellSize * 0.05 + Math.random() * config.cellSize * 0.05;\r\n                const treeHeight = config.cellSize * 0.2 + Math.random() * config.cellSize * 0.2;\r\n\r\n                const trunkGeo = new THREE.CylinderGeometry(treeRadius * 0.3, treeRadius * 0.4, treeHeight, 8);\r\n                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4A3B31 });\r\n                const trunk = new THREE.Mesh(trunkGeo, trunkMat);\r\n                trunk.castShadow = true;\r\n                trunk.position.set(\r\n                    x + (Math.random() - 0.5) * parkSize * 0.7,\r\n                    treeHeight / 2,\r\n                    z + (Math.random() - 0.5) * parkSize * 0.7\r\n                );\r\n                cityGroup.add(trunk);\r\n\r\n                const foliageGeo = new THREE.SphereGeometry(treeRadius, 8, 6);\r\n                const foliageMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });\r\n                const foliage = new THREE.Mesh(foliageGeo, foliageMat);\r\n                foliage.castShadow = true;\r\n                foliage.position.set(trunk.position.x, treeHeight + treeRadius * 0.8, trunk.position.z);\r\n                cityGroup.add(foliage);\r\n            }\r\n        }\r\n\r\n        function createRecreationalArea(x, z, color) {\r\n            const areaSize = config.cellSize * 0.9;\r\n            const areaGeo = new THREE.PlaneGeometry(areaSize, areaSize);\r\n            const areaMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.9 });\r\n            const areaMesh = new THREE.Mesh(areaGeo, areaMat);\r\n            areaMesh.rotation.x = -Math.PI / 2;\r\n            areaMesh.position.set(x, 0.01, z);\r\n            areaMesh.receiveShadow = true;\r\n            cityGroup.add(areaMesh);\r\n        }\r\n\r\n\r\n        function createBuilding(x, z) {\r\n            const building = new THREE.Group();\r\n            let currentHeight = 0;\r\n            const numSegments = 1 + Math.floor(Math.random() * config.maxBuildingSegments);\r\n            let baseWidth = config.cellSize * (0.5 + Math.random() * 0.4);\r\n            let baseDepth = config.cellSize * (0.5 + Math.random() * 0.4);\r\n\r\n            for (let i = 0; i < numSegments; i++) {\r\n                const segmentHeight = config.buildingSegmentMinHeight + Math.random() * (config.cityScale / numSegments);\r\n                const segmentWidth = baseWidth * (1 - i * 0.15); // Tapering\r\n                const segmentDepth = baseDepth * (1 - i * 0.15);\r\n\r\n                if (segmentWidth < 1 || segmentDepth < 1) break;\r\n\r\n                const segmentGeo = new THREE.BoxGeometry(segmentWidth, segmentHeight, segmentDepth);\r\n                const material = buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)];\r\n                const segmentMesh = new THREE.Mesh(segmentGeo, material.clone()); // Clone material for potential window modification\r\n\r\n                segmentMesh.castShadow = true;\r\n                segmentMesh.receiveShadow = true;\r\n                segmentMesh.position.y = currentHeight + segmentHeight / 2;\r\n                currentHeight += segmentHeight;\r\n                building.add(segmentMesh);\r\n\r\n                // Add \"windows\" - simple emissive planes that light up at night\r\n                if (Math.random() < 0.7) { // 70% chance of windows on a segment\r\n                    const windowRows = Math.floor(segmentHeight / 1.5);\r\n                    const windowCols = Math.floor(segmentWidth / 1.5);\r\n                    const windowDepth = 0.1;\r\n                    const windowPlaneGeo = new THREE.PlaneGeometry(0.8, 0.8); // Small window\r\n\r\n                    for (let face = 0; face < 4; face++) { // 4 sides\r\n                        for (let r = 0; r < windowRows; r++) {\r\n                            for (let c = 0; c < windowCols; c++) {\r\n                                if (Math.random() < 0.5) continue; // Sparsely populate windows\r\n                                const winMesh = new THREE.Mesh(windowPlaneGeo, windowMaterial); // Shared material, its emissive will be changed\r\n\r\n                                const yPos = (r - windowRows / 2 + 0.5) * 1.5;\r\n                                const xPos = (c - windowCols / 2 + 0.5) * 1.5;\r\n\r\n                                if (face === 0) winMesh.position.set(xPos, yPos, segmentDepth / 2 + windowDepth); // Front\r\n                                if (face === 1) { winMesh.position.set(xPos, yPos, -segmentDepth / 2 - windowDepth); winMesh.rotation.y = Math.PI; } // Back\r\n                                if (face === 2) { winMesh.position.set(segmentWidth / 2 + windowDepth, yPos, xPos); winMesh.rotation.y = Math.PI / 2; } // Right\r\n                                if (face === 3) { winMesh.position.set(-segmentWidth / 2 - windowDepth, yPos, xPos); winMesh.rotation.y = -Math.PI / 2; } // Left\r\n\r\n                                segmentMesh.add(winMesh); // Add to segment so positions are relative\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            building.position.set(x, 0, z); // Base of the building is on the ground\r\n            cityGroup.add(building);\r\n\r\n            // Add streetlight if building is not too tall\r\n            if (currentHeight < config.cityScale * 0.4 && Math.random() < 0.3) {\r\n                createStreetLight(x, z, currentHeight + 2);\r\n            }\r\n        }\r\n\r\n        function createStreetLight(x, z, height) {\r\n            const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, height, 8);\r\n            const poleMat = new THREE.MeshStandardMaterial({ color: 0x444444 });\r\n            const pole = new THREE.Mesh(poleGeo, poleMat);\r\n            pole.position.set(x, height / 2, z);\r\n            pole.castShadow = true;\r\n            cityGroup.add(pole);\r\n\r\n            const lightBulbGeo = new THREE.SphereGeometry(0.3, 8, 8);\r\n            const lightBulbMat = new THREE.MeshStandardMaterial({ emissive: 0xffff00, emissiveIntensity: 0, color: 0xffff00 }); // Emissive off initially\r\n            const lightBulbMesh = new THREE.Mesh(lightBulbGeo, lightBulbMat);\r\n            lightBulbMesh.position.set(x, height + 0.3, z);\r\n            cityGroup.add(lightBulbMesh);\r\n            streetLightMeshes.push(lightBulbMesh);\r\n\r\n            const pointLight = new THREE.PointLight(0xffffaa, 0, 20, 1); // Intensity 0 initially, decay 1\r\n            pointLight.position.set(x, height + 0.5, z);\r\n            pointLight.castShadow = false; // Performance: streetlights don't cast shadows\r\n            cityGroup.add(pointLight);\r\n            streetLightSources.push(pointLight);\r\n        }\r\n\r\n\r\n        function createVehicleModel() {\r\n            const group = new THREE.Group();\r\n            const bodyMat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, metalness: 0.6, roughness: 0.4 });\r\n            const bodyGeo = new THREE.BoxGeometry(2.5, 0.6, 1.2);\r\n            const body = new THREE.Mesh(bodyGeo, bodyMat);\r\n            body.castShadow = true;\r\n            group.add(body);\r\n\r\n            const cockpitGeo = new THREE.BoxGeometry(0.8, 0.4, 0.7);\r\n            const cockpitMat = new THREE.MeshStandardMaterial({ color: 0x3333dd, transparent: true, opacity: 0.6 });\r\n            const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);\r\n            cockpit.position.set(0.5, 0.3, 0);\r\n            body.add(cockpit);\r\n\r\n            // Headlights\r\n            const headlightMat = new THREE.MeshStandardMaterial({ emissive: 0xffffff, color: 0xffffff, emissiveIntensity: 0 });\r\n            const headlightGeo = new THREE.SphereGeometry(0.15, 8, 8);\r\n            const headlightL = new THREE.Mesh(headlightGeo, headlightMat);\r\n            headlightL.position.set(1.25, 0, 0.4);\r\n            body.add(headlightL);\r\n            const headlightR = new THREE.Mesh(headlightGeo, headlightMat);\r\n            headlightR.position.set(1.25, 0, -0.4);\r\n            body.add(headlightR);\r\n            group.userData.headlights = [headlightL, headlightR];\r\n\r\n\r\n            // Taillights\r\n            const taillightMat = new THREE.MeshStandardMaterial({ emissive: 0xff0000, color: 0xff0000, emissiveIntensity: 0 });\r\n            const taillightGeo = new THREE.BoxGeometry(0.1, 0.2, 0.4);\r\n            const taillightL = new THREE.Mesh(taillightGeo, taillightMat);\r\n            taillightL.position.set(-1.25, 0, 0.3);\r\n            body.add(taillightL);\r\n            const taillightR = new THREE.Mesh(taillightGeo, taillightMat);\r\n            taillightR.position.set(-1.25, 0, -0.3);\r\n            body.add(taillightR);\r\n            group.userData.taillights = [taillightL, taillightR];\r\n\r\n            return group;\r\n        }\r\n\r\n        function createVehiclePaths() {\r\n            const numPaths = Math.max(5, Math.floor(config.vehicleCount / 3));\r\n            const cityWidth = config.gridSize * config.cellSize;\r\n            const minHeight = config.cityScale + 10; // Above highest possible building segment\r\n            const maxHeight = minHeight + 30;\r\n\r\n            for (let i = 0; i < numPaths; i++) {\r\n                const points = [];\r\n                const numPoints = 5 + Math.floor(Math.random() * 5);\r\n                for (let j = 0; j < numPoints; j++) {\r\n                    points.push(new THREE.Vector3(\r\n                        (Math.random() - 0.5) * cityWidth * 1.2, // Slightly outside grid\r\n                        minHeight + Math.random() * (maxHeight - minHeight),\r\n                        (Math.random() - 0.5) * cityWidth * 1.2\r\n                    ));\r\n                }\r\n                points.push(points[0]); // Close the loop\r\n                const curve = new THREE.CatmullRomCurve3(points);\r\n                curve.curveType = 'catmullrom';\r\n                curve.tension = 0.5;\r\n                vehiclePaths.push(curve);\r\n\r\n                // Optional: visualize paths\r\n                // const lineGeo = new THREE.BufferGeometry().setFromPoints(curve.getPoints(50));\r\n                // const lineMat = new THREE.LineBasicMaterial({ color: 0xff0000 });\r\n                // const curveObject = new THREE.Line(lineGeo, lineMat);\r\n                // cityGroup.add(curveObject);\r\n            }\r\n        }\r\n\r\n        function spawnVehicles() {\r\n            if (vehiclePaths.length === 0) return;\r\n            for (let i = 0; i < config.vehicleCount; i++) {\r\n                const model = createVehicleModel();\r\n                const path = vehiclePaths[Math.floor(Math.random() * vehiclePaths.length)];\r\n                const speed = 0.01 + Math.random() * 0.02; // Speed as fraction of path per second\r\n                const progress = Math.random(); // Start at random point on path\r\n\r\n                vehicles.push({ model, path, speed, progress });\r\n                vehicleGroup.add(model);\r\n            }\r\n        }\r\n\r\n        function updateVehicles(delta) {\r\n            vehicles.forEach(v => {\r\n                v.progress = (v.progress + v.speed * delta) % 1;\r\n                const position = v.path.getPointAt(v.progress);\r\n                v.model.position.copy(position);\r\n\r\n                const tangent = v.path.getTangentAt(v.progress).normalize();\r\n                const nextPosition = v.path.getPointAt((v.progress + 0.001) % 1); // Look slightly ahead\r\n                v.model.lookAt(nextPosition);\r\n            });\r\n        }\r\n\r\n        function updateDayNightCycle(delta) {\r\n            timeOfDay = (timeOfDay + delta / config.dayDuration) % 1;\r\n\r\n            const hours = Math.floor(timeOfDay * 24);\r\n            const minutes = Math.floor((timeOfDay * 24 * 60) % 60);\r\n            document.getElementById('timeDisplay').textContent = `Time: ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;\r\n\r\n            // Sun position (simple circular path)\r\n            const sunAngle = timeOfDay * Math.PI * 2 - Math.PI / 2; // Offset to have noon at top\r\n            const cityCenter = config.gridSize * config.cellSize / 2;\r\n            sunLight.position.set(\r\n                cityCenter + Math.cos(sunAngle) * cityCenter * 2,\r\n                Math.sin(sunAngle) * cityCenter * 1.5, // Sun height\r\n                cityCenter + Math.sin(sunAngle) * cityCenter * 0.5 // Some Z variation\r\n            );\r\n            sunLight.target.position.set(cityCenter * 0.5, 0, cityCenter * 0.5); // Target center of city\r\n\r\n            // Light intensity and color\r\n            let sunIntensity, ambientIntensityFactor;\r\n            let skyColor = new THREE.Color();\r\n            let fogColor = new THREE.Color();\r\n            let windowEmissive = 0x000000;\r\n            let vehicleLightIntensity = 0;\r\n            let streetLightIntensity = 0;\r\n            let streetLightSourceIntensity = 0;\r\n\r\n            if (timeOfDay > 0.23 && timeOfDay < 0.27) { // Sunrise (5:30 - 6:30 AM)\r\n                const t = (timeOfDay - 0.23) / 0.04; // Normalize 0-1\r\n                sunIntensity = THREE.MathUtils.lerp(0.0, 1.2, t);\r\n                ambientIntensityFactor = THREE.MathUtils.lerp(0.3, 0.6, t);\r\n                skyColor.lerpColors(new THREE.Color(0x101020), new THREE.Color(0xffa500), t); // Dark blue to orange\r\n                fogColor.lerpColors(new THREE.Color(0x050510), new THREE.Color(0x886644), t);\r\n                vehicleLightIntensity = THREE.MathUtils.lerp(1, 0.5, t);\r\n                streetLightIntensity = THREE.MathUtils.lerp(2, 0.5, t);\r\n                streetLightSourceIntensity = THREE.MathUtils.lerp(1, 0.2, t);\r\n            } else if (timeOfDay >= 0.27 && timeOfDay < 0.73) { // Daytime (6:30 AM - 5:30 PM)\r\n                sunIntensity = 1.2;\r\n                ambientIntensityFactor = 0.6;\r\n                skyColor.set(0x87CEEB); // Sky blue\r\n                fogColor.set(0xaaaaee);\r\n                windowEmissive = 0x000000;\r\n                vehicleLightIntensity = 0;\r\n                streetLightIntensity = 0;\r\n                streetLightSourceIntensity = 0;\r\n            } else if (timeOfDay >= 0.73 && timeOfDay < 0.77) { // Sunset (5:30 PM - 6:30 PM)\r\n                const t = (timeOfDay - 0.73) / 0.04; // Normalize 0-1\r\n                sunIntensity = THREE.MathUtils.lerp(1.2, 0.0, t);\r\n                ambientIntensityFactor = THREE.MathUtils.lerp(0.6, 0.3, t);\r\n                skyColor.lerpColors(new THREE.Color(0xffa500), new THREE.Color(0x101020), t); // Orange to dark blue\r\n                fogColor.lerpColors(new THREE.Color(0x886644), new THREE.Color(0x050510), t);\r\n                windowEmissive = new THREE.Color(0xffffaa).multiplyScalar(t * 0.5).getHex();\r\n                vehicleLightIntensity = THREE.MathUtils.lerp(0.5, 1, t);\r\n                streetLightIntensity = THREE.MathUtils.lerp(0.5, 2, t);\r\n                streetLightSourceIntensity = THREE.MathUtils.lerp(0.2, 1, t);\r\n            } else { // Nighttime\r\n                sunIntensity = 0.0;\r\n                ambientIntensityFactor = 0.2; // Darker ambient for night\r\n                skyColor.set(0x050515); // Very dark blue\r\n                fogColor.set(0x020205);\r\n                windowEmissive = 0xffffaa; // Bright windows\r\n                vehicleLightIntensity = 1;\r\n                streetLightIntensity = 2;\r\n                streetLightSourceIntensity = 1;\r\n            }\r\n\r\n            sunLight.intensity = sunIntensity;\r\n            ambientLight.intensity = ambientIntensityFactor;\r\n            scene.background.copy(skyColor);\r\n            scene.fog.color.copy(fogColor);\r\n\r\n            // Update window emissive material\r\n            windowMaterial.emissive.setHex(windowEmissive);\r\n            windowMaterial.emissiveIntensity = (windowEmissive === 0x000000) ? 0 : 1;\r\n\r\n\r\n            // Update vehicle lights\r\n            vehicles.forEach(v => {\r\n                v.model.userData.headlights.forEach(light => light.material.emissiveIntensity = vehicleLightIntensity);\r\n                v.model.userData.taillights.forEach(light => light.material.emissiveIntensity = vehicleLightIntensity);\r\n            });\r\n\r\n            // Update street lights\r\n            streetLightMeshes.forEach(mesh => mesh.material.emissiveIntensity = streetLightIntensity);\r\n            streetLightSources.forEach(light => light.intensity = streetLightSourceIntensity);\r\n        }\r\n\r\n        function setupUI() {\r\n            document.getElementById('regenerateButton').addEventListener('click', () => {\r\n                config.gridSize = parseInt(document.getElementById('gridSizeInput').value);\r\n                config.cityScale = parseInt(document.getElementById('cityScaleInput').value);\r\n                config.vehicleCount = parseInt(document.getElementById('vehicleCountInput').value);\r\n                regenerateWorld();\r\n            });\r\n        }\r\n\r\n        function onWindowResize() {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n            const delta = clock.getDelta();\r\n\r\n            updateDayNightCycle(delta);\r\n            updateVehicles(delta);\r\n\r\n            controls.update();\r\n            renderer.render(scene, camera);\r\n        }\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "futuristic-city-gemini-pro-2-5",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.945Z",
    "model": "gemini-pro-2.5",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, astronomy, simulation, architecture."
  }
}
