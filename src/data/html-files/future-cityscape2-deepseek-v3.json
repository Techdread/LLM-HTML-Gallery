{
  "title": "Futuristic Cityscape with Flying Vehicles",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Futuristic Cityscape with Flying Vehicles</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n            font-family: 'Arial', sans-serif;\r\n            color: white;\r\n        }\r\n        \r\n        #canvas-container {\r\n            position: absolute;\r\n            width: 100%;\r\n            height: 100%;\r\n        }\r\n        \r\n        #info {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            background: rgba(0, 0, 0, 0.7);\r\n            padding: 10px;\r\n            border-radius: 5px;\r\n            font-size: 14px;\r\n        }\r\n        \r\n        #controls {\r\n            position: absolute;\r\n            bottom: 20px;\r\n            left: 50%;\r\n            transform: translateX(-50%);\r\n            background: rgba(0, 0, 0, 0.7);\r\n            padding: 10px;\r\n            border-radius: 5px;\r\n            display: flex;\r\n            gap: 10px;\r\n        }\r\n        \r\n        button {\r\n            background: #4a6da7;\r\n            color: white;\r\n            border: none;\r\n            padding: 8px 15px;\r\n            border-radius: 4px;\r\n            cursor: pointer;\r\n            transition: background 0.3s;\r\n        }\r\n        \r\n        button:hover {\r\n            background: #5d8ac9;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"canvas-container\"></div>\r\n    \r\n    <div id=\"info\">\r\n        <h2>Futuristic Cityscape</h2>\r\n        <p>WASD: Move camera</p>\r\n        <p>Mouse: Look around</p>\r\n        <p>Scroll: Zoom in/out</p>\r\n    </div>\r\n    \r\n    <div id=\"controls\">\r\n        <button id=\"view-top\">Top View</button>\r\n        <button id=\"view-street\">Street View</button>\r\n        <button id=\"view-follow\">Follow Vehicle</button>\r\n    </div>\r\n\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js\"></script>\r\n    <script>\r\n        // Main ThreeJS application\r\n        let scene, camera, renderer, controls;\r\n        let vehicles = [];\r\n        let city = [];\r\n        let clock = new THREE.Clock();\r\n        let followVehicle = false;\r\n        let followedVehicleIndex = 0;\r\n\r\n        // Initialize the application\r\n        init();\r\n\r\n        function init() {\r\n            // Create scene\r\n            scene = new THREE.Scene();\r\n            scene.background = new THREE.Color(0x111122);\r\n            scene.fog = new THREE.FogExp2(0x111122, 0.002);\r\n\r\n            // Create camera\r\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);\r\n            camera.position.set(0, 200, 500);\r\n            \r\n            // Create renderer\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setPixelRatio(window.devicePixelRatio);\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            renderer.shadowMap.enabled = true;\r\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n            document.getElementById('canvas-container').appendChild(renderer.domElement);\r\n            \r\n            // Add orbit controls\r\n            controls = new THREE.OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n            controls.minDistance = 100;\r\n            controls.maxDistance = 2000;\r\n            \r\n            // Add lights\r\n            setupLights();\r\n            \r\n            // Create city\r\n            createCity();\r\n            \r\n            // Create flying vehicles\r\n            createVehicles();\r\n            \r\n            // Add event listeners\r\n            window.addEventListener('resize', onWindowResize);\r\n            \r\n            // Setup UI controls\r\n            document.getElementById('view-top').addEventListener('click', () => {\r\n                followVehicle = false;\r\n                camera.position.set(0, 1000, 0);\r\n                camera.lookAt(0, 0, 0);\r\n                controls.target.set(0, 0, 0);\r\n            });\r\n            \r\n            document.getElementById('view-street').addEventListener('click', () => {\r\n                followVehicle = false;\r\n                camera.position.set(0, 50, 300);\r\n                camera.lookAt(0, 50, 0);\r\n                controls.target.set(0, 50, 0);\r\n            });\r\n            \r\n            document.getElementById('view-follow').addEventListener('click', () => {\r\n                followVehicle = true;\r\n                followedVehicleIndex = Math.floor(Math.random() * vehicles.length);\r\n            });\r\n            \r\n            // Start animation loop\r\n            animate();\r\n        }\r\n\r\n        function setupLights() {\r\n            // Ambient light\r\n            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);\r\n            scene.add(ambientLight);\r\n            \r\n            // Directional light (sun)\r\n            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\r\n            directionalLight.position.set(100, 300, 100);\r\n            directionalLight.castShadow = true;\r\n            directionalLight.shadow.mapSize.width = 2048;\r\n            directionalLight.shadow.mapSize.height = 2048;\r\n            directionalLight.shadow.camera.near = 0.5;\r\n            directionalLight.shadow.camera.far = 1000;\r\n            directionalLight.shadow.camera.left = -200;\r\n            directionalLight.shadow.camera.right = 200;\r\n            directionalLight.shadow.camera.top = 200;\r\n            directionalLight.shadow.camera.bottom = -200;\r\n            scene.add(directionalLight);\r\n            \r\n            // Hemisphere light\r\n            const hemisphereLight = new THREE.HemisphereLight(0x4488ff, 0xff8844, 0.3);\r\n            scene.add(hemisphereLight);\r\n            \r\n            // City lights\r\n            const cityLight = new THREE.PointLight(0xffdd99, 0.8, 100);\r\n            cityLight.position.set(0, 50, 0);\r\n            scene.add(cityLight);\r\n        }\r\n\r\n        function createCity() {\r\n            // Ground plane\r\n            const groundGeometry = new THREE.PlaneGeometry(2000, 2000);\r\n            const groundMaterial = new THREE.MeshStandardMaterial({ \r\n                color: 0x333344,\r\n                roughness: 0.8,\r\n                metalness: 0.2\r\n            });\r\n            const ground = new THREE.Mesh(groundGeometry, groundMaterial);\r\n            ground.rotation.x = -Math.PI / 2;\r\n            ground.receiveShadow = true;\r\n            scene.add(ground);\r\n            \r\n            // Create buildings\r\n            const buildingColors = [\r\n                0x445588, 0x556699, 0x6677aa, 0x334477,\r\n                0x7788bb, 0x8899cc, 0x99aadd, 0xaabbee\r\n            ];\r\n            \r\n            const buildingMaterials = buildingColors.map(color => \r\n                new THREE.MeshStandardMaterial({ \r\n                    color: color,\r\n                    roughness: 0.7,\r\n                    metalness: 0.3\r\n                })\r\n            );\r\n            \r\n            // Add some emissive materials for windows\r\n            const windowMaterial = new THREE.MeshStandardMaterial({\r\n                color: 0xffffcc,\r\n                emissive: 0xffffee,\r\n                emissiveIntensity: 1.0,\r\n                roughness: 0.1,\r\n                metalness: 0.9\r\n            });\r\n            \r\n            // Create a grid of buildings\r\n            const gridSize = 20;\r\n            const spacing = 80;\r\n            const offset = (gridSize * spacing) / 2;\r\n            \r\n            for (let i = 0; i < gridSize; i++) {\r\n                for (let j = 0; j < gridSize; j++) {\r\n                    // Skip some spaces for variety\r\n                    if (Math.random() < 0.2) continue;\r\n                    \r\n                    const height = 20 + Math.random() * 150;\r\n                    const width = 30 + Math.random() * 40;\r\n                    const depth = 30 + Math.random() * 40;\r\n                    \r\n                    const buildingGeometry = new THREE.BoxGeometry(width, height, depth);\r\n                    \r\n                    // Create main building\r\n                    const building = new THREE.Mesh(\r\n                        buildingGeometry, \r\n                        buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)]\r\n                    );\r\n                    \r\n                    building.position.x = i * spacing - offset + (Math.random() * 20 - 10);\r\n                    building.position.z = j * spacing - offset + (Math.random() * 20 - 10);\r\n                    building.position.y = height / 2;\r\n                    building.castShadow = true;\r\n                    building.receiveShadow = true;\r\n                    \r\n                    scene.add(building);\r\n                    city.push(building);\r\n                    \r\n                    // Add windows\r\n                    if (height > 40) {\r\n                        const windowRows = Math.floor(height / 15);\r\n                        const windowCols = Math.floor(width / 10);\r\n                        \r\n                        for (let row = 0; row < windowRows; row++) {\r\n                            for (let col = 0; col < windowCols; col++) {\r\n                                if (Math.random() < 0.7) continue; // Not all windows are lit\r\n                                \r\n                                const windowGeometry = new THREE.PlaneGeometry(5, 5);\r\n                                const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);\r\n                                \r\n                                windowMesh.position.x = building.position.x - width/2 + col * (width / windowCols) + 5;\r\n                                windowMesh.position.y = building.position.y - height/2 + row * (height / windowRows) + 10;\r\n                                windowMesh.position.z = building.position.z + depth/2 + 1;\r\n                                \r\n                                windowMesh.rotation.y = Math.PI;\r\n                                scene.add(windowMesh);\r\n                                \r\n                                // Add windows to the other side\r\n                                if (Math.random() < 0.5) {\r\n                                    const windowMesh2 = windowMesh.clone();\r\n                                    windowMesh2.position.z = building.position.z - depth/2 - 1;\r\n                                    windowMesh2.rotation.y = 0;\r\n                                    scene.add(windowMesh2);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                    // Add some decorative elements\r\n                    if (Math.random() < 0.3) {\r\n                        addBuildingDetails(building, height, width, depth);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // Add some larger landmark buildings\r\n            addLandmarkBuildings();\r\n        }\r\n\r\n        function addBuildingDetails(building, height, width, depth) {\r\n            // Add antenna or spire\r\n            if (Math.random() < 0.5 && height > 80) {\r\n                const spireHeight = height * 0.2 + Math.random() * height * 0.3;\r\n                const spireGeometry = new THREE.CylinderGeometry(1, 3, spireHeight, 8);\r\n                const spireMaterial = new THREE.MeshStandardMaterial({ \r\n                    color: 0xaaaaaa,\r\n                    metalness: 0.9,\r\n                    roughness: 0.1\r\n                });\r\n                const spire = new THREE.Mesh(spireGeometry, spireMaterial);\r\n                \r\n                spire.position.x = building.position.x;\r\n                spire.position.y = building.position.y + height/2 + spireHeight/2;\r\n                spire.position.z = building.position.z;\r\n                \r\n                scene.add(spire);\r\n            }\r\n            \r\n            // Add some horizontal platforms\r\n            if (Math.random() < 0.4 && height > 60) {\r\n                const platformGeometry = new THREE.CylinderGeometry(\r\n                    width * 0.6, \r\n                    width * 0.8, \r\n                    2, \r\n                    8\r\n                );\r\n                const platformMaterial = new THREE.MeshStandardMaterial({ \r\n                    color: 0x666677,\r\n                    metalness: 0.5,\r\n                    roughness: 0.5\r\n                });\r\n                const platform = new THREE.Mesh(platformGeometry, platformMaterial);\r\n                \r\n                platform.position.x = building.position.x;\r\n                platform.position.y = building.position.y - height/2 + height * 0.7;\r\n                platform.position.z = building.position.z;\r\n                \r\n                scene.add(platform);\r\n            }\r\n        }\r\n\r\n        function addLandmarkBuildings() {\r\n            // Central tower\r\n            const centralTowerHeight = 400;\r\n            const centralTowerGeometry = new THREE.CylinderGeometry(40, 60, centralTowerHeight, 16);\r\n            const centralTowerMaterial = new THREE.MeshStandardMaterial({ \r\n                color: 0x99aadd,\r\n                metalness: 0.6,\r\n                roughness: 0.3\r\n            });\r\n            const centralTower = new THREE.Mesh(centralTowerGeometry, centralTowerMaterial);\r\n            \r\n            centralTower.position.y = centralTowerHeight / 2;\r\n            centralTower.castShadow = true;\r\n            scene.add(centralTower);\r\n            city.push(centralTower);\r\n            \r\n            // Add rings to the central tower\r\n            for (let i = 0; i < 5; i++) {\r\n                const ringHeight = centralTowerHeight * 0.2 + i * centralTowerHeight * 0.15;\r\n                const ringGeometry = new THREE.TorusGeometry(60 + i * 10, 5, 16, 32);\r\n                const ringMaterial = new THREE.MeshStandardMaterial({ \r\n                    color: 0xccddff,\r\n                    metalness: 0.8,\r\n                    roughness: 0.1,\r\n                    emissive: 0x4488ff,\r\n                    emissiveIntensity: 0.3\r\n                });\r\n                const ring = new THREE.Mesh(ringGeometry, ringMaterial);\r\n                \r\n                ring.position.y = ringHeight;\r\n                ring.rotation.x = Math.PI / 2;\r\n                scene.add(ring);\r\n            }\r\n            \r\n            // Add some other landmark buildings around the city\r\n            const landmarkPositions = [\r\n                { x: -500, z: -500 },\r\n                { x: 500, z: -500 },\r\n                { x: -500, z: 500 },\r\n                { x: 500, z: 500 }\r\n            ];\r\n            \r\n            landmarkPositions.forEach(pos => {\r\n                const height = 250 + Math.random() * 150;\r\n                const shape = new THREE.Shape();\r\n                const sides = 6 + Math.floor(Math.random() * 6);\r\n                const radius = 30 + Math.random() * 20;\r\n                \r\n                shape.moveTo(radius, 0);\r\n                for (let i = 1; i <= sides; i++) {\r\n                    const angle = (i / sides) * Math.PI * 2;\r\n                    shape.lineTo(\r\n                        Math.cos(angle) * radius,\r\n                        Math.sin(angle) * radius\r\n                    );\r\n                }\r\n                \r\n                const extrudeSettings = {\r\n                    steps: 1,\r\n                    depth: height,\r\n                    bevelEnabled: true,\r\n                    bevelThickness: 5,\r\n                    bevelSize: 5,\r\n                    bevelOffset: 0,\r\n                    bevelSegments: 3\r\n                };\r\n                \r\n                const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);\r\n                const material = new THREE.MeshStandardMaterial({ \r\n                    color: 0x88aadd,\r\n                    metalness: 0.7,\r\n                    roughness: 0.2\r\n                });\r\n                \r\n                const building = new THREE.Mesh(geometry, material);\r\n                building.position.set(pos.x, height / 2, pos.z);\r\n                building.rotation.y = Math.random() * Math.PI * 2;\r\n                building.castShadow = true;\r\n                scene.add(building);\r\n                city.push(building);\r\n                \r\n                // Add a light at the top\r\n                const topLight = new THREE.PointLight(0xffaa88, 1, 200);\r\n                topLight.position.set(pos.x, height + 10, pos.z);\r\n                scene.add(topLight);\r\n            });\r\n        }\r\n\r\n        function createVehicles() {\r\n            // Create several flying vehicles with different paths\r\n            const vehicleCount = 12;\r\n            \r\n            for (let i = 0; i < vehicleCount; i++) {\r\n                createVehicle(i);\r\n            }\r\n        }\r\n\r\n        function createVehicle(index) {\r\n            // Create a simple vehicle model\r\n            const vehicleGroup = new THREE.Group();\r\n            \r\n            // Vehicle body\r\n            const bodyGeometry = new THREE.BoxGeometry(15, 5, 30);\r\n            const bodyMaterial = new THREE.MeshStandardMaterial({ \r\n                color: 0x333333,\r\n                metalness: 0.8,\r\n                roughness: 0.2\r\n            });\r\n            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);\r\n            body.castShadow = true;\r\n            vehicleGroup.add(body);\r\n            \r\n            // Cockpit\r\n            const cockpitGeometry = new THREE.SphereGeometry(4, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);\r\n            const cockpitMaterial = new THREE.MeshStandardMaterial({ \r\n                color: 0x88ccff,\r\n                metalness: 0.9,\r\n                roughness: 0.1,\r\n                transparent: true,\r\n                opacity: 0.7\r\n            });\r\n            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);\r\n            cockpit.position.set(0, 3, -5);\r\n            cockpit.rotation.x = Math.PI;\r\n            vehicleGroup.add(cockpit);\r\n            \r\n            // Wings\r\n            const wingGeometry = new THREE.BoxGeometry(30, 1, 10);\r\n            const wingMaterial = new THREE.MeshStandardMaterial({ \r\n                color: 0x555555,\r\n                metalness: 0.7,\r\n                roughness: 0.3\r\n            });\r\n            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);\r\n            leftWing.position.set(-20, 0, 0);\r\n            vehicleGroup.add(leftWing);\r\n            \r\n            const rightWing = leftWing.clone();\r\n            rightWing.position.set(20, 0, 0);\r\n            vehicleGroup.add(rightWing);\r\n            \r\n            // Engine glow\r\n            const engineLight = new THREE.PointLight(0x44aaff, 2, 50);\r\n            engineLight.position.set(0, 0, 15);\r\n            vehicleGroup.add(engineLight);\r\n            \r\n            // Add some decorative elements\r\n            const detailGeometry = new THREE.ConeGeometry(2, 5, 4);\r\n            const detailMaterial = new THREE.MeshStandardMaterial({ \r\n                color: 0xaaaaaa,\r\n                metalness: 0.9,\r\n                roughness: 0.1\r\n            });\r\n            \r\n            for (let i = 0; i < 4; i++) {\r\n                const detail = new THREE.Mesh(detailGeometry, detailMaterial);\r\n                detail.position.set(\r\n                    (i % 2 === 0 ? -8 : 8),\r\n                    0,\r\n                    -10 + (i < 2 ? 0 : 5)\r\n                );\r\n                detail.rotation.x = Math.PI / 2;\r\n                vehicleGroup.add(detail);\r\n            }\r\n            \r\n            // Set initial position based on index\r\n            const angle = (index / vehicles.length) * Math.PI * 2;\r\n            const radius = 300 + Math.random() * 200;\r\n            \r\n            vehicleGroup.position.x = Math.cos(angle) * radius;\r\n            vehicleGroup.position.y = 100 + Math.random() * 200;\r\n            vehicleGroup.position.z = Math.sin(angle) * radius;\r\n            \r\n            // Add to scene\r\n            scene.add(vehicleGroup);\r\n            \r\n            // Store vehicle data\r\n            vehicles.push({\r\n                group: vehicleGroup,\r\n                speed: 0.5 + Math.random() * 0.5,\r\n                pathPoints: generatePathPoints(index),\r\n                currentPathIndex: 0,\r\n                nextPathIndex: 1\r\n            });\r\n        }\r\n\r\n        function generatePathPoints(index) {\r\n            const points = [];\r\n            const pointCount = 20 + Math.floor(Math.random() * 10);\r\n            const centerOffset = (index % 3) * 100 - 100; // Vary paths slightly\r\n            \r\n            for (let i = 0; i < pointCount; i++) {\r\n                const angle = (i / pointCount) * Math.PI * 2;\r\n                const radius = 200 + Math.random() * 300;\r\n                const height = 100 + Math.random() * 300;\r\n                \r\n                points.push(new THREE.Vector3(\r\n                    Math.cos(angle) * radius + centerOffset,\r\n                    height,\r\n                    Math.sin(angle) * radius + centerOffset\r\n                ));\r\n            }\r\n            \r\n            // Add some vertical movement\r\n            for (let i = 0; i < pointCount; i += 2) {\r\n                points[i].y += 100;\r\n            }\r\n            \r\n            return points;\r\n        }\r\n\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n            \r\n            const delta = clock.getDelta();\r\n            \r\n            // Update vehicles\r\n            updateVehicles(delta);\r\n            \r\n            // Update camera if following a vehicle\r\n            if (followVehicle && vehicles.length > 0) {\r\n                const vehicle = vehicles[followedVehicleIndex];\r\n                const vehiclePos = vehicle.group.position;\r\n                \r\n                // Calculate position behind and above the vehicle\r\n                const targetPos = new THREE.Vector3();\r\n                targetPos.copy(vehiclePos);\r\n                \r\n                // Get vehicle forward direction\r\n                const lookAtPoint = new THREE.Vector3();\r\n                if (vehicle.nextPathIndex < vehicle.pathPoints.length) {\r\n                    lookAtPoint.copy(vehicle.pathPoints[vehicle.nextPathIndex]);\r\n                } else {\r\n                    lookAtPoint.copy(vehicle.pathPoints[0]);\r\n                }\r\n                \r\n                const forward = new THREE.Vector3().subVectors(lookAtPoint, vehiclePos).normalize();\r\n                const up = new THREE.Vector3(0, 1, 0);\r\n                const right = new THREE.Vector3().crossVectors(up, forward).normalize();\r\n                const cameraOffset = new THREE.Vector3().copy(right).multiplyScalar(30);\r\n                cameraOffset.add(new THREE.Vector3(0, 20, 0));\r\n                cameraOffset.add(new THREE.Vector3().copy(forward).multiplyScalar(-50));\r\n                \r\n                targetPos.add(cameraOffset);\r\n                \r\n                // Smooth camera movement\r\n                camera.position.lerp(targetPos, 0.1);\r\n                camera.lookAt(vehiclePos);\r\n                controls.target.copy(vehiclePos);\r\n            }\r\n            \r\n            // Update controls\r\n            controls.update();\r\n            \r\n            // Render scene\r\n            renderer.render(scene, camera);\r\n        }\r\n\r\n        function updateVehicles(delta) {\r\n            vehicles.forEach(vehicle => {\r\n                const { group, pathPoints, speed } = vehicle;\r\n                \r\n                // Get current and next path points\r\n                const currentIndex = vehicle.currentPathIndex;\r\n                const nextIndex = vehicle.nextPathIndex;\r\n                \r\n                const currentPoint = pathPoints[currentIndex];\r\n                const nextPoint = pathPoints[nextIndex];\r\n                \r\n                // Calculate direction to next point\r\n                const direction = new THREE.Vector3().subVectors(nextPoint, currentPoint).normalize();\r\n                const distanceToNext = group.position.distanceTo(nextPoint);\r\n                \r\n                // Move vehicle\r\n                group.position.add(direction.clone().multiplyScalar(speed));\r\n                \r\n                // Rotate vehicle to face direction of movement\r\n                if (distanceToNext > 5) {\r\n                    group.quaternion.slerp(\r\n                        new THREE.Quaternion().setFromUnitVectors(\r\n                            new THREE.Vector3(0, 0, -1),\r\n                            direction\r\n                        ),\r\n                        0.1\r\n                    );\r\n                }\r\n            \r\n                // Check if reached next point\r\n                if (distanceToNext < 10) {\r\n                    vehicle.currentPathIndex = nextIndex;\r\n                    vehicle.nextPathIndex = (nextIndex + 1) % pathPoints.length;\r\n                }\r\n            });\r\n        }\r\n\r\n        function onWindowResize() {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n    </script>\r\n</body>\r\n</html>",
  "id": "future-cityscape2-deepseek-v3",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.830Z",
    "model": "deepseek-v3",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, astronomy, architecture."
  }
}
