{
  "title": "3D Palletization Algorithm Visualizer",
  "htmlContent": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>3D Palletization Algorithm Visualizer</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        \n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            overflow: hidden;\n            color: white;\n        }\n        \n        #container {\n            width: 100vw;\n            height: 100vh;\n            position: relative;\n        }\n        \n        #canvas-container {\n            position: relative;\n            width: 100%;\n            height: 100%;\n        }\n        \n        #controls {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            background: rgba(0, 0, 0, 0.8);\n            backdrop-filter: blur(10px);\n            padding: 20px;\n            border-radius: 15px;\n            border: 1px solid rgba(255, 255, 255, 0.1);\n            z-index: 100;\n            min-width: 300px;\n        }\n        \n        #info-panel {\n            position: absolute;\n            top: 20px;\n            right: 20px;\n            background: rgba(0, 0, 0, 0.8);\n            backdrop-filter: blur(10px);\n            padding: 20px;\n            border-radius: 15px;\n            border: 1px solid rgba(255, 255, 255, 0.1);\n            z-index: 100;\n            min-width: 250px;\n        }\n        \n        .control-group {\n            margin-bottom: 15px;\n        }\n        \n        label {\n            display: block;\n            margin-bottom: 5px;\n            font-weight: 600;\n            color: #ffffff;\n        }\n        \n        select, button, input[type=\"range\"] {\n            width: 100%;\n            padding: 8px;\n            border: none;\n            border-radius: 8px;\n            background: rgba(255, 255, 255, 0.1);\n            color: white;\n            font-size: 14px;\n        }\n        \n        button {\n            background: linear-gradient(45deg, #4CAF50, #45a049);\n            cursor: pointer;\n            transition: all 0.3s ease;\n            font-weight: 600;\n        }\n        \n        button:hover {\n            transform: translateY(-2px);\n            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);\n        }\n        \n        button:disabled {\n            background: rgba(255, 255, 255, 0.2);\n            cursor: not-allowed;\n            transform: none;\n        }\n        \n        .algorithm-btn {\n            background: linear-gradient(45deg, #2196F3, #1976D2);\n            margin: 5px 0;\n        }\n        \n        .algorithm-btn:hover {\n            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);\n        }\n        \n        .algorithm-btn.active {\n            background: linear-gradient(45deg, #FF9800, #F57C00);\n        }\n        \n        input[type=\"range\"] {\n            -webkit-appearance: none;\n            height: 6px;\n            background: rgba(255, 255, 255, 0.3);\n            outline: none;\n        }\n        \n        input[type=\"range\"]::-webkit-slider-thumb {\n            -webkit-appearance: none;\n            appearance: none;\n            width: 20px;\n            height: 20px;\n            background: #4CAF50;\n            cursor: pointer;\n            border-radius: 50%;\n        }\n        \n        .stats {\n            font-size: 12px;\n            margin: 5px 0;\n        }\n        \n        .legend {\n            margin-top: 15px;\n        }\n        \n        .legend-item {\n            display: flex;\n            align-items: center;\n            margin: 5px 0;\n        }\n        \n        .color-box {\n            width: 20px;\n            height: 20px;\n            margin-right: 10px;\n            border-radius: 4px;\n        }\n        \n        #loading {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            background: rgba(0, 0, 0, 0.9);\n            padding: 20px 40px;\n            border-radius: 10px;\n            z-index: 1000;\n        }\n        \n        .spinner {\n            border: 3px solid rgba(255, 255, 255, 0.3);\n            border-top: 3px solid #4CAF50;\n            border-radius: 50%;\n            width: 30px;\n            height: 30px;\n            animation: spin 1s linear infinite;\n            margin: 0 auto 10px;\n        }\n        \n        @keyframes spin {\n            0% { transform: rotate(0deg); }\n            100% { transform: rotate(360deg); }\n        }\n        \n        .visualization-mode {\n            display: flex;\n            gap: 10px;\n            margin: 10px 0;\n        }\n        \n        .mode-btn {\n            flex: 1;\n            padding: 8px;\n            background: rgba(255, 255, 255, 0.1);\n            border: 1px solid rgba(255, 255, 255, 0.2);\n            border-radius: 6px;\n            cursor: pointer;\n            text-align: center;\n            transition: all 0.3s ease;\n        }\n        \n        .mode-btn.active {\n            background: rgba(76, 175, 80, 0.3);\n            border-color: #4CAF50;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"container\">\n        <div id=\"canvas-container\"></div>\n        \n        <div id=\"controls\">\n            <h3>Algorithm Controls</h3>\n            \n            <div class=\"control-group\">\n                <label>Spatial Tracking Method:</label>\n                <select id=\"spatialMethod\">\n                    <option value=\"linear\">Linear Search (Current)</option>\n                    <option value=\"grid\">Grid-based (Voxel)</option>\n                    <option value=\"octree\">Octree</option>\n                    <option value=\"corners\">Corner Points</option>\n                    <option value=\"spatial-hash\">Spatial Hashing</option>\n                </select>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>Placement Algorithm:</label>\n                <button class=\"algorithm-btn active\" data-algorithm=\"firstfit\">First Fit</button>\n                <button class=\"algorithm-btn\" data-algorithm=\"bottomleft\">Bottom-Left Fill</button>\n                <button class=\"algorithm-btn\" data-algorithm=\"skyline\">3D Skyline</button>\n                <button class=\"algorithm-btn\" data-algorithm=\"corners\">Corner Points</button>\n            </div>\n            \n            <div class=\"visualization-mode\">\n                <div class=\"mode-btn active\" data-mode=\"products\">Products</div>\n                <div class=\"mode-btn\" data-mode=\"spatial\">Spatial Grid</div>\n                <div class=\"mode-btn\" data-mode=\"both\">Both</div>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>Animation Speed:</label>\n                <input type=\"range\" id=\"speed\" min=\"50\" max=\"2000\" value=\"500\">\n            </div>\n            \n            <div class=\"control-group\">\n                <label>Grid Resolution (for grid-based):</label>\n                <input type=\"range\" id=\"gridRes\" min=\"10\" max=\"50\" value=\"20\">\n            </div>\n            \n            <div class=\"control-group\">\n                <button id=\"startBtn\">Start Packing</button>\n                <button id=\"pauseBtn\" disabled>Pause</button>\n                <button id=\"resetBtn\">Reset</button>\n                <button id=\"stepBtn\">Step</button>\n            </div>\n        </div>\n        \n        <div id=\"info-panel\">\n            <h3>Statistics</h3>\n            <div class=\"stats\">\n                <div>Products Placed: <span id=\"placedCount\">0</span></div>\n                <div>Total Products: <span id=\"totalCount\">0</span></div>\n                <div>Volume Utilization: <span id=\"utilization\">0%</span></div>\n                <div>Current Operation: <span id=\"currentOp\">Ready</span></div>\n                <div>Spatial Queries: <span id=\"queries\">0</span></div>\n                <div>Collisions Checked: <span id=\"collisions\">0</span></div>\n            </div>\n            \n            <div class=\"legend\">\n                <h4>Legend</h4>\n                <div class=\"legend-item\">\n                    <div class=\"color-box\" style=\"background: #8B4513;\"></div>\n                    <span>Pallet</span>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"color-box\" style=\"background: #4CAF50;\"></div>\n                    <span>Placed Products</span>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"color-box\" style=\"background: #FF5722;\"></div>\n                    <span>Current Product</span>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"color-box\" style=\"background: #FFC107;\"></div>\n                    <span>Candidate Position</span>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"color-box\" style=\"background: rgba(255, 255, 255, 0.1);\"></div>\n                    <span>Spatial Grid</span>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"color-box\" style=\"background: #2196F3;\"></div>\n                    <span>Corner Points</span>\n                </div>\n            </div>\n        </div>\n        \n        <div id=\"loading\" style=\"display: none;\">\n            <div class=\"spinner\"></div>\n            <div>Loading Three.js...</div>\n        </div>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script>\n        // Global variables\n        let scene, camera, renderer, controls;\n        let pallet, products = [], placedProducts = [];\n        let spatialGrid, spatialStructure;\n        let isRunning = false, isPaused = false;\n        let currentAlgorithm = 'firstfit';\n        let currentSpatialMethod = 'linear';\n        let visualizationMode = 'products';\n        let animationSpeed = 500;\n        let gridResolution = 20;\n        let stats = {\n            placedCount: 0,\n            totalCount: 0,\n            queries: 0,\n            collisions: 0\n        };\n\n        // Pallet and product configurations\n        const PALLET_SIZE = { width: 120, height: 15, length: 100 };\n        const PRODUCT_TYPES = [\n            { width: 20, height: 25, length: 30, color: 0x4CAF50, weight: 5 },\n            { width: 15, height: 30, length: 25, color: 0x2196F3, weight: 3 },\n            { width: 25, height: 20, length: 20, color: 0xFF9800, weight: 7 },\n            { width: 30, height: 15, length: 35, color: 0x9C27B0, weight: 8 },\n            { width: 18, height: 22, length: 28, color: 0xF44336, weight: 4 }\n        ];\n\n        // Initialize Three.js scene\n        function initThreeJS() {\n            const container = document.getElementById('canvas-container');\n            \n            // Scene\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(0x222222);\n            scene.fog = new THREE.Fog(0x222222, 200, 1000);\n\n            // Camera\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n            camera.position.set(200, 150, 200);\n            camera.lookAt(0, 0, 0);\n\n            // Renderer\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.shadowMap.enabled = true;\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n            container.appendChild(renderer.domElement);\n\n            // Lighting\n            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);\n            scene.add(ambientLight);\n\n            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n            directionalLight.position.set(100, 100, 50);\n            directionalLight.castShadow = true;\n            directionalLight.shadow.mapSize.width = 2048;\n            directionalLight.shadow.mapSize.height = 2048;\n            scene.add(directionalLight);\n\n            // Basic camera controls (simplified orbit)\n            setupCameraControls();\n\n            // Create pallet\n            createPallet();\n            \n            // Generate sample products\n            generateProducts();\n            \n            // Initialize spatial structures\n            initializeSpatialStructures();\n            \n            animate();\n        }\n\n        function setupCameraControls() {\n            let isMouseDown = false;\n            let mouseX = 0, mouseY = 0;\n            let targetRotationX = 0, targetRotationY = 0;\n            let rotationX = 0, rotationY = 0;\n\n            renderer.domElement.addEventListener('mousedown', (event) => {\n                isMouseDown = true;\n                mouseX = event.clientX;\n                mouseY = event.clientY;\n            });\n\n            document.addEventListener('mouseup', () => {\n                isMouseDown = false;\n            });\n\n            document.addEventListener('mousemove', (event) => {\n                if (isMouseDown) {\n                    const deltaX = event.clientX - mouseX;\n                    const deltaY = event.clientY - mouseY;\n                    \n                    targetRotationY += deltaX * 0.01;\n                    targetRotationX += deltaY * 0.01;\n                    \n                    mouseX = event.clientX;\n                    mouseY = event.clientY;\n                }\n            });\n\n            renderer.domElement.addEventListener('wheel', (event) => {\n                const distance = camera.position.length();\n                const factor = event.deltaY > 0 ? 1.1 : 0.9;\n                camera.position.multiplyScalar(factor);\n            });\n\n            function updateCamera() {\n                rotationX += (targetRotationX - rotationX) * 0.05;\n                rotationY += (targetRotationY - rotationY) * 0.05;\n                \n                const distance = camera.position.length();\n                camera.position.x = distance * Math.sin(rotationY) * Math.cos(rotationX);\n                camera.position.y = distance * Math.sin(rotationX);\n                camera.position.z = distance * Math.cos(rotationY) * Math.cos(rotationX);\n                camera.lookAt(0, 0, 0);\n                \n                requestAnimationFrame(updateCamera);\n            }\n            updateCamera();\n        }\n\n        function createPallet() {\n            const geometry = new THREE.BoxGeometry(PALLET_SIZE.length, PALLET_SIZE.height, PALLET_SIZE.width);\n            const material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });\n            pallet = new THREE.Mesh(geometry, material);\n            pallet.position.set(0, PALLET_SIZE.height / 2, 0);\n            pallet.castShadow = true;\n            pallet.receiveShadow = true;\n            scene.add(pallet);\n\n            // Add wireframe outline\n            const wireframe = new THREE.WireframeGeometry(geometry);\n            const line = new THREE.LineSegments(wireframe);\n            line.material.color.setHex(0x000000);\n            line.position.copy(pallet.position);\n            scene.add(line);\n        }\n\n        function generateProducts() {\n            products = [];\n            const productCount = 20;\n            \n            for (let i = 0; i < productCount; i++) {\n                const type = PRODUCT_TYPES[Math.floor(Math.random() * PRODUCT_TYPES.length)];\n                products.push({\n                    id: i,\n                    dimensions: { ...type },\n                    placed: false,\n                    mesh: null\n                });\n            }\n            \n            stats.totalCount = products.length;\n            updateStats();\n        }\n\n        function initializeSpatialStructures() {\n            switch (currentSpatialMethod) {\n                case 'grid':\n                    initializeGrid();\n                    break;\n                case 'octree':\n                    initializeOctree();\n                    break;\n                case 'corners':\n                    initializeCornerPoints();\n                    break;\n                case 'spatial-hash':\n                    initializeSpatialHash();\n                    break;\n                default:\n                    spatialStructure = null;\n            }\n        }\n\n        function initializeGrid() {\n            spatialGrid = [];\n            const cellSize = Math.max(PALLET_SIZE.length, PALLET_SIZE.width) / gridResolution;\n            \n            // Create visual grid if needed\n            if (visualizationMode === 'spatial' || visualizationMode === 'both') {\n                createVisualGrid(cellSize);\n            }\n            \n            // Initialize grid data structure\n            spatialStructure = {\n                cells: new Map(),\n                cellSize: cellSize,\n                checkCollision: function(position, dimensions) {\n                    stats.queries++;\n                    const minX = Math.floor(position.x / this.cellSize);\n                    const maxX = Math.floor((position.x + dimensions.length) / this.cellSize);\n                    const minZ = Math.floor(position.z / this.cellSize);\n                    const maxZ = Math.floor((position.z + dimensions.width) / this.cellSize);\n                    \n                    for (let x = minX; x <= maxX; x++) {\n                        for (let z = minZ; z <= maxZ; z++) {\n                            const key = `${x},${z}`;\n                            if (this.cells.has(key)) {\n                                const cellProducts = this.cells.get(key);\n                                for (let product of cellProducts) {\n                                    if (isOverlapping(position, dimensions, product.position, product.dimensions)) {\n                                        stats.collisions++;\n                                        return true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                },\n                addProduct: function(position, dimensions, productId) {\n                    const minX = Math.floor(position.x / this.cellSize);\n                    const maxX = Math.floor((position.x + dimensions.length) / this.cellSize);\n                    const minZ = Math.floor(position.z / this.cellSize);\n                    const maxZ = Math.floor((position.z + dimensions.width) / this.cellSize);\n                    \n                    for (let x = minX; x <= maxX; x++) {\n                        for (let z = minZ; z <= maxZ; z++) {\n                            const key = `${x},${z}`;\n                            if (!this.cells.has(key)) {\n                                this.cells.set(key, []);\n                            }\n                            this.cells.get(key).push({ position, dimensions, productId });\n                        }\n                    }\n                }\n            };\n        }\n\n        function createVisualGrid(cellSize) {\n            console.log('Creating visual grid with cellSize:', cellSize, 'visualizationMode:', visualizationMode);\n            const gridGroup = new THREE.Group();\n            gridGroup.name = 'spatialGrid';\n            \n            // Remove existing grid\n            const existingGrid = scene.getObjectByName('spatialGrid');\n            if (existingGrid) {\n                scene.remove(existingGrid);\n                console.log('Removed existing grid');\n            }\n            \n            const material = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });\n            \n            // Vertical lines\n            for (let x = -PALLET_SIZE.length/2; x <= PALLET_SIZE.length/2; x += cellSize) {\n                const geometry = new THREE.BufferGeometry().setFromPoints([\n                    new THREE.Vector3(x, PALLET_SIZE.height, -PALLET_SIZE.width/2),\n                    new THREE.Vector3(x, PALLET_SIZE.height, PALLET_SIZE.width/2)\n                ]);\n                const line = new THREE.Line(geometry, material);\n                gridGroup.add(line);\n            }\n            \n            // Horizontal lines\n            for (let z = -PALLET_SIZE.width/2; z <= PALLET_SIZE.width/2; z += cellSize) {\n                const geometry = new THREE.BufferGeometry().setFromPoints([\n                    new THREE.Vector3(-PALLET_SIZE.length/2, PALLET_SIZE.height, z),\n                    new THREE.Vector3(PALLET_SIZE.length/2, PALLET_SIZE.height, z)\n                ]);\n                const line = new THREE.Line(geometry, material);\n                gridGroup.add(line);\n            }\n            \n            scene.add(gridGroup);\n            console.log('Added grid to scene with', gridGroup.children.length, 'lines');\n        }\n\n        function initializeCornerPoints() {\n            spatialStructure = {\n                corners: [{ x: -PALLET_SIZE.length/2, y: PALLET_SIZE.height, z: -PALLET_SIZE.width/2 }],\n                visualCorners: [],\n                checkCollision: function(position, dimensions) {\n                    stats.queries++;\n                    for (let placed of placedProducts) {\n                        if (isOverlapping(position, dimensions, placed.position, placed.dimensions)) {\n                            stats.collisions++;\n                            return true;\n                        }\n                    }\n                    return false;\n                },\n                addProduct: function(position, dimensions, productId) {\n                    // Remove blocked corners\n                    this.corners = this.corners.filter(corner => \n                        !isPointInside(corner, position, dimensions)\n                    );\n                    \n                    // Add new corners\n                    const newCorners = [\n                        { x: position.x + dimensions.length, y: position.y, z: position.z },\n                        { x: position.x, y: position.y + dimensions.height, z: position.z },\n                        { x: position.x, y: position.y, z: position.z + dimensions.width }\n                    ];\n                    \n                    this.corners.push(...newCorners);\n                    this.updateVisualCorners();\n                },\n                updateVisualCorners: function() {\n                    // Remove existing corner visualizations\n                    this.visualCorners.forEach(corner => scene.remove(corner));\n                    this.visualCorners = [];\n                    \n                    if (visualizationMode === 'spatial' || visualizationMode === 'both') {\n                        this.corners.forEach(corner => {\n                            const geometry = new THREE.SphereGeometry(2, 8, 6);\n                            const material = new THREE.MeshBasicMaterial({ color: 0x2196F3 });\n                            const sphere = new THREE.Mesh(geometry, material);\n                            sphere.position.set(corner.x, corner.y, corner.z);\n                            this.visualCorners.push(sphere);\n                            scene.add(sphere);\n                        });\n                    }\n                }\n            };\n            spatialStructure.updateVisualCorners();\n        }\n\n        function initializeOctree() {\n            // Simplified octree implementation\n            spatialStructure = {\n                bounds: {\n                    min: { x: -PALLET_SIZE.length/2, y: 0, z: -PALLET_SIZE.width/2 },\n                    max: { x: PALLET_SIZE.length/2, y: 200, z: PALLET_SIZE.width/2 }\n                },\n                products: [],\n                checkCollision: function(position, dimensions) {\n                    stats.queries++;\n                    for (let product of this.products) {\n                        if (isOverlapping(position, dimensions, product.position, product.dimensions)) {\n                            stats.collisions++;\n                            return true;\n                        }\n                    }\n                    return false;\n                },\n                addProduct: function(position, dimensions, productId) {\n                    this.products.push({ position, dimensions, productId });\n                }\n            };\n        }\n\n        function initializeSpatialHash() {\n            spatialStructure = {\n                buckets: new Map(),\n                bucketSize: 25,\n                hash: function(x, y, z) {\n                    const hx = Math.floor(x / this.bucketSize);\n                    const hy = Math.floor(y / this.bucketSize);\n                    const hz = Math.floor(z / this.bucketSize);\n                    return `${hx},${hy},${hz}`;\n                },\n                checkCollision: function(position, dimensions) {\n                    stats.queries++;\n                    const relevantBuckets = this.getRelevantBuckets(position, dimensions);\n                    \n                    for (let bucketKey of relevantBuckets) {\n                        if (this.buckets.has(bucketKey)) {\n                            for (let product of this.buckets.get(bucketKey)) {\n                                if (isOverlapping(position, dimensions, product.position, product.dimensions)) {\n                                    stats.collisions++;\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                },\n                getRelevantBuckets: function(position, dimensions) {\n                    const buckets = new Set();\n                    const minX = position.x;\n                    const maxX = position.x + dimensions.length;\n                    const minY = position.y;\n                    const maxY = position.y + dimensions.height;\n                    const minZ = position.z;\n                    const maxZ = position.z + dimensions.width;\n                    \n                    for (let x = minX; x <= maxX; x += this.bucketSize) {\n                        for (let y = minY; y <= maxY; y += this.bucketSize) {\n                            for (let z = minZ; z <= maxZ; z += this.bucketSize) {\n                                buckets.add(this.hash(x, y, z));\n                            }\n                        }\n                    }\n                    return buckets;\n                },\n                addProduct: function(position, dimensions, productId) {\n                    const relevantBuckets = this.getRelevantBuckets(position, dimensions);\n                    \n                    for (let bucketKey of relevantBuckets) {\n                        if (!this.buckets.has(bucketKey)) {\n                            this.buckets.set(bucketKey, []);\n                        }\n                        this.buckets.get(bucketKey).push({ position, dimensions, productId });\n                    }\n                }\n            };\n        }\n\n        // Utility functions\n        function isOverlapping(pos1, dim1, pos2, dim2) {\n            return pos1.x < pos2.x + dim2.length && pos1.x + dim1.length > pos2.x &&\n                   pos1.y < pos2.y + dim2.height && pos1.y + dim1.height > pos2.y &&\n                   pos1.z < pos2.z + dim2.width && pos1.z + dim1.width > pos2.z;\n        }\n\n        function isPointInside(point, position, dimensions) {\n            return point.x >= position.x && point.x <= position.x + dimensions.length &&\n                   point.y >= position.y && point.y <= position.y + dimensions.height &&\n                   point.z >= position.z && point.z <= position.z + dimensions.width;\n        }\n\n        function isValidPosition(position, dimensions) {\n            // Check pallet bounds\n            if (position.x < -PALLET_SIZE.length/2 || position.x + dimensions.length > PALLET_SIZE.length/2 ||\n                position.z < -PALLET_SIZE.width/2 || position.z + dimensions.width > PALLET_SIZE.width/2) {\n                return false;\n            }\n            \n            // Check collision using spatial structure\n            if (spatialStructure && spatialStructure.checkCollision) {\n                return !spatialStructure.checkCollision(position, dimensions);\n            } else {\n                // Linear search fallback\n                stats.queries++;\n                for (let placed of placedProducts) {\n                    if (isOverlapping(position, dimensions, placed.position, placed.dimensions)) {\n                        stats.collisions++;\n                        return false;\n                    }\n                }\n            }\n            \n            return true;\n        }\n\n        // Algorithm implementations\n        async function firstFitAlgorithm() {\n            for (let product of products) {\n                if (product.placed) continue;\n                \n                updateCurrentOperation(`Placing product ${product.id} (FirstFit)`);\n                \n                let placed = false;\n                const step = 10;\n                \n                for (let x = -PALLET_SIZE.length/2; x <= PALLET_SIZE.length/2 - product.dimensions.length && !placed; x += step) {\n                    for (let z = -PALLET_SIZE.width/2; z <= PALLET_SIZE.width/2 - product.dimensions.width && !placed; z += step) {\n                        const position = { x, y: PALLET_SIZE.height, z };\n                        \n                        // Show candidate position\n                        await showCandidatePosition(position, product.dimensions);\n                        \n                        if (isValidPosition(position, product.dimensions)) {\n                            await placeProduct(product, position);\n                            placed = true;\n                        }\n                    }\n                }\n                \n                if (!placed) {\n                    console.log(`Could not place product ${product.id}`);\n                }\n                \n                if (isPaused) {\n                    await waitForResume();\n                }\n            }\n        }\n\n        async function bottomLeftFillAlgorithm() {\n            for (let product of products) {\n                if (product.placed) continue;\n                \n                updateCurrentOperation(`Placing product ${product.id} (Bottom-Left Fill)`);\n                \n                let bestPosition = null;\n                let minX = Infinity, minZ = Infinity;\n                \n                const step = 5;\n                \n                for (let x = -PALLET_SIZE.length/2; x <= PALLET_SIZE.length/2 - product.dimensions.length; x += step) {\n                    for (let z = -PALLET_SIZE.width/2; z <= PALLET_SIZE.width/2 - product.dimensions.width; z += step) {\n                        // Find lowest possible Y position\n                        let y = PALLET_SIZE.height;\n                        for (let placed of placedProducts) {\n                            if (x < placed.position.x + placed.dimensions.length && \n                                x + product.dimensions.length > placed.position.x &&\n                                z < placed.position.z + placed.dimensions.width && \n                                z + product.dimensions.width > placed.position.z) {\n                                y = Math.max(y, placed.position.y + placed.dimensions.height);\n                            }\n                        }\n                        \n                        const position = { x, y, z };\n                        \n                        if (isValidPosition(position, product.dimensions)) {\n                            // Choose bottom-left-most position\n                            if (x < minX || (x === minX && z < minZ)) {\n                                bestPosition = position;\n                                minX = x;\n                                minZ = z;\n                            }\n                        }\n                    }\n                }\n                \n                if (bestPosition) {\n                    await showCandidatePosition(bestPosition, product.dimensions);\n                    await placeProduct(product, bestPosition);\n                } else {\n                    console.log(`Could not place product ${product.id}`);\n                }\n                \n                if (isPaused) {\n                    await waitForResume();\n                }\n            }\n        }\n\n        async function skylineAlgorithm() {\n            let skyline = [{ x: -PALLET_SIZE.length/2, z: -PALLET_SIZE.width/2, width: PALLET_SIZE.width, length: PALLET_SIZE.length, height: PALLET_SIZE.height }];\n            \n            for (let product of products) {\n                if (product.placed) continue;\n                \n                updateCurrentOperation(`Placing product ${product.id} (3D Skyline)`);\n                \n                let bestPosition = null;\n                let bestSegment = null;\n                let minWaste = Infinity;\n                \n                for (let segment of skyline) {\n                    if (segment.length >= product.dimensions.length && segment.width >= product.dimensions.width) {\n                        const position = { x: segment.x, y: segment.height, z: segment.z };\n                        \n                        if (isValidPosition(position, product.dimensions)) {\n                            const waste = (segment.length * segment.width) - (product.dimensions.length * product.dimensions.width);\n                            if (waste < minWaste) {\n                                bestPosition = position;\n                                bestSegment = segment;\n                                minWaste = waste;\n                            }\n                        }\n                    }\n                }\n                \n                if (bestPosition) {\n                    await showCandidatePosition(bestPosition, product.dimensions);\n                    await placeProduct(product, bestPosition);\n                    updateSkyline(skyline, bestSegment, bestPosition, product.dimensions);\n                } else {\n                    console.log(`Could not place product ${product.id}`);\n                }\n                \n                if (isPaused) {\n                    await waitForResume();\n                }\n            }\n        }\n\n        async function cornerPointsAlgorithm() {\n            // Ensure corner points structure is initialized\n            if (!spatialStructure || !spatialStructure.corners) {\n                currentSpatialMethod = 'corners';\n                initializeSpatialStructures();\n            }\n            \n            if (!spatialStructure || !spatialStructure.corners) {\n                console.error('Corner points structure not initialized');\n                return;\n            }\n            \n            for (let product of products) {\n                if (product.placed) continue;\n                \n                updateCurrentOperation(`Placing product ${product.id} (Corner Points)`);\n                \n                let bestPosition = null;\n                let bestCorner = null;\n                \n                // Sort corners by preference (bottom-left-front first)\n                const sortedCorners = [...spatialStructure.corners].sort((a, b) => {\n                    if (a.y !== b.y) return a.y - b.y;\n                    if (a.x !== b.x) return a.x - b.x;\n                    return a.z - b.z;\n                });\n                \n                for (let corner of sortedCorners) {\n                    const position = { x: corner.x, y: corner.y, z: corner.z };\n                    \n                    if (isValidPosition(position, product.dimensions)) {\n                        bestPosition = position;\n                        bestCorner = corner;\n                        break;\n                    }\n                }\n                \n                if (bestPosition) {\n                    await showCandidatePosition(bestPosition, product.dimensions);\n                    await placeProduct(product, bestPosition);\n                } else {\n                    console.log(`Could not place product ${product.id}`);\n                }\n                \n                if (isPaused) {\n                    await waitForResume();\n                }\n            }\n        }\n\n        function updateSkyline(skyline, usedSegment, position, dimensions) {\n            // Remove used segment\n            const index = skyline.indexOf(usedSegment);\n            skyline.splice(index, 1);\n            \n            // Add new segments around the placed product\n            const newHeight = position.y + dimensions.height;\n            \n            // Top segment\n            skyline.push({\n                x: position.x,\n                z: position.z,\n                width: dimensions.width,\n                length: dimensions.length,\n                height: newHeight\n            });\n            \n            // Right segment (if there's remaining space)\n            if (position.x + dimensions.length < usedSegment.x + usedSegment.length) {\n                skyline.push({\n                    x: position.x + dimensions.length,\n                    z: usedSegment.z,\n                    width: usedSegment.width,\n                    length: usedSegment.x + usedSegment.length - (position.x + dimensions.length),\n                    height: usedSegment.height\n                });\n            }\n            \n            // Back segment (if there's remaining space)\n            if (position.z + dimensions.width < usedSegment.z + usedSegment.width) {\n                skyline.push({\n                    x: position.x,\n                    z: position.z + dimensions.width,\n                    width: usedSegment.z + usedSegment.width - (position.z + dimensions.width),\n                    length: dimensions.length,\n                    height: usedSegment.height\n                });\n            }\n        }\n\n        async function showCandidatePosition(position, dimensions) {\n            // Remove previous candidate\n            const existing = scene.getObjectByName('candidate');\n            if (existing) {\n                scene.remove(existing);\n            }\n            \n            // Create candidate visualization\n            const geometry = new THREE.BoxGeometry(dimensions.length, dimensions.height, dimensions.width);\n            const material = new THREE.MeshBasicMaterial({ \n                color: 0xFFC107, \n                transparent: true, \n                opacity: 0.5,\n                wireframe: true\n            });\n            const candidate = new THREE.Mesh(geometry, material);\n            candidate.name = 'candidate';\n            candidate.position.set(\n                position.x + dimensions.length / 2,\n                position.y + dimensions.height / 2,\n                position.z + dimensions.width / 2\n            );\n            scene.add(candidate);\n            \n            await sleep(animationSpeed / 4);\n        }\n\n        async function placeProduct(product, position) {\n            // Remove candidate\n            const candidate = scene.getObjectByName('candidate');\n            if (candidate) {\n                scene.remove(candidate);\n            }\n            \n            // Create product mesh\n            const geometry = new THREE.BoxGeometry(\n                product.dimensions.length,\n                product.dimensions.height,\n                product.dimensions.width\n            );\n            const material = new THREE.MeshLambertMaterial({ color: product.dimensions.color });\n            const mesh = new THREE.Mesh(geometry, material);\n            \n            mesh.position.set(\n                position.x + product.dimensions.length / 2,\n                position.y + product.dimensions.height / 2,\n                position.z + product.dimensions.width / 2\n            );\n            \n            mesh.castShadow = true;\n            mesh.receiveShadow = true;\n            \n            // Add wireframe\n            const wireframe = new THREE.WireframeGeometry(geometry);\n            const line = new THREE.LineSegments(wireframe);\n            line.material.color.setHex(0x000000);\n            line.position.copy(mesh.position);\n            \n            scene.add(mesh);\n            scene.add(line);\n            \n            // Update data structures\n            product.placed = true;\n            product.mesh = mesh;\n            product.position = position;\n            \n            placedProducts.push({\n                position: position,\n                dimensions: product.dimensions,\n                productId: product.id\n            });\n            \n            // Update spatial structure\n            if (spatialStructure && spatialStructure.addProduct) {\n                spatialStructure.addProduct(position, product.dimensions, product.id);\n            }\n            \n            // Update statistics\n            stats.placedCount++;\n            updateStats();\n            \n            await sleep(animationSpeed);\n        }\n\n        function updateStats() {\n            document.getElementById('placedCount').textContent = stats.placedCount;\n            document.getElementById('totalCount').textContent = stats.totalCount;\n            document.getElementById('queries').textContent = stats.queries;\n            document.getElementById('collisions').textContent = stats.collisions;\n            \n            // Calculate utilization\n            const placedVolume = placedProducts.reduce((sum, p) => \n                sum + (p.dimensions.length * p.dimensions.width * p.dimensions.height), 0);\n            const totalVolume = PALLET_SIZE.length * PALLET_SIZE.width * 150; // Max height\n            const utilization = totalVolume > 0 ? ((placedVolume / totalVolume) * 100).toFixed(1) : 0;\n            document.getElementById('utilization').textContent = utilization + '%';\n        }\n\n        function updateCurrentOperation(operation) {\n            document.getElementById('currentOp').textContent = operation;\n        }\n\n        function sleep(ms) {\n            return new Promise(resolve => setTimeout(resolve, ms));\n        }\n\n        async function waitForResume() {\n            while (isPaused && isRunning) {\n                await sleep(100);\n            }\n        }\n\n        // Event handlers\n        document.getElementById('startBtn').addEventListener('click', async () => {\n            if (isRunning) return;\n            \n            isRunning = true;\n            isPaused = false;\n            document.getElementById('startBtn').disabled = true;\n            document.getElementById('pauseBtn').disabled = false;\n            document.getElementById('resetBtn').disabled = true;\n            \n            try {\n                switch (currentAlgorithm) {\n                    case 'firstfit':\n                        await firstFitAlgorithm();\n                        break;\n                    case 'bottomleft':\n                        await bottomLeftFillAlgorithm();\n                        break;\n                    case 'skyline':\n                        await skylineAlgorithm();\n                        break;\n                    case 'corners':\n                        await cornerPointsAlgorithm();\n                        break;\n                }\n                updateCurrentOperation('Completed');\n            } catch (error) {\n                console.error('Algorithm error:', error);\n                updateCurrentOperation('Error occurred');\n            }\n            \n            isRunning = false;\n            isPaused = false;\n            document.getElementById('startBtn').disabled = false;\n            document.getElementById('pauseBtn').disabled = true;\n            document.getElementById('pauseBtn').textContent = 'Pause';\n            document.getElementById('resetBtn').disabled = false;\n        });\n\n        document.getElementById('pauseBtn').addEventListener('click', () => {\n            isPaused = !isPaused;\n            document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';\n        });\n\n        document.getElementById('resetBtn').addEventListener('click', () => {\n            reset();\n        });\n\n        document.getElementById('stepBtn').addEventListener('click', async () => {\n            if (isRunning) return;\n            \n            // Find next unplaced product and place it\n            const nextProduct = products.find(p => !p.placed);\n            if (nextProduct) {\n                isRunning = true;\n                document.getElementById('stepBtn').disabled = true;\n                \n                // Use first fit for single step\n                let placed = false;\n                const step = 10;\n                \n                for (let x = -PALLET_SIZE.length/2; x <= PALLET_SIZE.length/2 - nextProduct.dimensions.length && !placed; x += step) {\n                    for (let z = -PALLET_SIZE.width/2; z <= PALLET_SIZE.width/2 - nextProduct.dimensions.width && !placed; z += step) {\n                        let y = PALLET_SIZE.height;\n                        \n                        // Find stacking height\n                        for (let placed of placedProducts) {\n                            if (x < placed.position.x + placed.dimensions.length && \n                                x + nextProduct.dimensions.length > placed.position.x &&\n                                z < placed.position.z + placed.dimensions.width && \n                                z + nextProduct.dimensions.width > placed.position.z) {\n                                y = Math.max(y, placed.position.y + placed.dimensions.height);\n                            }\n                        }\n                        \n                        const position = { x, y, z };\n                        \n                        if (isValidPosition(position, nextProduct.dimensions)) {\n                            await showCandidatePosition(position, nextProduct.dimensions);\n                            await placeProduct(nextProduct, position);\n                            placed = true;\n                        }\n                    }\n                }\n                \n                if (!placed) {\n                    updateCurrentOperation(`Could not place product ${nextProduct.id}`);\n                }\n                \n                isRunning = false;\n                document.getElementById('stepBtn').disabled = false;\n            }\n        });\n\n        // Algorithm selection\n        document.querySelectorAll('.algorithm-btn').forEach(btn => {\n            btn.addEventListener('click', () => {\n                if (isRunning) return;\n                \n                document.querySelectorAll('.algorithm-btn').forEach(b => b.classList.remove('active'));\n                btn.classList.add('active');\n                currentAlgorithm = btn.dataset.algorithm;\n                \n                // If switching to corner points algorithm, ensure we use corner points spatial method\n                if (currentAlgorithm === 'corners') {\n                    currentSpatialMethod = 'corners';\n                    document.getElementById('spatialMethod').value = 'corners';\n                }\n                \n                reset();\n            });\n        });\n\n        // Spatial method selection\n        document.getElementById('spatialMethod').addEventListener('change', (e) => {\n            if (isRunning) return;\n            currentSpatialMethod = e.target.value;\n            reset();\n        });\n\n        // Visualization mode selection\n        document.querySelectorAll('.mode-btn').forEach(btn => {\n            btn.addEventListener('click', () => {\n                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));\n                btn.classList.add('active');\n                visualizationMode = btn.dataset.mode;\n                \n                // Auto-switch to appropriate spatial method for visualization\n                if (btn.dataset.mode === 'spatial' || btn.dataset.mode === 'both') {\n                    if (currentSpatialMethod === 'linear') {\n                        currentSpatialMethod = 'grid';\n                        document.getElementById('spatialMethod').value = 'grid';\n                    }\n                }\n                \n                initializeSpatialStructures();\n            });\n        });\n\n        // Speed control\n        document.getElementById('speed').addEventListener('input', (e) => {\n            animationSpeed = parseInt(e.target.value);\n        });\n\n        // Grid resolution control\n        document.getElementById('gridRes').addEventListener('input', (e) => {\n            if (isRunning) return;\n            gridResolution = parseInt(e.target.value);\n            if (currentSpatialMethod === 'grid') {\n                initializeSpatialStructures();\n            }\n        });\n\n        function reset() {\n            // Stop any running algorithm\n            isRunning = false;\n            isPaused = false;\n            \n            // Clear placed products and their wireframes\n            placedProducts.forEach(product => {\n                if (product.mesh) {\n                    scene.remove(product.mesh);\n                }\n            });\n            \n            // Remove all product meshes from scene\n            const objectsToRemove = [];\n            scene.traverse((child) => {\n                if (child.isMesh && child !== pallet) {\n                    objectsToRemove.push(child);\n                }\n                if (child.isLineSegments && child.parent === scene) {\n                    objectsToRemove.push(child);\n                }\n            });\n            objectsToRemove.forEach(obj => scene.remove(obj));\n            \n            placedProducts = [];\n            \n            // Reset products\n            products.forEach(product => {\n                product.placed = false;\n                product.mesh = null;\n                product.position = null;\n            });\n            \n            // Remove candidate and other temporary objects\n            const candidate = scene.getObjectByName('candidate');\n            if (candidate) scene.remove(candidate);\n            \n            // Reset statistics\n            stats.placedCount = 0;\n            stats.queries = 0;\n            stats.collisions = 0;\n            updateStats();\n            updateCurrentOperation('Ready');\n            \n            // Reinitialize spatial structures\n            initializeSpatialStructures();\n            \n            // Reset buttons\n            document.getElementById('startBtn').disabled = false;\n            document.getElementById('pauseBtn').disabled = true;\n            document.getElementById('resetBtn').disabled = false;\n            document.getElementById('pauseBtn').textContent = 'Pause';\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n            renderer.render(scene, camera);\n        }\n\n        // Handle window resize\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n\n        // Initialize everything when page loads\n        document.addEventListener('DOMContentLoaded', () => {\n            document.getElementById('loading').style.display = 'block';\n            \n            // Simulate loading time for Three.js\n            setTimeout(() => {\n                document.getElementById('loading').style.display = 'none';\n                initThreeJS();\n            }, 1000);\n        });\n    </script>\n</body>\n</html>",
  "id": "threejs-packing-visualizer-claude-4",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.756Z",
    "model": "claude-4",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, astronomy, architecture."
  }
}
