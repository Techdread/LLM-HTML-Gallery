{
  "id": "planet-threejs-planet-Qwen3-Coder-30B-A3B-Instruct",
  "title": "Procedurally Generated 3D Planet",
  "htmlContent": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Procedurally Generated 3D Planet</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background: #000;\n        }\n\n        canvas {\n            display: block;\n        }\n\n        #info {\n            position: absolute;\n            top: 10px;\n            width: 100%;\n            text-align: center;\n            color: white;\n            font-family: Arial, sans-serif;\n            font-size: 14px;\n            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);\n            pointer-events: none;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"info\">Procedurally Generated 3D Planet<br>Use mouse to rotate view | Scroll to zoom | Space to pause/resume\n        rotation</div>\n\n    <!-- Import map for three.js and its addons -->\n    <script type=\"importmap\">\n    {\n      \"imports\": {\n        \"three\": \"https://unpkg.com/three@0.165.0/build/three.module.js\",\n        \"three/addons/\": \"https://unpkg.com/three@0.165.0/examples/jsm/\"\n      }\n    }\n  </script>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\n        // Main variables\n        let scene, camera, renderer, controls;\n        let planet, atmosphere, clouds;\n        let clock = new THREE.Clock();\n        let rotationSpeed = 0.002;\n        let isRotating = true;\n\n        // Noise function for terrain generation\n        const noise = new ImprovedNoise();\n\n        init();\n        animate();\n\n        function init() {\n            // Create scene\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(0x000814);\n\n            // Create camera\n            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);\n            camera.position.z = 5;\n\n            // Create renderer\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.setPixelRatio(window.devicePixelRatio);\n            document.body.appendChild(renderer.domElement);\n\n            // Add orbit controls\n            controls = new OrbitControls(camera, renderer.domElement);\n            controls.enableDamping = true;\n            controls.dampingFactor = 0.05;\n            controls.screenSpacePanning = false;\n            controls.minDistance = 2.5;\n            controls.maxDistance = 10;\n\n            // Add lighting\n            setupLighting();\n\n            // Create planet with terrain\n            createPlanet();\n\n            // Create atmosphere\n            createAtmosphere();\n\n            // Create clouds\n            createClouds();\n\n            // Add event listeners\n            window.addEventListener('resize', onWindowResize, false);\n            window.addEventListener('keydown', onKeyDown, false);\n\n            // Add stars in background\n            createStars();\n        }\n\n        function setupLighting() {\n            // Ambient light for overall illumination\n            const ambientLight = new THREE.AmbientLight(0x333333);\n            scene.add(ambientLight);\n\n            // Directional light (sun)\n            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);\n            sunLight.position.set(5, 3, 5);\n            sunLight.castShadow = true;\n            scene.add(sunLight);\n\n            // Hemisphere light for more natural lighting\n            const hemisphereLight = new THREE.HemisphereLight(0x80deea, 0x4caf50, 0.2);\n            scene.add(hemisphereLight);\n        }\n\n        function createPlanet() {\n            // Create planet geometry with high detail\n            const geometry = new THREE.SphereGeometry(1, 64, 64);\n\n            // Modify vertices for terrain using noise\n            modifyTerrain(geometry);\n\n            // Create custom shader material for the planet surface\n            const material = new THREE.ShaderMaterial({\n                uniforms: {\n                    time: { value: 0 },\n                    waterColor: { value: new THREE.Color(0x1e88e5) },\n                    landColor: { value: new THREE.Color(0x4caf50) },\n                    sandColor: { value: new THREE.Color(0xffc107) },\n                    snowColor: { value: new THREE.Color(0xffffff) }\n                },\n                vertexShader: `\n                    uniform float time;\n                    varying vec3 vNormal;\n                    varying vec3 vPosition;\n                    \n                    void main() {\n                        vNormal = normalize(normalMatrix * normal);\n                        vPosition = position;\n                        \n                        // Apply displacement based on noise\n                        float displacement = 0.05 * sin(position.x * 10.0 + time) * \n                                           sin(position.y * 10.0 + time) * \n                                           sin(position.z * 10.0 + time);\n                        \n                        vec3 newPosition = position + normal * displacement;\n                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n                    }\n                `,\n                fragmentShader: `\n                    uniform float time;\n                    uniform vec3 waterColor;\n                    uniform vec3 landColor;\n                    uniform vec3 sandColor;\n                    uniform vec3 snowColor;\n                    \n                    varying vec3 vNormal;\n                    varying vec3 vPosition;\n                    \n                    void main() {\n                        // Calculate elevation based on position\n                        float elevation = length(vPosition);\n                        \n                        // Normalize normal for lighting calculations\n                        vec3 normal = normalize(vNormal);\n                        \n                        // Create biome-based coloring\n                        vec3 color;\n                        \n                        if (elevation < 0.95) {\n                            // Water - deep blue\n                            color = waterColor;\n                        } else if (elevation > 1.02) {\n                            // Snow caps at high elevations\n                            color = snowColor;\n                        } else {\n                            // Land with biomes based on latitude and elevation\n                            float lat = asin(vPosition.y);\n                            float latFactor = abs(lat / (3.14159 / 2.0));\n                            \n                            if (latFactor > 0.8) {\n                                // Tundra/ice regions\n                                color = snowColor * 0.8;\n                            } else if (latFactor > 0.6 && elevation < 1.01) {\n                                // Desert regions\n                                color = sandColor;\n                            } else if (elevation > 1.01) {\n                                // Mountain peaks\n                                color = mix(snowColor, landColor, 0.5);\n                            } else {\n                                // Forest/land regions\n                                color = landColor;\n                            }\n                        }\n                        \n                        // Add some lighting variation\n                        float lightIntensity = max(dot(normal, vec3(0.2, 1.0, 0.2)), 0.1);\n                        color *= lightIntensity;\n                        \n                        gl_FragColor = vec4(color, 1.0);\n                    }\n                `,\n                wireframe: false,\n                side: THREE.DoubleSide\n            });\n\n            planet = new THREE.Mesh(geometry, material);\n            scene.add(planet);\n        }\n\n        function modifyTerrain(geometry) {\n            const vertices = geometry.attributes.position.array;\n\n            // Apply noise to create terrain features\n            for (let i = 0; i < vertices.length; i += 3) {\n                const x = vertices[i];\n                const y = vertices[i + 1];\n                const z = vertices[i + 2];\n\n                // Normalize coordinates for noise function\n                const nx = x * 0.5;\n                const ny = y * 0.5;\n                const nz = z * 0.5;\n\n                // Generate terrain using multiple octaves of noise\n                let displacement = 0;\n                let amplitude = 1;\n                let frequency = 1;\n\n                for (let o = 0; o < 4; o++) {\n                    displacement += noise.noise(nx * frequency, ny * frequency, nz * frequency) * amplitude;\n                    amplitude *= 0.5;\n                    frequency *= 2;\n                }\n\n                // Apply displacement to vertex\n                const scale = 1 + displacement * 0.3;\n                vertices[i] *= scale;\n                vertices[i + 1] *= scale;\n                vertices[i + 2] *= scale;\n            }\n\n            geometry.attributes.position.needsUpdate = true;\n            geometry.computeVertexNormals();\n        }\n\n        function createAtmosphere() {\n            // Create atmosphere as a slightly larger sphere\n            const atmosphereGeometry = new THREE.SphereGeometry(1.05, 32, 32);\n\n            const atmosphereMaterial = new THREE.ShaderMaterial({\n                uniforms: {\n                    lightDirection: { value: new THREE.Vector3(5, 3, 5).normalize() }\n                },\n                vertexShader: `\n                    varying vec3 vNormal;\n                    varying vec3 vPosition;\n                    \n                    void main() {\n                        vNormal = normalize(normalMatrix * normal);\n                        vPosition = position;\n                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                    }\n                `,\n                fragmentShader: `\n                    uniform vec3 lightDirection;\n                    varying vec3 vNormal;\n                    varying vec3 vPosition;\n                    \n                    void main() {\n                        // Create atmospheric glow effect\n                        float atmosphereDensity = pow(1.0 - max(dot(vNormal, vec3(0.0, 0.0, 1.0)), 0.0), 4.0);\n                        \n                        // Blue atmosphere color with gradient\n                        vec3 atmosphereColor = mix(vec3(0.2, 0.6, 1.0), vec3(0.0, 0.0, 0.0), atmosphereDensity);\n                        \n                        // Add glow effect near the edges\n                        float edgeFactor = 1.0 - smoothstep(0.95, 1.0, length(vPosition));\n                        atmosphereColor += vec3(0.2, 0.4, 0.8) * edgeFactor;\n                        \n                        gl_FragColor = vec4(atmosphereColor, atmosphereDensity * 0.6);\n                    }\n                `,\n                transparent: true,\n                side: THREE.BackSide\n            });\n\n            atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);\n            scene.add(atmosphere);\n        }\n\n        function createClouds() {\n            // Create cloud layer as a slightly larger sphere\n            const cloudGeometry = new THREE.SphereGeometry(1.03, 32, 32);\n\n            const cloudMaterial = new THREE.ShaderMaterial({\n                uniforms: {\n                    time: { value: 0 },\n                    cloudColor: { value: new THREE.Color(0xffffff) }\n                },\n                vertexShader: `\n                    uniform float time;\n                    varying vec3 vNormal;\n                    varying vec3 vPosition;\n                    \n                    void main() {\n                        vNormal = normalize(normalMatrix * normal);\n                        vPosition = position;\n                        \n                        // Add some cloud movement\n                        vec3 newPosition = position + normal * sin(position.x * 5.0 + time) * 0.01;\n                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n                    }\n                `,\n                fragmentShader: `\n                    uniform float time;\n                    uniform vec3 cloudColor;\n                    varying vec3 vNormal;\n                    varying vec3 vPosition;\n                    \n                    void main() {\n                        // Create procedural cloud pattern\n                        float noise = sin(vPosition.x * 20.0 + time) * \n                                     sin(vPosition.y * 20.0 + time) * \n                                     sin(vPosition.z * 20.0 + time);\n                        \n                        // Add some variation to clouds\n                        float cloudDensity = smoothstep(0.3, 1.0, noise);\n                        \n                        if (cloudDensity < 0.5) {\n                            discard;\n                        }\n                        \n                        vec3 color = mix(cloudColor * 0.8, cloudColor, cloudDensity);\n                        \n                        // Add some edge softening\n                        float alpha = smoothstep(0.4, 1.0, cloudDensity);\n                        \n                        gl_FragColor = vec4(color, alpha * 0.7);\n                    }\n                `,\n                transparent: true,\n                side: THREE.DoubleSide\n            });\n\n            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);\n            scene.add(clouds);\n        }\n\n        function createStars() {\n            // Create starfield background\n            const starGeometry = new THREE.BufferGeometry();\n            const starMaterial = new THREE.PointsMaterial({\n                color: 0xffffff,\n                size: 0.02,\n                transparent: true\n            });\n\n            const starVertices = [];\n            for (let i = 0; i < 10000; i++) {\n                const x = (Math.random() - 0.5) * 2000;\n                const y = (Math.random() - 0.5) * 2000;\n                const z = (Math.random() - 0.5) * 2000;\n                starVertices.push(x, y, z);\n            }\n\n            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));\n            const stars = new THREE.Points(starGeometry, starMaterial);\n            scene.add(stars);\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        function onKeyDown(event) {\n            switch (event.code) {\n                case 'Space':\n                    isRotating = !isRotating;\n                    break;\n                case 'ArrowUp':\n                    rotationSpeed = Math.min(rotationSpeed + 0.001, 0.02);\n                    break;\n                case 'ArrowDown':\n                    rotationSpeed = Math.max(rotationSpeed - 0.001, 0.001);\n                    break;\n            }\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            const delta = clock.getDelta();\n            const time = clock.getElapsedTime();\n\n            // Update materials with time for animations\n            if (planet && planet.material) {\n                planet.material.uniforms.time.value = time;\n            }\n            if (clouds && clouds.material) {\n                clouds.material.uniforms.time.value = time;\n            }\n\n            // Rotate the planet and atmosphere\n            if (isRotating) {\n                if (planet) planet.rotation.y += rotationSpeed;\n                if (atmosphere) atmosphere.rotation.y += rotationSpeed * 0.9;\n                if (clouds) clouds.rotation.y += rotationSpeed * 1.2;\n            }\n\n            controls.update();\n            renderer.render(scene, camera);\n        }\n    </script>\n</body>\n\n</html>",
  "metadata": {
    "model": "Qwen3-Coder-30B-A3B-Instruct",
    "prompt": "Objective: Create a realistic, procedurally generated 3D planet in Three.js that includes detailed terrain, biomes, and atmospheric effects. The planet should be visually appealing and optimized for performance. Requirements: 1. PlanetGeometry: • Use a spherical geometry (THREE.SphereGeometry) as the base. •Modify the sphere's surface with noise (e.g., Perlin or Simplex) to create realistic terrain features like mountains, valleys, and plains. 2. Biomes and Textures: •Divide the planet into biomes (e.g., deserts, forests, tundras, oceans) based on elevation and latitude. • Use procedural color mapping to assign textures based on biome (e.g., sandy textures for deserts, green for forests, blue for oceans). •Consider blending textures smoothly between biomes. 3. Atmosphere: • Add asemi-transparent atmospheric layer around the planet using THREE.ShaderMaterial. • Implement a gradient color effect for the atmosphere(e.g., blue near the surface fading to black in space). • Add subtle glow effects for realism. 4. Lighting: • Use a directional light to simulate the sun, casting realistic shadows across the planet's surface. • Add ambient lighting to ensure details are visible in shadowed regions. • Implement dynamic lighting to simulate day-night cycles as the planet rotates. 5. Water: • Include procedural oceans with reflective and slightly transparent materials. • Simulate waves or surface distortion using shaders or displacement maps. 6. Clouds: • Add a separate spherical layer above the surface for clouds. • Use procedural noise to generate cloud patterns. •Animate the clouds to move slowly across the planet. 7. Rotation: • Make the planet rotate on its axis at a realistic speed. • Allow the user to pause or adjust the rotation speed. 8. Camera and Interaction: • Position the camera to give a clear view of the planet. • Allow the user to zoom in and out and rotate the camera. Use template bellow.",
    "timestamp": "2025-08-02T20:09:24.576Z",
    "tags": [
      "threejs"
    ],
    "description": "Our procedural planet generator starts with a noise-displaced THREE.SphereGeometry to sculpt mountains, valleys, and plains, then classifies each point by elevation and latitude into biomes—desert, forest, tundra, ocean—and smoothly blends their shaders; sea-level areas get a reflective, wave-distorted water material, a surrounding ShaderMaterial layer creates a blue-to-black atmospheric glow, and a drifting noise-based cloud sphere adds realism; a directional “sun” light plus ambient fill drive a day-night cycle as the globe rotates, all viewable via an orbiting, zoomable camera with performance optimizations like LOD and frustum culling."
  }
}
