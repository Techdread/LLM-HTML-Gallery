{
  "title": "Interactive Gravity Well Simulation",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Interactive Gravity Well Simulation</title>\r\n    <script src=\"https://cdn.tailwindcss.com\"></script>\r\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js\"></script>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n            font-family: 'Inter', sans-serif;\r\n            background-color: #111827;\r\n            /* bg-gray-900 */\r\n            color: #f3f4f6;\r\n            /* text-gray-100 */\r\n        }\r\n\r\n        #container {\r\n            width: 100vw;\r\n            height: 100vh;\r\n            display: block;\r\n        }\r\n\r\n        #controls {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            background-color: rgba(17, 24, 39, 0.8);\r\n            /* bg-gray-900 with opacity */\r\n            padding: 15px;\r\n            border-radius: 8px;\r\n            border: 1px solid #374151;\r\n            /* border-gray-700 */\r\n            color: #f3f4f6;\r\n            /* text-gray-100 */\r\n            max-width: 300px;\r\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\r\n        }\r\n\r\n        #controls label,\r\n        #controls button,\r\n        #controls input {\r\n            display: block;\r\n            margin-bottom: 8px;\r\n            font-size: 0.875rem;\r\n            /* text-sm */\r\n        }\r\n\r\n        #controls input[type=\"range\"],\r\n        #controls input[type=\"number\"] {\r\n            width: 100%;\r\n            background-color: #374151;\r\n            /* bg-gray-700 */\r\n            border-radius: 4px;\r\n            padding: 2px;\r\n            accent-color: #3b82f6;\r\n            /* accent-blue-500 */\r\n        }\r\n\r\n        #controls input[type=\"number\"] {\r\n            padding: 4px 8px;\r\n            border: 1px solid #4b5563;\r\n            /* border-gray-600 */\r\n        }\r\n\r\n        #controls button {\r\n            background-color: #3b82f6;\r\n            /* bg-blue-600 */\r\n            color: white;\r\n            padding: 8px 12px;\r\n            border: none;\r\n            border-radius: 6px;\r\n            cursor: pointer;\r\n            transition: background-color 0.2s;\r\n            width: 100%;\r\n            margin-top: 10px;\r\n        }\r\n\r\n        #controls button:hover {\r\n            background-color: #2563eb;\r\n            /* bg-blue-700 */\r\n        }\r\n\r\n        #controls h3 {\r\n            font-weight: 600;\r\n            /* font-semibold */\r\n            margin-bottom: 10px;\r\n            border-bottom: 1px solid #4b5563;\r\n            /* border-gray-600 */\r\n            padding-bottom: 5px;\r\n        }\r\n\r\n        #instructions {\r\n            position: absolute;\r\n            bottom: 10px;\r\n            left: 10px;\r\n            background-color: rgba(17, 24, 39, 0.8);\r\n            /* bg-gray-900 with opacity */\r\n            padding: 10px;\r\n            border-radius: 8px;\r\n            border: 1px solid #374151;\r\n            /* border-gray-700 */\r\n            color: #d1d5db;\r\n            /* text-gray-300 */\r\n            font-size: 0.8rem;\r\n            max-width: 350px;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"container\"></div>\r\n    <div id=\"controls\">\r\n        <h3>Controls</h3>\r\n\r\n        <label for=\"massInput\">Massive Object Mass (1-100):</label>\r\n        <input type=\"range\" id=\"massInput\" min=\"1\" max=\"100\" value=\"20\">\r\n        <button id=\"addMassiveObject\">Add Massive Object (Click Grid)</button>\r\n        <p id=\"addMassiveObjectStatus\" class=\"text-xs text-yellow-400 mt-1\"></p>\r\n\r\n        <hr class=\"border-gray-600 my-3\">\r\n\r\n        <label for=\"particleVelocityX\">Particle Velocity X (-1 to 1):</label>\r\n        <input type=\"range\" id=\"particleVelocityX\" min=\"-1\" max=\"1\" value=\"0.5\" step=\"0.1\">\r\n        <label for=\"particleVelocityZ\">Particle Velocity Z (-1 to 1):</label>\r\n        <input type=\"range\" id=\"particleVelocityZ\" min=\"-1\" max=\"1\" value=\"0\" step=\"0.1\">\r\n        <label for=\"particleSpeed\">Particle Speed (0.1 - 5):</label>\r\n        <input type=\"range\" id=\"particleSpeed\" min=\"0.1\" max=\"5\" value=\"1\" step=\"0.1\">\r\n        <button id=\"launchParticle\">Launch Particle (Click Grid)</button>\r\n        <p id=\"launchParticleStatus\" class=\"text-xs text-yellow-400 mt-1\"></p>\r\n\r\n        <hr class=\"border-gray-600 my-3\">\r\n\r\n        <button id=\"resetSimulation\">Reset Simulation</button>\r\n    </div>\r\n\r\n    <div id=\"instructions\">\r\n        <strong>Instructions:</strong>\r\n        <ul>\r\n            <li>Orbit: Left Mouse Button + Drag</li>\r\n            <li>Zoom: Mouse Wheel</li>\r\n            <li>Pan: Right Mouse Button + Drag</li>\r\n            <li>Add Massive Object: Set mass, click button, then click on the grid.</li>\r\n            <li>Launch Particle: Set velocity/speed, click button, then click on the grid for starting position.</li>\r\n        </ul>\r\n    </div>\r\n\r\n    <script type=\"module\">\r\n        // Ensure Three.js and OrbitControls are loaded\r\n        if (typeof THREE === 'undefined' || typeof THREE.OrbitControls === 'undefined') {\r\n            console.error(\"Three.js or OrbitControls failed to load.\");\r\n            // Display error message to user\r\n            document.getElementById('container').innerHTML = '<p style=\"color: red; padding: 20px;\">Error: Could not load required 3D libraries. Please check your internet connection and try refreshing.</p>';\r\n        } else {\r\n            // --- Global Variables ---\r\n            let scene, camera, renderer, controls;\r\n            let gridMesh, originalVertices;\r\n            const massiveObjects = []; // Store { mesh: THREE.Mesh, mass: number, position: THREE.Vector3 }\r\n            const particles = []; // Store { mesh: THREE.Mesh, velocity: THREE.Vector3, trail: THREE.Line, trailIndex: number }\r\n            const raycaster = new THREE.Raycaster();\r\n            const mouse = new THREE.Vector2();\r\n            let isAddingMassiveObject = false;\r\n            let isLaunchingParticle = false;\r\n            const G = 0.1; // Gravitational constant (scaled for simulation)\r\n            const timeStep = 0.05; // Simulation time step\r\n            const GRID_SIZE = 50;\r\n            const GRID_SEGMENTS = 50;\r\n            const maxTrailPoints = 200; // Maximum points in a particle's trail\r\n\r\n            // --- Initialization ---\r\n            function init() {\r\n                // Scene\r\n                scene = new THREE.Scene();\r\n                scene.background = new THREE.Color(0x111827); // bg-gray-900\r\n\r\n                // Camera\r\n                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n                camera.position.set(0, 30, 30); // Position camera above the grid\r\n\r\n                // Renderer\r\n                renderer = new THREE.WebGLRenderer({ antialias: true });\r\n                renderer.setSize(window.innerWidth, window.innerHeight);\r\n                document.getElementById('container').appendChild(renderer.domElement);\r\n\r\n                // Lighting\r\n                const ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);\r\n                scene.add(ambientLight);\r\n                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\r\n                directionalLight.position.set(1, 1, 0.5).normalize();\r\n                scene.add(directionalLight);\r\n\r\n                // Grid (Spacetime Fabric)\r\n                // PlaneGeometry is created in its local XY plane.\r\n                // Width along X, Height along Y, Normal along Z.\r\n                const gridGeometry = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, GRID_SEGMENTS, GRID_SEGMENTS);\r\n                const gridMaterial = new THREE.MeshPhongMaterial({\r\n                    color: 0x3b82f6, // blue-500\r\n                    wireframe: true,\r\n                    side: THREE.DoubleSide\r\n                });\r\n                gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);\r\n                // Rotate to be horizontal in world XZ plane.\r\n                // Original local X -> World X\r\n                // Original local Y -> World Z (after rotation, -Y local becomes +Z world)\r\n                // Original local Z -> World Y (after rotation, +Z local becomes +Y world)\r\n                gridMesh.rotation.x = -Math.PI / 2;\r\n                scene.add(gridMesh);\r\n\r\n                // Store original vertices for deformation calculations\r\n                // These are in the local coordinate system of the grid.\r\n                // For PlaneGeometry, original z-coordinates are 0.\r\n                originalVertices = gridGeometry.attributes.position.array.slice(); // Create a copy\r\n\r\n                // Controls\r\n                controls = new THREE.OrbitControls(camera, renderer.domElement);\r\n                controls.enableDamping = true; // Smooth camera movement\r\n                controls.dampingFactor = 0.05;\r\n                controls.screenSpacePanning = false; // Pan parallel to the grid plane\r\n                controls.maxPolarAngle = Math.PI / 2 - 0.05; // Prevent camera going below grid\r\n                controls.minDistance = 5;\r\n                controls.maxDistance = 100;\r\n\r\n                // Event Listeners\r\n                window.addEventListener('resize', onWindowResize, false);\r\n                renderer.domElement.addEventListener('click', onCanvasClick, false);\r\n                setupUIListeners();\r\n\r\n                // Start Animation Loop\r\n                animate();\r\n            }\r\n\r\n            // --- UI Event Listeners ---\r\n            function setupUIListeners() {\r\n                const addMassiveObjectButton = document.getElementById('addMassiveObject');\r\n                const launchParticleButton = document.getElementById('launchParticle');\r\n                const resetSimulationButton = document.getElementById('resetSimulation');\r\n                const addMassiveObjectStatus = document.getElementById('addMassiveObjectStatus');\r\n                const launchParticleStatus = document.getElementById('launchParticleStatus');\r\n\r\n                addMassiveObjectButton.addEventListener('click', () => {\r\n                    isAddingMassiveObject = true;\r\n                    isLaunchingParticle = false;\r\n                    addMassiveObjectStatus.textContent = \"Click on the grid to place the object.\";\r\n                    launchParticleStatus.textContent = \"\";\r\n                    renderer.domElement.style.cursor = 'crosshair';\r\n                });\r\n\r\n                launchParticleButton.addEventListener('click', () => {\r\n                    isLaunchingParticle = true;\r\n                    isAddingMassiveObject = false;\r\n                    launchParticleStatus.textContent = \"Click on the grid for particle start position.\";\r\n                    addMassiveObjectStatus.textContent = \"\";\r\n                    renderer.domElement.style.cursor = 'crosshair';\r\n                });\r\n\r\n                resetSimulationButton.addEventListener('click', resetSimulation);\r\n            }\r\n\r\n            // --- Event Handlers ---\r\n            function onWindowResize() {\r\n                camera.aspect = window.innerWidth / window.innerHeight;\r\n                camera.updateProjectionMatrix();\r\n                renderer.setSize(window.innerWidth, window.innerHeight);\r\n            }\r\n\r\n            function onCanvasClick(event) {\r\n                if (!isAddingMassiveObject && !isLaunchingParticle) return;\r\n\r\n                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\r\n                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\r\n                raycaster.setFromCamera(mouse, camera);\r\n                const intersects = raycaster.intersectObject(gridMesh);\r\n\r\n                if (intersects.length > 0) {\r\n                    const intersectPoint = intersects[0].point; // World coordinates\r\n\r\n                    if (isAddingMassiveObject) {\r\n                        addMassiveObject(intersectPoint);\r\n                        isAddingMassiveObject = false;\r\n                        document.getElementById('addMassiveObjectStatus').textContent = \"\";\r\n                        renderer.domElement.style.cursor = 'default';\r\n                    } else if (isLaunchingParticle) {\r\n                        launchParticle(intersectPoint);\r\n                        isLaunchingParticle = false;\r\n                        document.getElementById('launchParticleStatus').textContent = \"\";\r\n                        renderer.domElement.style.cursor = 'default';\r\n                    }\r\n                } else {\r\n                    if (isAddingMassiveObject) document.getElementById('addMassiveObjectStatus').textContent = \"Click failed. Aim for the grid.\";\r\n                    if (isLaunchingParticle) document.getElementById('launchParticleStatus').textContent = \"Click failed. Aim for the grid.\";\r\n                }\r\n            }\r\n\r\n            // --- Object Creation ---\r\n            function addMassiveObject(position) { // position is world coordinates from click\r\n                const mass = parseFloat(document.getElementById('massInput').value);\r\n                if (isNaN(mass) || mass <= 0) {\r\n                    console.warn(\"Invalid mass value provided.\");\r\n                    return;\r\n                }\r\n                const radius = Math.cbrt(mass) * 0.3;\r\n                const geometry = new THREE.SphereGeometry(radius, 32, 16);\r\n                const material = new THREE.MeshPhongMaterial({ color: 0xffcc00 });\r\n                const mesh = new THREE.Mesh(geometry, material);\r\n\r\n                // Set mesh position in world coordinates\r\n                mesh.position.copy(position);\r\n                // The click 'position' y is on the grid (approx 0). Elevate sphere by its radius.\r\n                mesh.position.y = radius;\r\n\r\n                scene.add(mesh);\r\n                massiveObjects.push({ mesh, mass, position: mesh.position.clone() }); // Store world position\r\n\r\n                deformGrid();\r\n            }\r\n\r\n            function launchParticle(startPosition) { // startPosition is world coordinates\r\n                const velX = parseFloat(document.getElementById('particleVelocityX').value);\r\n                const velZ = parseFloat(document.getElementById('particleVelocityZ').value);\r\n                const speed = parseFloat(document.getElementById('particleSpeed').value);\r\n\r\n                if (isNaN(velX) || isNaN(velZ) || isNaN(speed) || speed <= 0) {\r\n                    console.warn(\"Invalid particle velocity or speed.\");\r\n                    return;\r\n                }\r\n\r\n                const geometry = new THREE.SphereGeometry(0.2, 8, 8);\r\n                const material = new THREE.MeshBasicMaterial({ color: 0xffffff });\r\n                const mesh = new THREE.Mesh(geometry, material);\r\n                mesh.position.copy(startPosition);\r\n                mesh.position.y = 0.5; // Start slightly above the grid's visual plane\r\n\r\n                const velocity = new THREE.Vector3(velX, 0, velZ).normalize().multiplyScalar(speed);\r\n\r\n                const trailMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa, linewidth: 1 });\r\n                const trailGeometry = new THREE.BufferGeometry();\r\n                const trailPositions = new Float32Array(maxTrailPoints * 3);\r\n                trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));\r\n                const trail = new THREE.Line(trailGeometry, trailMaterial);\r\n                trail.frustumCulled = false;\r\n                scene.add(trail);\r\n\r\n                scene.add(mesh);\r\n                particles.push({ mesh, velocity, trail, trailIndex: 0 });\r\n            }\r\n\r\n            // --- Simulation Logic ---\r\n            function deformGrid() {\r\n                const positions = gridMesh.geometry.attributes.position; // Local coordinates\r\n                const vertex = new THREE.Vector3(); // For local vertex calculation\r\n                const worldVertex = new THREE.Vector3(); // For world vertex calculation\r\n\r\n                for (let i = 0; i < positions.count; i++) {\r\n                    // Get original local vertex (original local z is 0)\r\n                    vertex.fromArray(originalVertices, i * 3);\r\n\r\n                    // Transform original local vertex to world space for distance calculation\r\n                    worldVertex.copy(vertex).applyMatrix4(gridMesh.matrixWorld);\r\n                    // After rotation: worldX = localX, worldY = localZ, worldZ = -localY\r\n                    // So worldVertex.y is initially 0 because original localZ is 0.\r\n\r\n                    let totalDeformation = 0; // This will be the change in local Z, affecting world Y\r\n\r\n                    massiveObjects.forEach(obj => {\r\n                        // obj.position is the world position of the massive object\r\n                        // Calculate distance in the world XZ plane (the plane of the grid)\r\n                        const dx = worldVertex.x - obj.position.x;\r\n                        const dz = worldVertex.z - obj.position.z; // worldVertex.z is -localY\r\n                        const distanceSq = dx * dx + dz * dz;\r\n\r\n                        const minDistanceSq = 0.1;\r\n                        if (distanceSq > minDistanceSq) {\r\n                            // Negative deformation for downward curve (negative world Y)\r\n                            const deformation = - (G * obj.mass * 5) / distanceSq;\r\n                            totalDeformation += Math.max(deformation, -GRID_SIZE / 4);\r\n                        } else {\r\n                            totalDeformation += -GRID_SIZE / 4; // Max deformation\r\n                        }\r\n                    });\r\n\r\n                    // Apply deformation to the LOCAL Z-coordinate of the vertex.\r\n                    // Original local Z (vertex.z) is 0.\r\n                    // Since worldY = localZ (due to grid rotation), changing localZ deforms along worldY.\r\n                    // A negative totalDeformation makes localZ negative, thus worldY negative (downwards).\r\n                    positions.setZ(i, Math.max(vertex.z + totalDeformation, -GRID_SIZE / 2));\r\n                }\r\n\r\n                positions.needsUpdate = true;\r\n                gridMesh.geometry.computeVertexNormals(); // Recalculate normals for correct lighting\r\n            }\r\n\r\n\r\n            function updateParticles() {\r\n                const particlesToRemove = [];\r\n\r\n                particles.forEach((particle, index) => {\r\n                    const acceleration = new THREE.Vector3(0, 0, 0);\r\n\r\n                    massiveObjects.forEach(obj => {\r\n                        const direction = new THREE.Vector3().subVectors(obj.position, particle.mesh.position);\r\n                        const distanceSq = direction.lengthSq();\r\n                        const objRadius = obj.mesh.geometry.parameters.radius;\r\n                        const minForceDistanceSq = objRadius * objRadius * 1.1;\r\n\r\n                        if (distanceSq > minForceDistanceSq) {\r\n                            const forceMagnitude = (G * obj.mass) / distanceSq;\r\n                            const forceVector = direction.normalize().multiplyScalar(forceMagnitude);\r\n                            acceleration.add(forceVector);\r\n                        } else if (distanceSq < objRadius * objRadius) {\r\n                            if (!particlesToRemove.includes(index)) {\r\n                                particlesToRemove.push(index);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    particle.velocity.add(acceleration.multiplyScalar(timeStep));\r\n                    particle.mesh.position.add(particle.velocity.clone().multiplyScalar(timeStep));\r\n\r\n                    if (!particlesToRemove.includes(index)) {\r\n                        const trailPositionsAttr = particle.trail.geometry.attributes.position;\r\n                        const currentPointIndex = (particle.trailIndex % maxTrailPoints) * 3;\r\n\r\n                        trailPositionsAttr.array[currentPointIndex] = particle.mesh.position.x;\r\n                        trailPositionsAttr.array[currentPointIndex + 1] = particle.mesh.position.y;\r\n                        trailPositionsAttr.array[currentPointIndex + 2] = particle.mesh.position.z;\r\n\r\n                        const nextPointIndex = ((particle.trailIndex + 1) % maxTrailPoints) * 3;\r\n                        trailPositionsAttr.array[nextPointIndex] = particle.mesh.position.x;\r\n                        trailPositionsAttr.array[nextPointIndex + 1] = particle.mesh.position.y;\r\n                        trailPositionsAttr.array[nextPointIndex + 2] = particle.mesh.position.z;\r\n\r\n                        particle.trailIndex++;\r\n\r\n                        if (particle.trailIndex < maxTrailPoints) {\r\n                            particle.trail.geometry.setDrawRange(0, particle.trailIndex + 1);\r\n                        } else {\r\n                            particle.trail.geometry.setDrawRange(0, maxTrailPoints);\r\n                        }\r\n                        trailPositionsAttr.needsUpdate = true;\r\n                    }\r\n\r\n                    const boundary = GRID_SIZE * 1.5;\r\n                    if (Math.abs(particle.mesh.position.x) > boundary ||\r\n                        Math.abs(particle.mesh.position.z) > boundary ||\r\n                        Math.abs(particle.mesh.position.y) > boundary * 2) {\r\n                        if (!particlesToRemove.includes(index)) {\r\n                            particlesToRemove.push(index);\r\n                        }\r\n                    }\r\n                });\r\n\r\n                for (let i = particlesToRemove.length - 1; i >= 0; i--) {\r\n                    const indexToRemove = particlesToRemove[i];\r\n                    const particleToRemove = particles[indexToRemove];\r\n\r\n                    scene.remove(particleToRemove.mesh);\r\n                    scene.remove(particleToRemove.trail);\r\n\r\n                    particleToRemove.mesh.geometry.dispose();\r\n                    particleToRemove.mesh.material.dispose();\r\n                    particleToRemove.trail.geometry.dispose();\r\n                    particleToRemove.trail.material.dispose();\r\n\r\n                    particles.splice(indexToRemove, 1);\r\n                }\r\n            }\r\n\r\n            // --- Reset ---\r\n            function resetSimulation() {\r\n                massiveObjects.forEach(obj => {\r\n                    scene.remove(obj.mesh);\r\n                    if (obj.mesh.geometry) obj.mesh.geometry.dispose();\r\n                    if (obj.mesh.material) obj.mesh.material.dispose();\r\n                });\r\n                massiveObjects.length = 0;\r\n\r\n                particles.forEach(p => {\r\n                    scene.remove(p.mesh);\r\n                    scene.remove(p.trail);\r\n                    if (p.mesh.geometry) p.mesh.geometry.dispose();\r\n                    if (p.mesh.material) p.mesh.material.dispose();\r\n                    if (p.trail.geometry) p.trail.geometry.dispose();\r\n                    if (p.trail.material) p.trail.material.dispose();\r\n                });\r\n                particles.length = 0;\r\n\r\n                const positions = gridMesh.geometry.attributes.position;\r\n                positions.array.set(originalVertices); // Restore original local vertex data\r\n                positions.needsUpdate = true;\r\n                gridMesh.geometry.computeVertexNormals();\r\n\r\n                isAddingMassiveObject = false;\r\n                isLaunchingParticle = false;\r\n                document.getElementById('addMassiveObjectStatus').textContent = \"\";\r\n                document.getElementById('launchParticleStatus').textContent = \"\";\r\n                renderer.domElement.style.cursor = 'default';\r\n                console.log(\"Simulation Reset\");\r\n            }\r\n\r\n            // --- Animation Loop ---\r\n            function animate() {\r\n                requestAnimationFrame(animate);\r\n                updateParticles();\r\n                controls.update();\r\n                renderer.render(scene, camera);\r\n            }\r\n\r\n            // --- Start ---\r\n            window.onload = init;\r\n        }\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "gravity-sim-gemini-pro-2-5",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "Particles",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.949Z",
    "model": "gemini-pro-2.5",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, particles, webgl, shaders, astronomy, simulation, architecture."
  }
}
