{
  "title": "Voxel Fire Spread Simulation",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Voxel Fire Spread Simulation</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n            background: linear-gradient(to bottom, #1a2980, #26d0ce);\r\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n        }\r\n\r\n        canvas {\r\n            display: block;\r\n        }\r\n\r\n        #ui-container {\r\n            position: absolute;\r\n            top: 20px;\r\n            left: 20px;\r\n            background: rgba(0, 0, 0, 0.7);\r\n            padding: 15px;\r\n            border-radius: 10px;\r\n            color: white;\r\n            max-width: 300px;\r\n            backdrop-filter: blur(5px);\r\n            z-index: 10;\r\n        }\r\n\r\n        #ui-container h1 {\r\n            margin-top: 0;\r\n            font-size: 1.5em;\r\n            color: #ff9a00;\r\n        }\r\n\r\n        #ui-container p {\r\n            margin: 8px 0;\r\n            font-size: 0.9em;\r\n            line-height: 1.4;\r\n        }\r\n\r\n        button {\r\n            background: #ff6b00;\r\n            color: white;\r\n            border: none;\r\n            padding: 10px 15px;\r\n            border-radius: 5px;\r\n            cursor: pointer;\r\n            font-weight: bold;\r\n            margin: 5px 0;\r\n            width: 100%;\r\n            transition: background 0.3s;\r\n        }\r\n\r\n        button:hover {\r\n            background: #ff8c00;\r\n        }\r\n\r\n        .slider-container {\r\n            margin: 10px 0;\r\n        }\r\n\r\n        label {\r\n            display: block;\r\n            margin-bottom: 5px;\r\n        }\r\n\r\n        input[type=\"range\"] {\r\n            width: 100%;\r\n        }\r\n\r\n        #stats {\r\n            position: absolute;\r\n            bottom: 20px;\r\n            right: 20px;\r\n            background: rgba(0, 0, 0, 0.7);\r\n            padding: 10px 15px;\r\n            border-radius: 10px;\r\n            color: white;\r\n            font-size: 0.9em;\r\n            backdrop-filter: blur(5px);\r\n            z-index: 10;\r\n        }\r\n\r\n        #instructions {\r\n            position: absolute;\r\n            bottom: 20px;\r\n            left: 20px;\r\n            background: rgba(0, 0, 0, 0.7);\r\n            padding: 10px 15px;\r\n            border-radius: 10px;\r\n            color: white;\r\n            font-size: 0.9em;\r\n            max-width: 300px;\r\n            backdrop-filter: blur(5px);\r\n            z-index: 10;\r\n        }\r\n\r\n        #title {\r\n            position: absolute;\r\n            top: 20px;\r\n            width: 100%;\r\n            text-align: center;\r\n            color: white;\r\n            font-size: 2em;\r\n            text-shadow: 0 0 10px rgba(0, 0, 0, 0.7);\r\n            z-index: 10;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"title\">Voxel Fire Spread Simulation</div>\r\n\r\n    <div id=\"ui-container\">\r\n        <h1>Fire Simulation Controls</h1>\r\n        <p>Click on flammable voxels to ignite them. Watch the fire spread!</p>\r\n        <button id=\"reset-btn\">Reset Simulation</button>\r\n        <div class=\"slider-container\">\r\n            <label for=\"spread-rate\">Fire Spread Rate: <span id=\"spread-value\">50%</span></label>\r\n            <input type=\"range\" id=\"spread-rate\" min=\"1\" max=\"100\" value=\"50\">\r\n        </div>\r\n        <div class=\"slider-container\">\r\n            <label for=\"fuel\">Fuel Duration: <span id=\"fuel-value\">3</span>s</label>\r\n            <input type=\"range\" id=\"fuel\" min=\"1\" max=\"10\" value=\"3\">\r\n        </div>\r\n        <p>Fire spreads to adjacent flammable voxels with a probability based on the spread rate.</p>\r\n    </div>\r\n\r\n    <div id=\"stats\">\r\n        <div>Fires: <span id=\"fire-count\">0</span></div>\r\n        <div>Flammable: <span id=\"flammable-count\">0</span></div>\r\n        <div>Burnt: <span id=\"burnt-count\">0</span></div>\r\n    </div>\r\n\r\n    <div id=\"instructions\">\r\n        <p><strong>Controls:</strong></p>\r\n        <p>• Left-click: Ignite voxel</p>\r\n        <p>• Right-click + drag: Rotate camera</p>\r\n        <p>• Scroll: Zoom in/out</p>\r\n    </div>\r\n\r\n    <script type=\"importmap\">\r\n        {\r\n            \"imports\": {\r\n                \"three\": \"https://unpkg.com/three@0.165.0/build/three.module.js\",\r\n                \"three/addons/\": \"https://unpkg.com/three@0.165.0/examples/jsm/\"\r\n            }\r\n        }\r\n    </script>\r\n\r\n    <script type=\"module\">\r\n        import * as THREE from 'three';\r\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\n\r\n        // Scene setup\r\n        let scene, camera, renderer, controls;\r\n        let voxelGrid = [];\r\n        let smokeParticles = [];\r\n        let fireMaterial, burntMaterial, flammableMaterial;\r\n        let spreadRate = 0.5;\r\n        let fuelDuration = 3;\r\n        let stats = { fires: 0, flammable: 0, burnt: 0 };\r\n\r\n        // Initialize the scene\r\n        function init() {\r\n            // Scene\r\n            scene = new THREE.Scene();\r\n            scene.background = new THREE.Color(0x87CEEB);\r\n            scene.fog = new THREE.Fog(0x87CEEB, 15, 30);\r\n\r\n            // Camera\r\n            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n            camera.position.set(10, 10, 10);\r\n            camera.lookAt(0, 0, 0);\r\n\r\n            // Renderer\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            renderer.shadowMap.enabled = true;\r\n            document.body.appendChild(renderer.domElement);\r\n\r\n            // Controls\r\n            controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n\r\n            // Lighting\r\n            const ambientLight = new THREE.AmbientLight(0x404040, 1);\r\n            scene.add(ambientLight);\r\n\r\n            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\r\n            directionalLight.position.set(5, 10, 7);\r\n            directionalLight.castShadow = true;\r\n            directionalLight.shadow.mapSize.width = 1024;\r\n            directionalLight.shadow.mapSize.height = 1024;\r\n            scene.add(directionalLight);\r\n\r\n            // Create materials\r\n            createMaterials();\r\n\r\n            // Create voxel grid\r\n            createVoxelGrid(15, 15, 15);\r\n\r\n            // Add ground\r\n            const groundGeometry = new THREE.PlaneGeometry(30, 30);\r\n            const groundMaterial = new THREE.MeshStandardMaterial({\r\n                color: 0x2e8b57,\r\n                roughness: 0.9,\r\n                metalness: 0.1\r\n            });\r\n            const ground = new THREE.Mesh(groundGeometry, groundMaterial);\r\n            ground.rotation.x = -Math.PI / 2;\r\n            ground.position.y = -0.5;\r\n            ground.receiveShadow = true;\r\n            scene.add(ground);\r\n\r\n            // Add event listeners\r\n            window.addEventListener('resize', onWindowResize);\r\n            document.getElementById('reset-btn').addEventListener('click', resetSimulation);\r\n            document.getElementById('spread-rate').addEventListener('input', updateSpreadRate);\r\n            document.getElementById('fuel').addEventListener('input', updateFuelDuration);\r\n\r\n            // Raycaster for voxel interaction\r\n            const raycaster = new THREE.Raycaster();\r\n            const mouse = new THREE.Vector2();\r\n\r\n            document.addEventListener('click', (event) => {\r\n                // Calculate mouse position in normalized device coordinates\r\n                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\r\n                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\r\n\r\n                // Update the picking ray with the camera and mouse position\r\n                raycaster.setFromCamera(mouse, camera);\r\n\r\n                // Calculate objects intersecting the picking ray\r\n                const intersects = raycaster.intersectObjects(getVoxelMeshes(), true);\r\n\r\n                if (intersects.length > 0) {\r\n                    const voxel = intersects[0].object.userData.voxel;\r\n                    if (voxel && voxel.isFlammable && !voxel.isOnFire) {\r\n                        igniteVoxel(voxel);\r\n                    }\r\n                }\r\n            });\r\n\r\n            // Start animation\r\n            animate();\r\n        }\r\n\r\n        function createMaterials() {\r\n            fireMaterial = new THREE.MeshPhongMaterial({\r\n                color: 0xff4500,\r\n                emissive: 0xff8c00,\r\n                shininess: 30,\r\n                transparent: true,\r\n                opacity: 0.9\r\n            });\r\n\r\n            burntMaterial = new THREE.MeshPhongMaterial({\r\n                color: 0x2f4f4f,\r\n                shininess: 5\r\n            });\r\n\r\n            flammableMaterial = new THREE.MeshPhongMaterial({\r\n                color: 0x8b4513,\r\n                shininess: 10\r\n            });\r\n        }\r\n\r\n        function createVoxelGrid(width, height, depth) {\r\n            const voxelSize = 0.9;\r\n            const spacing = 1.1;\r\n\r\n            // Create a grid of voxels with some randomness\r\n            for (let x = 0; x < width; x++) {\r\n                voxelGrid[x] = [];\r\n                for (let y = 0; y < height; y++) {\r\n                    voxelGrid[x][y] = [];\r\n                    for (let z = 0; z < depth; z++) {\r\n                        // Only create voxels in the lower half of the grid\r\n                        if (y > 5 && Math.random() > 0.3) {\r\n                            const voxel = {\r\n                                position: new THREE.Vector3(\r\n                                    (x - width / 2) * spacing,\r\n                                    y * spacing,\r\n                                    (z - depth / 2) * spacing\r\n                                ),\r\n                                isFlammable: true,\r\n                                isOnFire: false,\r\n                                fuel: 0,\r\n                                neighbors: []\r\n                            };\r\n\r\n                            // Create mesh for voxel\r\n                            const geometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);\r\n                            const material = flammableMaterial;\r\n                            const mesh = new THREE.Mesh(geometry, material);\r\n                            mesh.position.copy(voxel.position);\r\n                            mesh.castShadow = true;\r\n                            mesh.receiveShadow = true;\r\n\r\n                            // Store reference to voxel in mesh\r\n                            mesh.userData.voxel = voxel;\r\n\r\n                            scene.add(mesh);\r\n                            voxel.mesh = mesh; // Store reference to mesh\r\n                            voxelGrid[x][y][z] = voxel;\r\n                        } else {\r\n                            voxelGrid[x][y][z] = null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Connect neighbors for fire spread logic\r\n            connectNeighbors();\r\n        }\r\n\r\n        function getVoxelMeshes() {\r\n            const meshes = [];\r\n            for (let x = 0; x < voxelGrid.length; x++) {\r\n                for (let y = 0; y < voxelGrid[x].length; y++) {\r\n                    for (let z = 0; z < voxelGrid[x][y].length; z++) {\r\n                        if (voxelGrid[x][y][z]) {\r\n                            meshes.push(voxelGrid[x][y][z].mesh);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return meshes;\r\n        }\r\n\r\n        function connectNeighbors() {\r\n            for (let x = 0; x < voxelGrid.length; x++) {\r\n                for (let y = 0; y < voxelGrid[x].length; y++) {\r\n                    for (let z = 0; z < voxelGrid[x][y].length; z++) {\r\n                        const voxel = voxelGrid[x][y][z];\r\n                        if (!voxel) continue;\r\n\r\n                        // Check all 6 neighbors (x, y, z)\r\n                        const directions = [\r\n                            [-1, 0, 0], [1, 0, 0],\r\n                            [0, -1, 0], [0, 1, 0],\r\n                            [0, 0, -1], [0, 0, 1]\r\n                        ];\r\n\r\n                        for (const dir of directions) {\r\n                            const nx = x + dir[0];\r\n                            const ny = y + dir[1];\r\n                            const nz = z + dir[2];\r\n\r\n                            if (nx >= 0 && nx < voxelGrid.length &&\r\n                                ny >= 0 && ny < voxelGrid[nx].length &&\r\n                                nz >= 0 && nz < voxelGrid[nx][ny].length) {\r\n\r\n                                const neighbor = voxelGrid[nx][ny][nz];\r\n                                if (neighbor && neighbor.isFlammable) {\r\n                                    voxel.neighbors.push(neighbor);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function igniteVoxel(voxel) {\r\n            if (!voxel.isFlammable) return;\r\n\r\n            voxel.isOnFire = true;\r\n            voxel.fuel = fuelDuration;\r\n            voxel.mesh.material = fireMaterial;\r\n\r\n            // Add smoke particles\r\n            createSmokeParticles(voxel.position);\r\n\r\n            updateStats();\r\n        }\r\n\r\n        function updateVoxelState(voxel) {\r\n            if (!voxel.isOnFire) return;\r\n\r\n            voxel.fuel -= 0.1;\r\n\r\n            if (voxel.fuel <= 0) {\r\n                voxel.isOnFire = false;\r\n                voxel.isFlammable = false;\r\n                voxel.mesh.material = burntMaterial;\r\n\r\n                // Remove smoke particles\r\n                removeSmokeParticles(voxel.position);\r\n            } else {\r\n                // Spread fire to neighbors\r\n                spreadFire(voxel);\r\n            }\r\n        }\r\n\r\n        function spreadFire(voxel) {\r\n            if (Math.random() > spreadRate) return;\r\n\r\n            for (const neighbor of voxel.neighbors) {\r\n                if (neighbor.isFlammable && !neighbor.isOnFire) {\r\n                    igniteVoxel(neighbor);\r\n                }\r\n            }\r\n        }\r\n\r\n        function createSmokeParticles(position) {\r\n            const particleCount = 100;\r\n            const particles = new THREE.BufferGeometry();\r\n            const positions = new Float32Array(particleCount * 3);\r\n            const colors = new Float32Array(particleCount * 3);\r\n\r\n            for (let i = 0; i < particleCount; i++) {\r\n                const i3 = i * 3;\r\n\r\n                // Position around the voxel\r\n                positions[i3] = position.x + (Math.random() - 0.5) * 0.5;\r\n                positions[i3 + 1] = position.y + 0.5 + Math.random() * 0.5;\r\n                positions[i3 + 2] = position.z + (Math.random() - 0.5) * 0.5;\r\n\r\n                // Color: gray to dark gray\r\n                const colorValue = 0.5 + Math.random() * 0.5;\r\n                colors[i3] = colorValue;\r\n                colors[i3 + 1] = colorValue;\r\n                colors[i3 + 2] = colorValue;\r\n            }\r\n\r\n            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));\r\n            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));\r\n\r\n            const particleMaterial = new THREE.PointsMaterial({\r\n                size: 0.1,\r\n                vertexColors: true,\r\n                transparent: true,\r\n                opacity: 0.7,\r\n                blending: THREE.AdditiveBlending\r\n            });\r\n\r\n            const particleSystem = new THREE.Points(particles, particleMaterial);\r\n            particleSystem.position.copy(position);\r\n            scene.add(particleSystem);\r\n\r\n            smokeParticles.push({\r\n                system: particleSystem,\r\n                position: position.clone(),\r\n                age: 0\r\n            });\r\n        }\r\n\r\n        function removeSmokeParticles(position) {\r\n            for (let i = smokeParticles.length - 1; i >= 0; i--) {\r\n                const particle = smokeParticles[i];\r\n                if (particle.position.distanceTo(position) < 2) {\r\n                    scene.remove(particle.system);\r\n                    smokeParticles.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        function updateSmokeParticles() {\r\n            for (let i = smokeParticles.length - 1; i >= 0; i--) {\r\n                const particle = smokeParticles[i];\r\n                particle.age += 0.05;\r\n\r\n                // Move particles upward and fade out\r\n                const positions = particle.system.geometry.attributes.position.array;\r\n                for (let j = 0; j < positions.length; j += 3) {\r\n                    positions[j + 1] += 0.02; // Upward movement\r\n                    positions[j] += (Math.random() - 0.5) * 0.01; // Slight horizontal drift\r\n                    positions[j + 2] += (Math.random() - 0.5) * 0.01;\r\n                }\r\n\r\n                particle.system.geometry.attributes.position.needsUpdate = true;\r\n\r\n                // Remove old particles\r\n                if (particle.age > 5) {\r\n                    scene.remove(particle.system);\r\n                    smokeParticles.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        function updateStats() {\r\n            stats.fires = 0;\r\n            stats.flammable = 0;\r\n            stats.burnt = 0;\r\n\r\n            for (let x = 0; x < voxelGrid.length; x++) {\r\n                for (let y = 0; y < voxelGrid[x].length; y++) {\r\n                    for (let z = 0; z < voxelGrid[x][y].length; z++) {\r\n                        const voxel = voxelGrid[x][y][z];\r\n                        if (!voxel) continue;\r\n\r\n                        if (voxel.isOnFire) stats.fires++;\r\n                        else if (voxel.isFlammable) stats.flammable++;\r\n                        else stats.burnt++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            document.getElementById('fire-count').textContent = stats.fires;\r\n            document.getElementById('flammable-count').textContent = stats.flammable;\r\n            document.getElementById('burnt-count').textContent = stats.burnt;\r\n        }\r\n\r\n        function resetSimulation() {\r\n            // Remove all smoke particles\r\n            for (const particle of smokeParticles) {\r\n                scene.remove(particle.system);\r\n            }\r\n            smokeParticles = [];\r\n\r\n            // Reset all voxels\r\n            for (let x = 0; x < voxelGrid.length; x++) {\r\n                for (let y = 0; y < voxelGrid[x].length; y++) {\r\n                    for (let z = 0; z < voxelGrid[x][y].length; z++) {\r\n                        const voxel = voxelGrid[x][y][z];\r\n                        if (!voxel) continue;\r\n\r\n                        voxel.isOnFire = false;\r\n                        voxel.isFlammable = true;\r\n                        voxel.fuel = 0;\r\n                        voxel.mesh.material = flammableMaterial;\r\n                    }\r\n                }\r\n            }\r\n\r\n            updateStats();\r\n        }\r\n\r\n        function updateSpreadRate() {\r\n            spreadRate = document.getElementById('spread-rate').value / 100;\r\n            document.getElementById('spread-value').textContent = spreadRate.toFixed(0) + '%';\r\n        }\r\n\r\n        function updateFuelDuration() {\r\n            fuelDuration = parseInt(document.getElementById('fuel').value);\r\n            document.getElementById('fuel-value').textContent = fuelDuration;\r\n        }\r\n\r\n        function onWindowResize() {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n\r\n            // Update controls\r\n            controls.update();\r\n\r\n            // Update voxel states\r\n            for (let x = 0; x < voxelGrid.length; x++) {\r\n                for (let y = 0; y < voxelGrid[x].length; y++) {\r\n                    for (let z = 0; z < voxelGrid[x][y].length; z++) {\r\n                        const voxel = voxelGrid[x][y][z];\r\n                        if (voxel && voxel.isOnFire) {\r\n                            updateVoxelState(voxel);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update smoke particles\r\n            updateSmokeParticles();\r\n\r\n            // Render scene\r\n            renderer.render(scene, camera);\r\n        }\r\n\r\n        // Start the application\r\n        init();\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "voxel-fire-qwen-coder-30b-a3b",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "Particles",
      "WebGL",
      "Shaders",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:58.112Z",
    "model": "qwen-coder-30b-a3b",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, particles, webgl, shaders, simulation, architecture."
  }
}
