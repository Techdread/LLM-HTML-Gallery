{
  "title": "Three.js Procedural Terrain",
  "htmlContent": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-B\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Three.js Procedural Terrain</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000;\n        }\n\n        canvas {\n            display: block;\n        }\n    </style>\n</head>\n\n<body>\n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://esm.sh/three@0.160.0\",\n                \"three/addons/\": \"https://esm.sh/three@0.160.0/examples/jsm/\",\n                \"simplex-noise\": \"https://esm.sh/simplex-noise@3.0.1\",\n                \"lil-gui\": \"https://esm.sh/lil-gui@0.19.1\"\n            }\n        }\n    </script>\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n        import SimplexNoise from 'simplex-noise';\n        import GUI from 'lil-gui';\n\n        let scene, camera, renderer, controls;\n        let terrainMesh;\n        let simplex;\n\n        const params = {\n            // Terrain\n            seed: 'threejs-terrain',\n            planeSize: 500,\n            segments: 150, // Higher for more detail, lower for performance\n            scale: 150, // Noise scale\n            octaves: 8,\n            persistence: 0.5,\n            lacunarity: 2.0,\n            heightMultiplier: 60,\n            flatness: 1.0, // Power exponent for height: >1 sharper peaks, <1 flatter valleys\n\n            // Dropoff (simple radial)\n            enableDropoff: true,\n            dropoffStart: 0.7, // Start dropoff at 70% of radius\n            dropoffStrength: 2.0, // How sharp the dropoff is\n\n            // Colors\n            snowColor: '#FFFFFF',\n            rockColor: '#808080',\n            grassColor: '#556B2F',\n            waterColor: '#4682B4', // For very low areas\n            snowLine: 0.65, // Normalized height\n            rockLine: 0.3,  // Normalized height\n            waterLine: 0.05, // Normalized height\n\n            // Atmosphere (Fog)\n            fogColor: '#d3d3d3', // Light gray, similar to video's sky\n            fogDensity: 0.0035,\n\n            // Lighting\n            sunColor: '#FFFFFF',\n            sunIntensity: 2.0,\n            ambientColor: '#505050',\n        };\n\n        let sunLight, ambientLight;\n\n        function init() {\n            // Scene\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(params.fogColor); // Match fog for seamlessness\n            updateFog();\n\n            // Camera\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);\n            camera.position.set(150, 100, 150);\n\n            // Renderer\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.shadowMap.enabled = true;\n            document.body.appendChild(renderer.domElement);\n\n            // Controls\n            controls = new OrbitControls(camera, renderer.domElement);\n            controls.enableDamping = true;\n            controls.dampingFactor = 0.05;\n\n            // Lights\n            sunLight = new THREE.DirectionalLight(new THREE.Color(params.sunColor), params.sunIntensity);\n            sunLight.position.set(100, 200, 100);\n            sunLight.castShadow = true;\n            sunLight.shadow.mapSize.width = 2048;\n            sunLight.shadow.mapSize.height = 2048;\n            sunLight.shadow.camera.near = 0.5;\n            sunLight.shadow.camera.far = 500;\n            sunLight.shadow.camera.left = -params.planeSize / 1.5;\n            sunLight.shadow.camera.right = params.planeSize / 1.5;\n            sunLight.shadow.camera.top = params.planeSize / 1.5;\n            sunLight.shadow.camera.bottom = -params.planeSize / 1.5;\n            scene.add(sunLight);\n            scene.add(sunLight.target); // Good practice\n\n            ambientLight = new THREE.AmbientLight(new THREE.Color(params.ambientColor));\n            scene.add(ambientLight);\n\n            // Initial terrain generation\n            generateTerrain();\n\n            // GUI\n            setupGUI();\n\n            // Event Listeners\n            window.addEventListener('resize', onWindowResize, false);\n\n            animate();\n        }\n\n        function fbm(x, y, simplexInstance) {\n            let total = 0;\n            let frequency = 1;\n            let amplitude = 1;\n            let maxValue = 0; // Used for normalizing to 0-1 range\n\n            for (let i = 0; i < params.octaves; i++) {\n                total += simplexInstance.noise2D(x * frequency / params.scale, y * frequency / params.scale) * amplitude;\n                maxValue += amplitude;\n                amplitude *= params.persistence;\n                frequency *= params.lacunarity;\n            }\n            return (total / maxValue + 1) / 2; // Normalize to 0-1\n        }\n\n        function generateTerrain() {\n            if (terrainMesh) {\n                scene.remove(terrainMesh);\n                terrainMesh.geometry.dispose();\n                terrainMesh.material.dispose();\n            }\n\n            simplex = new SimplexNoise(params.seed);\n\n            const geometry = new THREE.PlaneGeometry(params.planeSize, params.planeSize, params.segments, params.segments);\n            const positions = geometry.attributes.position;\n            const colors = [];\n\n            let minHeight = Infinity;\n            let maxHeight = -Infinity;\n            const heightData = [];\n\n            // First pass: calculate heights\n            for (let i = 0; i < positions.count; i++) {\n                const x = positions.getX(i);\n                const y = positions.getY(i); // This is actually z in world space for a horizontal plane\n\n                let noiseVal = fbm(x, y, simplex);\n\n                // Apply flatness (power function)\n                noiseVal = Math.pow(noiseVal, params.flatness);\n\n                let height = noiseVal * params.heightMultiplier;\n\n                // Radial dropoff\n                if (params.enableDropoff) {\n                    const distToCenter = Math.sqrt(x * x + y * y);\n                    const maxDist = params.planeSize * 0.5;\n                    const normalizedDist = distToCenter / maxDist;\n\n                    // Create a falloff curve based on distance from the center\n                    if (normalizedDist > params.dropoffStart) {\n                        // Remap the distance from the start of the dropoff to the edge to a 0-1 range\n                        const t = (normalizedDist - params.dropoffStart) / (1.0 - params.dropoffStart);\n                        // Apply a power function to control the steepness of the falloff\n                        const falloff = Math.pow(1.0 - t, params.dropoffStrength);\n                        height *= Math.max(0, falloff);\n                    }\n                }\n\n\n                heightData.push(height);\n                if (height < minHeight) minHeight = height;\n                if (height > maxHeight) maxHeight = height;\n            }\n\n            const heightRange = maxHeight - minHeight;\n\n            // Second pass: set vertex positions and colors\n            for (let i = 0; i < positions.count; i++) {\n                let currentHeight = heightData[i];\n                positions.setZ(i, currentHeight); // Plane is XY, so Z is height\n\n                // Normalize height for coloring\n                const normalizedHeight = heightRange > 0 ? (currentHeight - minHeight) / heightRange : 0.5;\n\n                let color = new THREE.Color();\n                if (normalizedHeight > params.snowLine) {\n                    color.set(params.snowColor);\n                } else if (normalizedHeight > params.rockLine) {\n                    // Blend between rock and snow\n                    const t = (normalizedHeight - params.rockLine) / (params.snowLine - params.rockLine);\n                    color.set(params.rockColor).lerp(new THREE.Color(params.snowColor), t);\n                } else if (normalizedHeight > params.waterLine) {\n                    // Blend between grass and rock\n                    const t = (normalizedHeight - params.waterLine) / (params.rockLine - params.waterLine);\n                    color.set(params.grassColor).lerp(new THREE.Color(params.rockColor), t);\n                } else {\n                    // Blend between water and grass\n                    const t = normalizedHeight / params.waterLine;\n                    color.set(params.waterColor).lerp(new THREE.Color(params.grassColor), t);\n                }\n                colors.push(color.r, color.g, color.b);\n            }\n\n            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n            geometry.computeVertexNormals();\n\n            const material = new THREE.MeshStandardMaterial({\n                vertexColors: true,\n                roughness: 0.8,\n                metalness: 0.1,\n                // wireframe: true, // For debugging\n            });\n\n            terrainMesh = new THREE.Mesh(geometry, material);\n            terrainMesh.rotation.x = -Math.PI / 2; // Rotate to be horizontal\n            terrainMesh.receiveShadow = true;\n            terrainMesh.castShadow = true; // Can be performance intensive for high segment counts\n            scene.add(terrainMesh);\n        }\n\n        function updateFog() {\n            if (scene.fog) {\n                scene.fog.color.set(params.fogColor);\n                scene.fog.density = params.fogDensity;\n            } else {\n                scene.fog = new THREE.FogExp2(new THREE.Color(params.fogColor), params.fogDensity);\n            }\n            if (scene.background instanceof THREE.Color) {\n                scene.background.set(params.fogColor);\n            } else {\n                scene.background = new THREE.Color(params.fogColor);\n            }\n        }\n\n        function updateLights() {\n            sunLight.color.set(params.sunColor);\n            sunLight.intensity = params.sunIntensity;\n            ambientLight.color.set(params.ambientColor);\n        }\n\n        function setupGUI() {\n            const gui = new GUI();\n\n            const terrainFolder = gui.addFolder('Terrain');\n            terrainFolder.add(params, 'seed').name('Seed').onFinishChange(generateTerrain);\n            terrainFolder.add(params, 'planeSize', 100, 1000, 10).name('Plane Size').onFinishChange(generateTerrain);\n            terrainFolder.add(params, 'segments', 50, 300, 10).name('Segments').onFinishChange(generateTerrain);\n            terrainFolder.add(params, 'scale', 10, 500, 1).name('Noise Scale').onChange(generateTerrain);\n            terrainFolder.add(params, 'octaves', 1, 16, 1).name('Octaves').onChange(generateTerrain);\n            terrainFolder.add(params, 'persistence', 0.1, 1.0, 0.01).name('Persistence').onChange(generateTerrain);\n            terrainFolder.add(params, 'lacunarity', 1.5, 4.0, 0.01).name('Lacunarity').onChange(generateTerrain);\n            terrainFolder.add(params, 'heightMultiplier', 10, 200, 1).name('Height Multiplier').onChange(generateTerrain);\n            terrainFolder.add(params, 'flatness', 0.1, 3.0, 0.01).name('Flatness Power').onChange(generateTerrain);\n\n            const dropoffFolder = gui.addFolder('Terrain Dropoff');\n            dropoffFolder.add(params, 'enableDropoff').name('Enable Dropoff').onChange(generateTerrain);\n            dropoffFolder.add(params, 'dropoffStart', 0.1, 0.95, 0.01).name('Dropoff Start (%)').onChange(generateTerrain);\n            dropoffFolder.add(params, 'dropoffStrength', 0.5, 10.0, 0.1).name('Dropoff Strength').onChange(generateTerrain);\n\n\n            const colorsFolder = gui.addFolder('Colors & Levels');\n            colorsFolder.addColor(params, 'snowColor').name('Snow Color').onChange(generateTerrain);\n            colorsFolder.addColor(params, 'rockColor').name('Rock Color').onChange(generateTerrain);\n            colorsFolder.addColor(params, 'grassColor').name('Grass Color').onChange(generateTerrain);\n            colorsFolder.addColor(params, 'waterColor').name('Water Color').onChange(generateTerrain);\n            colorsFolder.add(params, 'snowLine', 0, 1, 0.01).name('Snow Line').onChange(generateTerrain);\n            colorsFolder.add(params, 'rockLine', 0, 1, 0.01).name('Rock Line').onChange(generateTerrain);\n            colorsFolder.add(params, 'waterLine', 0, 1, 0.01).name('Water Line').onChange(generateTerrain);\n\n            const atmosphereFolder = gui.addFolder('Atmosphere');\n            atmosphereFolder.addColor(params, 'fogColor').name('Fog Color').onChange(updateFog);\n            atmosphereFolder.add(params, 'fogDensity', 0, 0.01, 0.0001).name('Fog Density').onChange(updateFog);\n\n            const lightingFolder = gui.addFolder('Lighting');\n            lightingFolder.addColor(params, 'sunColor').name('Sun Color').onChange(updateLights);\n            lightingFolder.add(params, 'sunIntensity', 0, 5, 0.1).name('Sun Intensity').onChange(updateLights);\n            lightingFolder.addColor(params, 'ambientColor').name('Ambient Color').onChange(updateLights);\n\n            gui.onChange(event => {\n                // Some specific updates might be needed if not covered by individual onChanges\n            });\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n            controls.update();\n            renderer.render(scene, camera);\n        }\n\n        init();\n    </script>\n</body>\n\n</html>",
  "id": "landscape-gemini-pro-2-5",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Procedural Generation",
      "Astronomy"
    ],
    "timestamp": "2025-08-04T21:59:57.965Z",
    "model": "gemini-pro-2.5",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, procedural generation, astronomy."
  }
}
