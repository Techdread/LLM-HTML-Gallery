{
  "title": "Voxel-Based Fire Spread Simulation",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Voxel-Based Fire Spread Simulation</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);\r\n            color: white;\r\n        }\r\n\r\n        canvas {\r\n            display: block;\r\n        }\r\n\r\n        .header {\r\n            position: absolute;\r\n            top: 20px;\r\n            left: 0;\r\n            width: 100%;\r\n            text-align: center;\r\n            z-index: 10;\r\n            padding: 10px;\r\n            background: rgba(0, 0, 0, 0.5);\r\n            backdrop-filter: blur(5px);\r\n        }\r\n\r\n        h1 {\r\n            margin: 0;\r\n            font-size: 2.5rem;\r\n            text-shadow: 0 0 10px rgba(255, 100, 0, 0.7);\r\n        }\r\n\r\n        .subtitle {\r\n            font-size: 1.2rem;\r\n            margin-top: 5px;\r\n            opacity: 0.9;\r\n        }\r\n\r\n        .controls {\r\n            position: absolute;\r\n            bottom: 20px;\r\n            left: 20px;\r\n            background: rgba(0, 0, 0, 0.7);\r\n            padding: 15px;\r\n            border-radius: 10px;\r\n            z-index: 10;\r\n            backdrop-filter: blur(5px);\r\n            max-width: 300px;\r\n        }\r\n\r\n        .control-group {\r\n            margin-bottom: 15px;\r\n        }\r\n\r\n        label {\r\n            display: block;\r\n            margin-bottom: 5px;\r\n            font-weight: bold;\r\n        }\r\n\r\n        input[type=\"range\"] {\r\n            width: 100%;\r\n            margin-bottom: 10px;\r\n        }\r\n\r\n        button {\r\n            background: linear-gradient(to right, #ff8c00, #ff4500);\r\n            color: white;\r\n            border: none;\r\n            padding: 10px 20px;\r\n            border-radius: 5px;\r\n            cursor: pointer;\r\n            font-weight: bold;\r\n            width: 100%;\r\n            margin-top: 5px;\r\n            transition: all 0.3s ease;\r\n        }\r\n\r\n        button:hover {\r\n            transform: scale(1.05);\r\n            box-shadow: 0 0 15px rgba(255, 69, 0, 0.7);\r\n        }\r\n\r\n        .stats {\r\n            position: absolute;\r\n            bottom: 20px;\r\n            right: 20px;\r\n            background: rgba(0, 0, 0, 0.7);\r\n            padding: 15px;\r\n            border-radius: 10px;\r\n            z-index: 10;\r\n            backdrop-filter: blur(5px);\r\n        }\r\n\r\n        .instructions {\r\n            position: absolute;\r\n            top: 80px;\r\n            right: 20px;\r\n            background: rgba(0, 0, 0, 0.7);\r\n            padding: 15px;\r\n            border-radius: 10px;\r\n            z-index: 10;\r\n            backdrop-filter: blur(5px);\r\n            max-width: 300px;\r\n        }\r\n\r\n        .instructions h3 {\r\n            margin-top: 0;\r\n            color: #ff8c00;\r\n        }\r\n\r\n        .instructions ul {\r\n            padding-left: 20px;\r\n        }\r\n\r\n        .instructions li {\r\n            margin-bottom: 10px;\r\n        }\r\n\r\n        .particle-count {\r\n            font-weight: bold;\r\n            color: #ff8c00;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div class=\"header\">\r\n        <h1>Voxel-Based Fire Spread Simulation</h1>\r\n        <div class=\"subtitle\">Click on voxels to ignite them and watch fire spread</div>\r\n    </div>\r\n\r\n    <div class=\"instructions\">\r\n        <h3>How to Use:</h3>\r\n        <ul>\r\n            <li><strong>Click</strong> on any voxel to ignite it</li>\r\n            <li>Adjust <strong>Fire Spread Rate</strong> to control how quickly fire spreads</li>\r\n            <li>Change <strong>Ignition Probability</strong> to make fire spread more or less likely</li>\r\n            <li>Use <strong>Reset Simulation</strong> to start over</li>\r\n            <li><strong>Drag</strong> to rotate the scene, <strong>Scroll</strong> to zoom</li>\r\n        </ul>\r\n    </div>\r\n\r\n    <div class=\"controls\">\r\n        <div class=\"control-group\">\r\n            <label for=\"spreadRate\">Fire Spread Rate: <span id=\"spreadRateValue\">0.8</span></label>\r\n            <input type=\"range\" id=\"spreadRate\" min=\"0.1\" max=\"1\" step=\"0.1\" value=\"0.8\">\r\n        </div>\r\n\r\n        <div class=\"control-group\">\r\n            <label for=\"ignitionProb\">Ignition Probability: <span id=\"ignitionProbValue\">0.7</span></label>\r\n            <input type=\"range\" id=\"ignitionProb\" min=\"0.1\" max=\"1\" step=\"0.1\" value=\"0.7\">\r\n        </div>\r\n\r\n        <button id=\"resetBtn\">Reset Simulation</button>\r\n    </div>\r\n\r\n    <div class=\"stats\">\r\n        <div>Active Fires: <span id=\"fireCount\" class=\"particle-count\">0</span></div>\r\n        <div>Smoke Particles: <span id=\"smokeCount\" class=\"particle-count\">0</span></div>\r\n        <div>Simulation Speed: <span id=\"speedValue\">1.0x</span></div>\r\n    </div>\r\n\r\n    <script type=\"importmap\">\r\n        {\r\n            \"imports\": {\r\n                \"three\": \"https://unpkg.com/three@0.165.0/build/three.module.js\",\r\n                \"three/addons/\": \"https://unpkg.com/three@0.165.0/examples/jsm/\"\r\n            }\r\n        }\r\n    </script>\r\n\r\n    <script type=\"module\">\r\n        import * as THREE from 'three';\r\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\n\r\n        // Scene setup\r\n        let scene, camera, renderer, controls;\r\n        let voxelGrid = [];\r\n        let smokeParticles = [];\r\n        let fireCount = 0;\r\n        let smokeCount = 0;\r\n\r\n        // Simulation parameters\r\n        const gridSize = 15;\r\n        const voxelSize = 1;\r\n        const spreadRate = 0.8; // Controls how often fire spreads to neighbors\r\n        const ignitionProbability = 0.7; // Probability of fire spreading to a neighbor\r\n\r\n        // Materials\r\n        const flammableMaterial = new THREE.MeshLambertMaterial({\r\n            color: 0x8B4513, // Brown\r\n            transparent: true,\r\n            opacity: 0.9\r\n        });\r\n\r\n        const burningMaterial = new THREE.MeshLambertMaterial({\r\n            color: 0xFF4500, // Orange-red\r\n            emissive: 0xFF4500,\r\n            emissiveIntensity: 1,\r\n            transparent: true,\r\n            opacity: 0.9\r\n        });\r\n\r\n        const burntMaterial = new THREE.MeshLambertMaterial({\r\n            color: 0x2F4F4F, // Dark slate gray\r\n            transparent: true,\r\n            opacity: 0.8\r\n        });\r\n\r\n        // Smoke particle material\r\n        const smokeMaterial = new THREE.PointsMaterial({\r\n            color: 0x888888,\r\n            size: 0.3,\r\n            transparent: true,\r\n            opacity: 0.6,\r\n            sizeAttenuation: true\r\n        });\r\n\r\n        init();\r\n        animate();\r\n\r\n        function init() {\r\n            // Scene\r\n            scene = new THREE.Scene();\r\n            scene.background = new THREE.Color(0x0a0a1a);\r\n            scene.fog = new THREE.Fog(0x0a0a1a, 20, 50);\r\n\r\n            // Camera\r\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n            camera.position.set(15, 15, 15);\r\n            camera.lookAt(0, 0, 0);\r\n\r\n            // Renderer\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            renderer.shadowMap.enabled = true;\r\n            document.body.appendChild(renderer.domElement);\r\n\r\n            // OrbitControls\r\n            controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n\r\n            // Lighting\r\n            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);\r\n            scene.add(ambientLight);\r\n\r\n            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\r\n            directionalLight.position.set(5, 10, 7);\r\n            directionalLight.castShadow = true;\r\n            directionalLight.shadow.mapSize.width = 1024;\r\n            directionalLight.shadow.mapSize.height = 1024;\r\n            scene.add(directionalLight);\r\n\r\n            const backLight = new THREE.DirectionalLight(0x4040ff, 0.5);\r\n            backLight.position.set(-5, -5, -5);\r\n            scene.add(backLight);\r\n\r\n            // Create voxel grid\r\n            createVoxelGrid();\r\n\r\n            // Add event listeners\r\n            setupEventListeners();\r\n\r\n            // Handle window resize\r\n            window.addEventListener('resize', onWindowResize);\r\n        }\r\n\r\n        function createVoxelGrid() {\r\n            // Clear existing voxels\r\n            for (let i = 0; i < voxelGrid.length; i++) {\r\n                if (voxelGrid[i] && voxelGrid[i].length) {\r\n                    for (let j = 0; j < voxelGrid[i].length; j++) {\r\n                        if (voxelGrid[i][j] && voxelGrid[i][j].length) {\r\n                            for (let k = 0; k < voxelGrid[i][j].length; k++) {\r\n                                if (voxelGrid[i][j][k]) {\r\n                                    scene.remove(voxelGrid[i][j][k]);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            voxelGrid = [];\r\n            fireCount = 0;\r\n            smokeCount = 0;\r\n            updateStats();\r\n\r\n            // Create a 3D grid of voxels\r\n            for (let x = 0; x < gridSize; x++) {\r\n                voxelGrid[x] = [];\r\n                for (let y = 0; y < gridSize; y++) {\r\n                    voxelGrid[x][y] = [];\r\n                    for (let z = 0; z < gridSize; z++) {\r\n                        // Create voxel\r\n                        const geometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);\r\n                        const material = flammableMaterial;\r\n\r\n                        const voxel = new THREE.Mesh(geometry, material);\r\n\r\n                        // Position the voxel\r\n                        voxel.position.set(\r\n                            (x - gridSize / 2) * voxelSize,\r\n                            (y - gridSize / 2) * voxelSize,\r\n                            (z - gridSize / 2) * voxelSize\r\n                        );\r\n\r\n                        // Add properties to voxel\r\n                        voxel.userData = {\r\n                            isFlammable: true,\r\n                            isOnFire: false,\r\n                            fuel: Math.random() * 5 + 3, // Random fuel between 3-8\r\n                            neighbors: [],\r\n                            smokeParticle: null\r\n                        };\r\n\r\n                        // Add to scene and store reference\r\n                        scene.add(voxel);\r\n                        voxelGrid[x][y][z] = voxel;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Set up neighbors for each voxel after all are created\r\n            setupAllNeighbors();\r\n\r\n            // Create smoke particles system\r\n            createSmokeSystem();\r\n        }\r\n\r\n        function setupAllNeighbors() {\r\n            // Now that all voxels exist, set up neighbors for each\r\n            for (let x = 0; x < gridSize; x++) {\r\n                for (let y = 0; y < gridSize; y++) {\r\n                    for (let z = 0; z < gridSize; z++) {\r\n                        setupNeighbors(x, y, z);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function setupNeighbors(x, y, z) {\r\n            const neighbors = [];\r\n\r\n            // Check all 6 adjacent positions (up, down, left, right, front, back)\r\n            const directions = [\r\n                [1, 0, 0], [-1, 0, 0], // x-axis\r\n                [0, 1, 0], [0, -1, 0], // y-axis\r\n                [0, 0, 1], [0, 0, -1]  // z-axis\r\n            ];\r\n\r\n            for (const [dx, dy, dz] of directions) {\r\n                const nx = x + dx;\r\n                const ny = y + dy;\r\n                const nz = z + dz;\r\n\r\n                // Check if neighbor is within grid bounds\r\n                if (nx >= 0 && nx < gridSize &&\r\n                    ny >= 0 && ny < gridSize &&\r\n                    nz >= 0 && nz < gridSize) {\r\n                    neighbors.push(voxelGrid[nx][ny][nz]);\r\n                }\r\n            }\r\n\r\n            voxelGrid[x][y][z].userData.neighbors = neighbors;\r\n        }\r\n\r\n        function createSmokeSystem() {\r\n            // Remove existing smoke particles\r\n            for (const particle of smokeParticles) {\r\n                scene.remove(particle);\r\n            }\r\n            smokeParticles = [];\r\n\r\n            // Create a large number of smoke particles\r\n            const particleCount = 5000;\r\n            const positions = new Float32Array(particleCount * 3);\r\n            const colors = new Float32Array(particleCount * 3);\r\n\r\n            for (let i = 0; i < particleCount; i++) {\r\n                const i3 = i * 3;\r\n\r\n                // Random initial positions\r\n                positions[i3] = (Math.random() - 0.5) * gridSize * voxelSize;\r\n                positions[i3 + 1] = (Math.random() - 0.5) * gridSize * voxelSize;\r\n                positions[i3 + 2] = (Math.random() - 0.5) * gridSize * voxelSize;\r\n\r\n                // Random colors (grayish)\r\n                colors[i3] = 0.7 + Math.random() * 0.3;\r\n                colors[i3 + 1] = 0.7 + Math.random() * 0.3;\r\n                colors[i3 + 2] = 0.7 + Math.random() * 0.3;\r\n            }\r\n\r\n            const geometry = new THREE.BufferGeometry();\r\n            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\r\n            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\r\n\r\n            const particleSystem = new THREE.Points(geometry, smokeMaterial);\r\n            scene.add(particleSystem);\r\n            smokeParticles.push(particleSystem);\r\n        }\r\n\r\n        function setupEventListeners() {\r\n            // Raycasting for voxel interaction\r\n            const raycaster = new THREE.Raycaster();\r\n            const mouse = new THREE.Vector2();\r\n\r\n            document.addEventListener('click', (event) => {\r\n                // Calculate mouse position in normalized device coordinates\r\n                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\r\n                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\r\n\r\n                // Update the picking ray with the camera and mouse position\r\n                raycaster.setFromCamera(mouse, camera);\r\n\r\n                // Calculate objects intersecting the picking ray\r\n                const intersects = raycaster.intersectObjects(scene.children);\r\n\r\n                if (intersects.length > 0) {\r\n                    const object = intersects[0].object;\r\n\r\n                    // Check if it's a voxel\r\n                    if (object.userData.isFlammable !== undefined) {\r\n                        igniteVoxel(object);\r\n                    }\r\n                }\r\n            });\r\n\r\n            // Setup controls\r\n            document.getElementById('spreadRate').addEventListener('input', function () {\r\n                document.getElementById('spreadRateValue').textContent = this.value;\r\n            });\r\n\r\n            document.getElementById('ignitionProb').addEventListener('input', function () {\r\n                document.getElementById('ignitionProbValue').textContent = this.value;\r\n            });\r\n\r\n            document.getElementById('resetBtn').addEventListener('click', resetSimulation);\r\n        }\r\n\r\n        function igniteVoxel(voxel) {\r\n            if (voxel.userData.isFlammable && !voxel.userData.isOnFire) {\r\n                voxel.userData.isOnFire = true;\r\n                voxel.userData.isFlammable = false;\r\n                voxel.material = burningMaterial;\r\n\r\n                fireCount++;\r\n                updateStats();\r\n\r\n                // Add smoke particle to this voxel\r\n                createSmokeForVoxel(voxel);\r\n            }\r\n        }\r\n\r\n        function createSmokeForVoxel(voxel) {\r\n            const particleSystem = smokeParticles[0];\r\n            if (!particleSystem) return;\r\n\r\n            const positions = particleSystem.geometry.attributes.position.array;\r\n            const colors = particleSystem.geometry.attributes.color.array;\r\n\r\n            // Find a free particle slot\r\n            for (let i = 0; i < positions.length; i += 3) {\r\n                if (positions[i] === 0 && positions[i + 1] === 0 && positions[i + 2] === 0) {\r\n                    // Position the smoke at the voxel\r\n                    positions[i] = voxel.position.x;\r\n                    positions[i + 1] = voxel.position.y + voxelSize / 2;\r\n                    positions[i + 2] = voxel.position.z;\r\n\r\n                    // Set color to gray\r\n                    colors[i] = 0.7 + Math.random() * 0.3;\r\n                    colors[i + 1] = 0.7 + Math.random() * 0.3;\r\n                    colors[i + 2] = 0.7 + Math.random() * 0.3;\r\n\r\n                    smokeCount++;\r\n                    updateStats();\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Custom deep copy function to avoid circular references\r\n        function copyVoxelState(voxel) {\r\n            return {\r\n                isFlammable: voxel.userData.isFlammable,\r\n                isOnFire: voxel.userData.isOnFire,\r\n                fuel: voxel.userData.fuel\r\n            };\r\n        }\r\n\r\n        function updateFireSpread() {\r\n            const spreadRate = parseFloat(document.getElementById('spreadRate').value);\r\n            const ignitionProb = parseFloat(document.getElementById('ignitionProb').value);\r\n\r\n            // Instead of JSON.stringify, we'll iterate directly through the grid\r\n            for (let x = 0; x < gridSize; x++) {\r\n                for (let y = 0; y < gridSize; y++) {\r\n                    for (let z = 0; z < gridSize; z++) {\r\n                        const voxel = voxelGrid[x][y][z];\r\n\r\n                        if (!voxel) continue;\r\n\r\n                        if (voxel.userData.isOnFire) {\r\n                            // Decrease fuel\r\n                            voxel.userData.fuel -= 0.05;\r\n\r\n                            // Check if fire has burned out\r\n                            if (voxel.userData.fuel <= 0) {\r\n                                // Turn to burnt state\r\n                                voxel.userData.isOnFire = false;\r\n                                voxel.userData.isFlammable = false;\r\n                                voxel.material = burntMaterial;\r\n\r\n                                fireCount--;\r\n                                updateStats();\r\n                            } else {\r\n                                // Spread fire to neighbors\r\n                                for (const neighbor of voxel.userData.neighbors) {\r\n                                    if (neighbor && neighbor.userData.isFlammable && Math.random() < spreadRate * ignitionProb) {\r\n                                        igniteVoxel(neighbor);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function updateSmokeParticles() {\r\n            const particleSystem = smokeParticles[0];\r\n            if (!particleSystem) return;\r\n\r\n            const positions = particleSystem.geometry.attributes.position.array;\r\n\r\n            // Update smoke positions\r\n            for (let i = 0; i < positions.length; i += 3) {\r\n                // Apply upward velocity\r\n                if (positions[i] !== 0 || positions[i + 1] !== 0 || positions[i + 2] !== 0) {\r\n                    // Move particles up and randomly\r\n                    positions[i + 1] += 0.05;\r\n                    positions[i] += (Math.random() - 0.5) * 0.05;\r\n                    positions[i + 2] += (Math.random() - 0.5) * 0.05;\r\n\r\n                    // Fade out particles\r\n                    if (positions[i + 1] > 20) {\r\n                        positions[i] = 0;\r\n                        positions[i + 1] = 0;\r\n                        positions[i + 2] = 0;\r\n                        smokeCount--;\r\n                    }\r\n                }\r\n            }\r\n\r\n            particleSystem.geometry.attributes.position.needsUpdate = true;\r\n            updateStats();\r\n        }\r\n\r\n        function updateStats() {\r\n            document.getElementById('fireCount').textContent = fireCount;\r\n            document.getElementById('smokeCount').textContent = smokeCount;\r\n        }\r\n\r\n        function resetSimulation() {\r\n            createVoxelGrid();\r\n        }\r\n\r\n        function onWindowResize() {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n\r\n            // Update controls\r\n            controls.update();\r\n\r\n            // Update fire spread simulation\r\n            updateFireSpread();\r\n\r\n            // Update smoke particles\r\n            updateSmokeParticles();\r\n\r\n            // Render the scene\r\n            renderer.render(scene, camera);\r\n        }\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "voxel-fire-q4-qwen-coder-30b-a3b",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "Particles",
      "WebGL",
      "Shaders",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:58.107Z",
    "model": "qwen-coder-30b-a3b",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, particles, webgl, shaders, simulation, architecture."
  }
}
