{
  "id": "planet-threejs-planet-Horizon-Beta",
  "title": "Procedurally Generated 3D Planet",
  "htmlContent": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\" />\n    <title>Procedural Biome Planet - biome5</title>\n    <style>\n        :root {\n            color-scheme: dark;\n        }\n\n        html,\n        body {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n            background: radial-gradient(1200px 800px at 70% 30%, #0a0f1e 0%, #060913 60%, #03060d 100%);\n            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n        }\n\n        canvas {\n            display: block;\n        }\n\n        .hud {\n            position: fixed;\n            top: 10px;\n            left: 10px;\n            right: 10px;\n            display: flex;\n            gap: 10px;\n            align-items: center;\n            color: #dbe7ff;\n            user-select: none;\n            pointer-events: none;\n            mix-blend-mode: screen;\n            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);\n        }\n\n        .hud .panel {\n            pointer-events: auto;\n            background: rgba(10, 15, 30, 0.55);\n            border: 1px solid rgba(90, 150, 255, 0.25);\n            border-radius: 10px;\n            padding: 10px 12px;\n            backdrop-filter: blur(6px);\n            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.05);\n        }\n\n        .hud .title {\n            font-weight: 700;\n            letter-spacing: 0.3px;\n        }\n\n        .row {\n            display: flex;\n            gap: 12px;\n            align-items: center;\n            flex-wrap: wrap;\n        }\n\n        .row label {\n            font-size: 12px;\n            opacity: 0.85;\n        }\n\n        .row input[type=\"range\"] {\n            width: 140px;\n            accent-color: #67a2ff;\n        }\n\n        .row input[type=\"checkbox\"] {\n            transform: translateY(1px);\n            accent-color: #67a2ff;\n        }\n\n        .kbd {\n            font: 11px/1 monospace;\n            padding: 2px 6px;\n            border-radius: 6px;\n            border: 1px solid rgba(255, 255, 255, 0.18);\n            background: rgba(255, 255, 255, 0.08);\n            margin-left: 6px;\n            display: inline-block;\n        }\n\n        .legend {\n            font-size: 12px;\n            opacity: 0.9;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- Import map for three.js and its addons -->\n    <script type=\"importmap\">\n    {\n      \"imports\": {\n        \"three\": \"https://unpkg.com/three@0.165.0/build/three.module.js\",\n        \"three/addons/\": \"https://unpkg.com/three@0.165.0/examples/jsm/\"\n      }\n    }\n  </script>\n\n    <div class=\"hud\">\n        <div class=\"panel\">\n            <div class=\"title\">Procedural Planet</div>\n            <div class=\"row\" style=\"margin-top:6px;\">\n                <label>Rotation speed</label>\n                <input id=\"rotSpeed\" type=\"range\" min=\"0\" max=\"1.2\" step=\"0.01\" value=\"0.08\" />\n                <label><input id=\"pauseToggle\" type=\"checkbox\" /> Pause</label>\n                <label><input id=\"cloudsToggle\" type=\"checkbox\" checked /> Clouds</label>\n                <label><input id=\"atmoToggle\" type=\"checkbox\" checked /> Atmosphere</label>\n                <label><input id=\"waterToggle\" type=\"checkbox\" checked /> Water</label>\n            </div>\n            <div class=\"legend\" style=\"margin-top:6px;\">\n                Space: Pause/Resume\n                <span class=\"kbd\">↑</span><span class=\"kbd\">↓</span> Adjust speed\n                <span class=\"kbd\">R</span> Reseed\n            </div>\n        </div>\n    </div>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\n        // Core objects\n        let scene, camera, renderer, controls, clock;\n        let planet, planetMaterial, planetGeometry;\n        let water, waterMaterial, waterGeometry;\n        let clouds, cloudsMaterial, cloudsGeometry;\n        let atmosphere, atmosphereMaterial, atmosphereGeometry;\n        let sunLight, ambient;\n        let rotationSpeed = 0.08;\n        let paused = false;\n\n        // Noise helpers\n        const baseNoise = new ImprovedNoise();\n        const cloudNoise = new ImprovedNoise();\n\n        // Parameters\n        const params = {\n            radius: 1.0,\n            segments: 256, // balances detail and perf\n            elevationScale: 0.18, // terrain displacement amplitude\n            lacunarity: 2.1,\n            persistence: 0.48,\n            octaves: 6,\n            seaLevel: 0.0, // threshold for water line in final elevation after normalization\n            biomeBlend: 0.08,\n            cloudSpeed: 0.01,\n            cloudHeight: 0.015,\n            cloudOpacity: 0.38,\n            atmosphereIntensity: 1.0,\n            dayNightSpeed: 0.05\n        };\n\n        // Random reseed\n        let reseed = Math.random() * 1000;\n\n        init();\n        animate();\n\n        function init() {\n            scene = new THREE.Scene();\n\n            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.05, 1000);\n            camera.position.set(0, 0.6, 3);\n\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.setClearColor(0x03060d, 1);\n            renderer.shadowMap.enabled = true;\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n            document.body.appendChild(renderer.domElement);\n\n            controls = new OrbitControls(camera, renderer.domElement);\n            controls.enableDamping = true;\n            controls.dampingFactor = 0.08;\n            controls.minDistance = 1.4;\n            controls.maxDistance = 8;\n            controls.enablePan = false;\n\n            clock = new THREE.Clock();\n\n            addLights();\n            buildPlanet();\n            buildWater();\n            buildClouds();\n            buildAtmosphere();\n            addStarBackground();\n\n            // Events\n            window.addEventListener('resize', onWindowResize, false);\n            window.addEventListener('keydown', onKeyDown, false);\n\n            // Hook up UI\n            const rotSpeedEl = document.getElementById('rotSpeed');\n            const pauseToggle = document.getElementById('pauseToggle');\n            const cloudsToggle = document.getElementById('cloudsToggle');\n            const atmoToggle = document.getElementById('atmoToggle');\n            const waterToggle = document.getElementById('waterToggle');\n\n            rotSpeedEl.addEventListener('input', (e) => rotationSpeed = parseFloat(e.target.value));\n            pauseToggle.addEventListener('change', (e) => paused = e.target.checked);\n            cloudsToggle.addEventListener('change', (e) => clouds.visible = e.target.checked);\n            atmoToggle.addEventListener('change', (e) => atmosphere.visible = e.target.checked);\n            waterToggle.addEventListener('change', (e) => water.visible = e.target.checked);\n        }\n\n        function addLights() {\n            sunLight = new THREE.DirectionalLight(0xffffff, 2.0);\n            sunLight.position.set(5, 2, 2);\n            sunLight.castShadow = true;\n            sunLight.shadow.mapSize.set(1024, 1024);\n            scene.add(sunLight);\n\n            ambient = new THREE.AmbientLight(0x223355, 0.6);\n            scene.add(ambient);\n        }\n\n        function buildPlanet() {\n            planetGeometry = new THREE.SphereGeometry(params.radius, params.segments, params.segments);\n            displaceTerrain(planetGeometry);\n\n            planetMaterial = new THREE.ShaderMaterial({\n                vertexShader: planetVertexShader(),\n                fragmentShader: planetFragmentShader(),\n                uniforms: {\n                    uLightDir: { value: new THREE.Vector3().copy(sunLight.position).normalize() },\n                    uBiomeBlend: { value: params.biomeBlend },\n                    uSeaLevel: { value: params.seaLevel },\n                    uTime: { value: 0 },\n                    uAmbient: { value: 0.1 }\n                },\n                lights: false,\n                fog: false\n            });\n\n            planet = new THREE.Mesh(planetGeometry, planetMaterial);\n            planet.castShadow = true;\n            planet.receiveShadow = true;\n            scene.add(planet);\n        }\n\n        function buildWater() {\n            waterGeometry = new THREE.SphereGeometry(params.radius * 1.0015, 192, 192);\n            waterMaterial = new THREE.ShaderMaterial({\n                transparent: true,\n                depthWrite: false,\n                vertexShader: waterVertexShader(),\n                fragmentShader: waterFragmentShader(),\n                uniforms: {\n                    uTime: { value: 0 },\n                    uColorDeep: { value: new THREE.Color(0x0a2a5a) },\n                    uColorShallow: { value: new THREE.Color(0x1f6fb2) },\n                    uOpacity: { value: 0.9 },\n                    uFresnelColor: { value: new THREE.Color(0x6dbcff) }\n                }\n            });\n            water = new THREE.Mesh(waterGeometry, waterMaterial);\n            water.receiveShadow = false;\n            scene.add(water);\n        }\n\n        function buildClouds() {\n            cloudsGeometry = new THREE.SphereGeometry(params.radius * (1.0 + params.cloudHeight), 192, 192);\n            cloudsMaterial = new THREE.ShaderMaterial({\n                transparent: true,\n                depthWrite: false,\n                vertexShader: cloudsVertexShader(),\n                fragmentShader: cloudsFragmentShader(),\n                uniforms: {\n                    uTime: { value: 0 },\n                    uOpacity: { value: params.cloudOpacity }\n                }\n            });\n            clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);\n            scene.add(clouds);\n        }\n\n        function buildAtmosphere() {\n            atmosphereGeometry = new THREE.SphereGeometry(params.radius * 1.06, 128, 128);\n            atmosphereMaterial = new THREE.ShaderMaterial({\n                side: THREE.BackSide,\n                transparent: true,\n                depthWrite: false,\n                vertexShader: atmosphereVertexShader(),\n                fragmentShader: atmosphereFragmentShader(),\n                uniforms: {\n                    uIntensity: { value: params.atmosphereIntensity },\n                    uColor: { value: new THREE.Color(0x5fb9ff) }\n                },\n                blending: THREE.AdditiveBlending\n            });\n            atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);\n            scene.add(atmosphere);\n        }\n\n        function addStarBackground() {\n            const starGeo = new THREE.SphereGeometry(80, 32, 32);\n            const starMat = new THREE.ShaderMaterial({\n                side: THREE.BackSide,\n                vertexShader: `\n          varying vec3 vWorldPos;\n          void main() {\n            vec4 wp = modelMatrix * vec4(position,1.0);\n            vWorldPos = wp.xyz;\n            gl_Position = projectionMatrix * viewMatrix * wp;\n          }\n        `,\n                fragmentShader: `\n          precision highp float;\n          varying vec3 vWorldPos;\n          float hash(vec3 p) {\n            p = fract(p * 0.3183099 + vec3(0.1,0.2,0.3));\n            p *= 17.0;\n            return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n          }\n          void main() {\n            vec3 d = normalize(vWorldPos);\n            float v = hash(floor(d * 120.0));\n            float star = step(0.9975, v) * (v - 0.9975) * 400.0;\n            vec3 col = mix(vec3(0.01,0.02,0.05), vec3(0.7,0.8,1.0), star);\n            gl_FragColor = vec4(col, 1.0);\n          }\n        `\n            });\n            const stars = new THREE.Mesh(starGeo, starMat);\n            scene.add(stars);\n        }\n\n        // Terrain displacement and biome data baked into attributes\n        function displaceTerrain(geometry) {\n            geometry.computeVertexNormals();\n            const pos = geometry.attributes.position;\n            const vCount = pos.count;\n\n            const elevations = new Float32Array(vCount);\n            const biomes = new Float32Array(vCount * 3); // biome weights: (cold, temperate, desert)\n\n            const tmp = new THREE.Vector3();\n\n            for (let i = 0; i < vCount; i++) {\n                tmp.fromBufferAttribute(pos, i).normalize();\n                const n = multiNoise(tmp.x, tmp.y, tmp.z, params.octaves, params.lacunarity, params.persistence, 1.7, reseed);\n                // Normalize n to [-1,1] and scale\n                const elev = n * params.elevationScale;\n                // Store the final displaced position\n                tmp.multiplyScalar(params.radius + elev);\n                pos.setXYZ(i, tmp.x, tmp.y, tmp.z);\n                elevations[i] = elev;\n\n                // Latitude based biome influence\n                const lat = Math.asin((tmp.y) / tmp.length()); // [-pi/2, pi/2]\n                const latNorm = (lat / (Math.PI * 0.5)); // [-1,1]\n                // Height normalized to guide biomes (mountain tundra, alpine, etc.)\n                const h = (elev - (-params.elevationScale)) / (2.0 * params.elevationScale); // ~[0,1]\n\n                // Base latitudinal weights\n                let wCold = smoothStep(0.3, 1.0, Math.abs(latNorm));  // high latitudes\n                let wDesert = smoothStep(0.15, 0.5, 1.0 - Math.abs(latNorm)); // low latitudes\n                let wTemperate = 1.0 - Math.max(wCold, wDesert);\n\n                // Elevation influence: higher -> colder (tundra), mid -> temperate, low -> desert/plains\n                wCold = clamp(wCold + smoothStep(0.55, 0.85, h) * 0.6, 0.0, 1.0);\n                wTemperate = clamp(wTemperate + (1.0 - Math.abs(h - 0.45) * 2.0) * 0.25, 0.0, 1.0);\n                wDesert = clamp(wDesert + smoothStep(0.0, 0.25, 0.25 - Math.abs(0.25 - h)) * 0.3, 0.0, 1.0);\n\n                // Renormalize\n                const sum = wCold + wTemperate + wDesert + 1e-6;\n                biomes[i * 3 + 0] = wCold / sum;\n                biomes[i * 3 + 1] = wTemperate / sum;\n                biomes[i * 3 + 2] = wDesert / sum;\n            }\n\n            pos.needsUpdate = true;\n            geometry.computeVertexNormals();\n\n            geometry.setAttribute('elevation', new THREE.BufferAttribute(elevations, 1));\n            geometry.setAttribute('biome', new THREE.BufferAttribute(biomes, 3));\n        }\n\n        // Multi-octave 3D noise sampled on unit sphere direction, with a simple warp\n        function multiNoise(x, y, z, octaves, lac, pers, warp, seed) {\n            let f = 1.0;\n            let a = 1.0;\n            let sum = 0.0;\n            let ampSum = 0.0;\n            let vx = x, vy = y, vz = z;\n\n            for (let o = 0; o < octaves; o++) {\n                // simple domain warp using previous value\n                const w = baseNoise.noise(vx * f + seed, vy * f, vz * f) * warp * 0.05;\n                vx = x + w;\n                vy = y + w * 0.8;\n                vz = z - w * 0.6;\n\n                const n = baseNoise.noise(vx * f + seed, vy * f - seed * 0.5, vz * f + seed * 0.25);\n                sum += n * a;\n                ampSum += a;\n\n                f *= lac;\n                a *= pers;\n            }\n            return sum / ampSum;\n        }\n\n        function smoothStep(edge0, edge1, x) {\n            const t = clamp((x - edge0) / (edge1 - edge0 + 1e-6), 0.0, 1.0);\n            return t * t * (3.0 - 2.0 * t);\n        }\n        function clamp(x, a, b) { return Math.min(Math.max(x, a), b); }\n\n        // Shaders\n        function planetVertexShader() {\n            return `\n        precision highp float;\n        attribute float elevation;\n        attribute vec3 biome;\n        varying float vElevation;\n        varying vec3 vBiome;\n        varying vec3 vNormal;\n        varying vec3 vWorldPos;\n        void main() {\n          vElevation = elevation;\n          vBiome = biome;\n          vNormal = normalize(normalMatrix * normal);\n          vec4 wp = modelMatrix * vec4(position, 1.0);\n          vWorldPos = wp.xyz;\n          gl_Position = projectionMatrix * viewMatrix * wp;\n        }\n      `;\n        }\n\n        function planetFragmentShader() {\n            return `\n        precision highp float;\n        uniform vec3 uLightDir;\n        uniform float uBiomeBlend;\n        uniform float uSeaLevel;\n        uniform float uTime;\n        uniform float uAmbient;\n        varying float vElevation;\n        varying vec3 vBiome;\n        varying vec3 vNormal;\n        varying vec3 vWorldPos;\n\n        // Color palettes for biomes\n        vec3 biomeCold(float h) {\n          // tundra/ice/rock based on elevation\n          vec3 ice = vec3(0.85, 0.92, 0.98);\n          vec3 rock = vec3(0.45, 0.47, 0.5);\n          vec3 snow = mix(rock, ice, smoothstep(0.35, 0.60, h));\n          return snow;\n        }\n        vec3 biomeTemperate(float h) {\n          vec3 grassLow = vec3(0.17, 0.38, 0.16);\n          vec3 grassHigh = vec3(0.35, 0.58, 0.28);\n          vec3 rock = vec3(0.4, 0.4, 0.42);\n          vec3 g = mix(grassLow, grassHigh, smoothstep(0.12, 0.45, h));\n          return mix(g, rock, smoothstep(0.6, 0.85, h));\n        }\n        vec3 biomeDesert(float h) {\n          vec3 sand = vec3(0.82, 0.72, 0.49);\n          vec3 dune = vec3(0.92, 0.84, 0.62);\n          vec3 rock = vec3(0.6, 0.55, 0.45);\n          vec3 base = mix(sand, dune, smoothstep(0.05, 0.2, h));\n          return mix(base, rock, smoothstep(0.55, 0.8, h));\n        }\n\n        // Soft shadowing via lambert with wrap and rim\n        void main() {\n          // Elevation mapped to [0,1] relative to planet scale knowledge on CPU side\n          float h = clamp((vElevation + 0.18) / (2.0 * 0.18), 0.0, 1.0);\n\n          // Biome blend\n          vec3 cCold = biomeCold(h);\n          vec3 cTemp = biomeTemperate(h);\n          vec3 cDes = biomeDesert(h);\n\n          vec3 biomeColor =\n              vBiome.x * cCold +\n              vBiome.y * cTemp +\n              vBiome.z * cDes;\n\n          // Subtle albedo variation by elevation\n          biomeColor *= mix(0.88, 1.08, smoothstep(0.0, 1.0, h));\n\n          // Lighting: wrap lambert + rim\n          vec3 N = normalize(vNormal);\n          vec3 L = normalize(uLightDir);\n          float ndl = dot(N, L);\n          float wrap = 0.4;\n          float diff = clamp((ndl + wrap) / (1.0 + wrap), 0.0, 1.0);\n\n          // Rim light opposite to light and camera\n          vec3 V = normalize(cameraPosition - vWorldPos);\n          float rim = pow(1.0 - max(dot(N, V), 0.0), 2.0) * 0.5;\n\n          vec3 lightColor = vec3(1.0, 0.98, 0.94);\n          vec3 col = biomeColor * (uAmbient + diff * 1.2) + rim * 0.08 * lightColor;\n\n          gl_FragColor = vec4(col, 1.0);\n        }\n      `;\n        }\n\n        function waterVertexShader() {\n            return `\n        precision highp float;\n        uniform float uTime;\n        varying vec3 vNormal;\n        varying vec3 vWorldPos;\n        void main() {\n          vNormal = normalize(normalMatrix * normal);\n          vec4 wp = modelMatrix * vec4(position, 1.0);\n          vWorldPos = wp.xyz;\n          gl_Position = projectionMatrix * viewMatrix * wp;\n        }\n      `;\n        }\n\n        function waterFragmentShader() {\n            return `\n        precision highp float;\n        uniform float uTime;\n        uniform vec3 uColorDeep;\n        uniform vec3 uColorShallow;\n        uniform vec3 uFresnelColor;\n        uniform float uOpacity;\n        varying vec3 vNormal;\n        varying vec3 vWorldPos;\n\n        float fresnel(vec3 n, vec3 v, float bias, float scale, float power){\n          return bias + scale * pow(1.0 + dot(n, v), power);\n        }\n\n        void main() {\n          vec3 N = normalize(vNormal);\n          vec3 V = normalize(cameraPosition - vWorldPos);\n\n          // Simple animated banding for wave tint\n          float w = sin(vWorldPos.x * 2.5 + uTime * 0.6) * 0.04\n                  + cos(vWorldPos.z * 3.1 - uTime * 0.45) * 0.03;\n          float shade = clamp(0.5 + w, 0.0, 1.0);\n\n          vec3 base = mix(uColorDeep, uColorShallow, shade);\n          float f = fresnel(N, V, 0.04, 0.96, 3.0);\n\n          vec3 col = mix(base, uFresnelColor, f * 0.25);\n          gl_FragColor = vec4(col, uOpacity);\n        }\n      `;\n        }\n\n        function cloudsVertexShader() {\n            return `\n        precision highp float;\n        uniform float uTime;\n        varying vec3 vDir;\n        varying vec3 vWorldPos;\n        void main() {\n          vec4 wp = modelMatrix * vec4(position, 1.0);\n          vWorldPos = wp.xyz;\n          vDir = normalize(position);\n          gl_Position = projectionMatrix * viewMatrix * wp;\n        }\n      `;\n        }\n\n        function cloudsFragmentShader() {\n            return `\n        precision highp float;\n        uniform float uTime;\n        uniform float uOpacity;\n        varying vec3 vDir;\n        varying vec3 vWorldPos;\n\n        // 3D hash-based noise (cheap)\n        float hash(vec3 p) {\n          p = fract(p * 0.3183099 + vec3(0.1,0.2,0.3));\n          p *= 17.0;\n          return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n        }\n        float noise(vec3 p) {\n          vec3 i = floor(p);\n          vec3 f = fract(p);\n          f = f*f*(3.0-2.0*f);\n          float n000 = hash(i + vec3(0.0,0.0,0.0));\n          float n100 = hash(i + vec3(1.0,0.0,0.0));\n          float n010 = hash(i + vec3(0.0,1.0,0.0));\n          float n110 = hash(i + vec3(1.0,1.0,0.0));\n          float n001 = hash(i + vec3(0.0,0.0,1.0));\n          float n101 = hash(i + vec3(1.0,0.0,1.0));\n          float n011 = hash(i + vec3(0.0,1.0,1.0));\n          float n111 = hash(i + vec3(1.0,1.0,1.0));\n          float n00 = mix(n000, n100, f.x);\n          float n01 = mix(n001, n101, f.x);\n          float n10 = mix(n010, n110, f.x);\n          float n11 = mix(n011, n111, f.x);\n          float n0 = mix(n00, n10, f.y);\n          float n1 = mix(n01, n11, f.y);\n          return mix(n0, n1, f.z);\n        }\n\n        float fbm(vec3 p) {\n          float f = 0.0;\n          float a = 0.5;\n          for(int i=0; i<5; i++) {\n            f += noise(p) * a;\n            p *= 2.1;\n            a *= 0.55;\n          }\n          return f;\n        }\n\n        void main() {\n          // Drift clouds slowly\n          vec3 p = vDir * 6.0;\n          p.y += uTime * 0.02;\n          p.x += uTime * 0.01;\n\n          float c = fbm(p);\n          c = smoothstep(0.58, 0.82, c);\n\n          // Lighting approximation using light coming from +X,+Y,+Z\n          vec3 L = normalize(vec3(0.6, 0.8, 0.5));\n          float s = 0.35 + 0.65 * clamp(dot(normalize(vWorldPos), L), 0.0, 1.0);\n\n          vec3 cloudCol = vec3(1.0) * s;\n          float alpha = c * uOpacity;\n\n          if (alpha < 0.02) discard;\n          gl_FragColor = vec4(cloudCol, alpha);\n        }\n      `;\n        }\n\n        function atmosphereVertexShader() {\n            return `\n        precision highp float;\n        varying vec3 vWorldPos;\n        varying vec3 vNormal;\n        void main() {\n          vec4 wp = modelMatrix * vec4(position, 1.0);\n          vWorldPos = wp.xyz;\n          vNormal = normalize(normalMatrix * normal);\n          gl_Position = projectionMatrix * viewMatrix * wp;\n        }\n      `;\n        }\n\n        function atmosphereFragmentShader() {\n            return `\n        precision highp float;\n        uniform float uIntensity;\n        uniform vec3 uColor;\n        varying vec3 vWorldPos;\n        varying vec3 vNormal;\n\n        void main() {\n          vec3 V = normalize(cameraPosition - vWorldPos);\n          float viewDot = max(dot(V, -normalize(vNormal)), 0.0);\n          float glow = pow(viewDot, 1.5);\n          vec3 col = uColor * glow * uIntensity;\n          gl_FragColor = vec4(col, glow * 0.9);\n        }\n      `;\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        function onKeyDown(e) {\n            if (e.code === 'Space') {\n                paused = !paused;\n                const toggle = document.getElementById('pauseToggle');\n                toggle.checked = paused;\n            } else if (e.code === 'ArrowUp') {\n                rotationSpeed = Math.min(rotationSpeed + 0.02, 1.2);\n                document.getElementById('rotSpeed').value = String(rotationSpeed);\n            } else if (e.code === 'ArrowDown') {\n                rotationSpeed = Math.max(rotationSpeed - 0.02, 0.0);\n                document.getElementById('rotSpeed').value = String(rotationSpeed);\n            } else if (e.code === 'KeyR') {\n                // Reseed terrain and clouds\n                reseed = Math.random() * 1000;\n                // Rebuild planet geometry and attributes\n                const newGeo = new THREE.SphereGeometry(params.radius, params.segments, params.segments);\n                displaceTerrain(newGeo);\n                planet.geometry.dispose();\n                planet.geometry = newGeo;\n            }\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n            const delta = clock.getDelta();\n            const time = clock.getElapsedTime();\n\n            // Day-night light movement\n            sunLight.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), params.dayNightSpeed * delta);\n            planetMaterial.uniforms.uLightDir.value.copy(sunLight.position).normalize();\n\n            if (!paused) {\n                planet.rotation.y += rotationSpeed * delta;\n                clouds.rotation.y += rotationSpeed * 1.2 * delta;\n                water.rotation.y += rotationSpeed * 0.9 * delta;\n            }\n\n            // Time uniforms\n            planetMaterial.uniforms.uTime.value = time;\n            waterMaterial.uniforms.uTime.value = time;\n            cloudsMaterial.uniforms.uTime.value = time;\n\n            controls.update();\n            renderer.render(scene, camera);\n        }\n    </script>\n</body>\n\n</html>",
  "metadata": {
    "model": "horizon-beta",
    "prompt": "Objective: Create a realistic, procedurally generated 3D planet in Three.js that includes detailed terrain, biomes, and atmospheric effects. The planet should be visually appealing and optimized for performance. Requirements: 1. PlanetGeometry: • Use a spherical geometry (THREE.SphereGeometry) as the base. •Modify the sphere's surface with noise (e.g., Perlin or Simplex) to create realistic terrain features like mountains, valleys, and plains. 2. Biomes and Textures: •Divide the planet into biomes (e.g., deserts, forests, tundras, oceans) based on elevation and latitude. • Use procedural color mapping to assign textures based on biome (e.g., sandy textures for deserts, green for forests, blue for oceans). •Consider blending textures smoothly between biomes. 3. Atmosphere: • Add asemi-transparent atmospheric layer around the planet using THREE.ShaderMaterial. • Implement a gradient color effect for the atmosphere(e.g., blue near the surface fading to black in space). • Add subtle glow effects for realism. 4. Lighting: • Use a directional light to simulate the sun, casting realistic shadows across the planet's surface. • Add ambient lighting to ensure details are visible in shadowed regions. • Implement dynamic lighting to simulate day-night cycles as the planet rotates. 5. Water: • Include procedural oceans with reflective and slightly transparent materials. • Simulate waves or surface distortion using shaders or displacement maps. 6. Clouds: • Add a separate spherical layer above the surface for clouds. • Use procedural noise to generate cloud patterns. •Animate the clouds to move slowly across the planet. 7. Rotation: • Make the planet rotate on its axis at a realistic speed. • Allow the user to pause or adjust the rotation speed. 8. Camera and Interaction: • Position the camera to give a clear view of the planet. • Allow the user to zoom in and out and rotate the camera. Use template bellow.",
    "timestamp": "2025-08-03T10:25:08.159Z",
    "tags": [
      "threejs"
    ],
    "description": "Our procedural planet generator starts with a noise-displaced THREE.SphereGeometry to sculpt mountains, valleys, and plains, then classifies each point by elevation and latitude into biomes—desert, forest, tundra, ocean—and smoothly blends their shaders; sea-level areas get a reflective, wave-distorted water material, a surrounding ShaderMaterial layer creates a blue-to-black atmospheric glow, and a drifting noise-based cloud sphere adds realism; a directional “sun” light plus ambient fill drive a day-night cycle as the globe rotates, all viewable via an orbiting, zoomable camera with performance optimizations like LOD and frustum culling."
  }
}
