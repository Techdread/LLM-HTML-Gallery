{
  "title": "3D Container with 55 Boxes - JSON Output",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>3D Container with 55 Boxes - JSON Output</title>\r\n    <style>\r\n        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #111; color: #fff; }\r\n        #info {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            background-color: rgba(0, 0, 0, 0.7);\r\n            padding: 10px;\r\n            border-radius: 5px;\r\n            border: 1px solid #555;\r\n            min-width: 200px;\r\n            z-index: 10; /* Ensure it's above JSON output */\r\n        }\r\n        #info h3 { margin-top: 0; }\r\n        #info p { margin: 5px 0; }\r\n        #controls {\r\n            position: absolute;\r\n            bottom: 10px; /* Adjusted position */\r\n            left: 10px;\r\n            background-color: rgba(0, 0, 0, 0.7);\r\n            padding: 10px;\r\n            border-radius: 5px;\r\n            border: 1px solid #555;\r\n            z-index: 10;\r\n        }\r\n         #jsonOutputContainer { /* New container for JSON */\r\n            position: absolute;\r\n            bottom: 60px; /* Position above controls */\r\n            left: 10px;\r\n            width: 350px; /* Adjust width as needed */\r\n            max-height: 200px; /* Limit height */\r\n            background-color: rgba(0, 0, 0, 0.7);\r\n            padding: 10px;\r\n            border-radius: 5px;\r\n            border: 1px solid #555;\r\n            z-index: 5; /* Below info/controls but above canvas */\r\n            display: flex; /* Use flexbox for layout */\r\n            flex-direction: column; /* Stack label and textarea vertically */\r\n        }\r\n        #jsonOutputContainer label {\r\n            margin-bottom: 5px;\r\n            font-weight: bold;\r\n            color: #ccc;\r\n        }\r\n        #jsonDataOutput { /* Style the textarea */\r\n            width: 100%;\r\n            flex-grow: 1; /* Allow textarea to fill remaining height */\r\n            background-color: #222;\r\n            color: #ddd;\r\n            border: 1px solid #444;\r\n            border-radius: 3px;\r\n            font-family: monospace;\r\n            font-size: 0.8em;\r\n            resize: none; /* Disable manual resizing */\r\n            white-space: pre; /* Preserve formatting */\r\n            overflow: auto; /* Add scrollbars if needed */\r\n        }\r\n        canvas { display: block; } /* Prevent scrollbars */\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"info\">\r\n        <h3>Box Information</h3>\r\n        <p>Click on a box to see its details.</p>\r\n        <p id=\"box-id\">ID: -</p>\r\n        <p id=\"box-dims\">Dimensions: -</p>\r\n        <p id=\"box-vol\">Volume: -</p>\r\n    </div>\r\n\r\n    <div id=\"controls\">\r\n        <label>\r\n            <input type=\"checkbox\" id=\"visibilityToggle\" disabled> Toggle Selected Box Visibility\r\n        </label>\r\n    </div>\r\n\r\n    <div id=\"jsonOutputContainer\">\r\n        <label for=\"jsonDataOutput\">Generated Box Data (JSON):</label>\r\n        <textarea id=\"jsonDataOutput\" readonly rows=\"10\"></textarea>\r\n    </div>\r\n\r\n\r\n    <script async src=\"https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js\"></script>\r\n\r\n    <script type=\"importmap\">\r\n        {\r\n            \"imports\": {\r\n                \"three\": \"https://unpkg.com/three@0.163.0/build/three.module.js\",\r\n                \"three/addons/\": \"https://unpkg.com/three@0.163.0/examples/jsm/\"\r\n            }\r\n        }\r\n    </script>\r\n\r\n    <script type=\"module\">\r\n        import * as THREE from 'three';\r\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\n\r\n        // --- Configuration ---\r\n        const containerDimensions = { w: 1200, h: 1000, d: 1200 };\r\n        const targetBoxCount = 55;\r\n        const highlightColor = 0xffff00; // Yellow\r\n\r\n        // --- Global Variables ---\r\n        let scene, camera, renderer, controls;\r\n        let raycaster, mouse;\r\n        let containerMesh;\r\n        let internalBoxesGroup; // Group to hold the 55 boxes\r\n        let clickableBoxes = []; // Array to store meshes for raycasting\r\n        let selectedBoxMesh = null;\r\n        const infoPanel = {\r\n            id: document.getElementById('box-id'),\r\n            dims: document.getElementById('box-dims'),\r\n            vol: document.getElementById('box-vol'),\r\n            title: document.querySelector('#info h3'),\r\n            defaultText: document.querySelector('#info p'),\r\n        };\r\n        const visibilityToggle = document.getElementById('visibilityToggle');\r\n        const jsonOutputTextarea = document.getElementById('jsonDataOutput'); // Reference to the textarea\r\n\r\n        // --- Algorithm: Generate Box Data ---\r\n        // [ SAME generateBoxes function as before - no changes needed here ]\r\n        function generateBoxes(containerW, containerH, containerD, count) {\r\n            let boxIdCounter = 0;\r\n            const boxes = []; // Final list of box data { id, x, y, z, w, h, d, volume }\r\n            let spaces = [ // Initial space is the whole container\r\n                { x: 0, y: 0, z: 0, w: containerW, h: containerH, d: containerD }\r\n            ];\r\n\r\n            while (spaces.length < count) {\r\n                if (spaces.length === 0) {\r\n                    console.error(\"Ran out of spaces before reaching target count.\");\r\n                    break;\r\n                }\r\n\r\n                // Find the space with the largest volume to split\r\n                let largestSpaceIndex = 0;\r\n                let largestVolume = 0;\r\n                for (let i = 0; i < spaces.length; i++) {\r\n                    const vol = spaces[i].w * spaces[i].h * spaces[i].d;\r\n                    if (vol > largestVolume) {\r\n                        largestVolume = vol;\r\n                        largestSpaceIndex = i;\r\n                    }\r\n                }\r\n\r\n                const spaceToSplit = spaces.splice(largestSpaceIndex, 1)[0];\r\n\r\n                // Decide which axis to split along (prefer the longest dimension)\r\n                let axis;\r\n                const dims = [spaceToSplit.w, spaceToSplit.h, spaceToSplit.d];\r\n                const maxDim = Math.max(...dims);\r\n                if (maxDim === spaceToSplit.w) axis = 'x';\r\n                else if (maxDim === spaceToSplit.h) axis = 'y';\r\n                else axis = 'z';\r\n\r\n                // Calculate split point (slightly randomized around middle to encourage dimension variety)\r\n                let splitCoord;\r\n                let dimSize;\r\n                switch (axis) {\r\n                    case 'x': dimSize = spaceToSplit.w; break;\r\n                    case 'y': dimSize = spaceToSplit.h; break;\r\n                    case 'z': dimSize = spaceToSplit.d; break;\r\n                }\r\n\r\n                // Ensure split results in integer dimensions > 0\r\n                if (dimSize < 2) {\r\n                     spaces.push(spaceToSplit);\r\n                     console.warn(\"Cannot split space further:\", spaceToSplit);\r\n                      if (spaces.length + boxes.length >= count) {\r\n                         while(spaces.length > 0 && boxes.length < count) {\r\n                             const finalSpace = spaces.pop();\r\n                             boxes.push({\r\n                                 id: boxIdCounter++,\r\n                                 x: finalSpace.x, y: finalSpace.y, z: finalSpace.z,\r\n                                 w: finalSpace.w, h: finalSpace.h, d: finalSpace.d,\r\n                                 volume: finalSpace.w * finalSpace.h * finalSpace.d\r\n                             });\r\n                         }\r\n                         break; // Exit the main loop\r\n                     }\r\n                     continue; // Try splitting another box in the next iteration\r\n                }\r\n\r\n                const randomFactor = 0.4 + Math.random() * 0.2; // Split between 40% and 60%\r\n                splitCoord = Math.floor(dimSize * randomFactor);\r\n                if (splitCoord <= 0) splitCoord = 1;\r\n                if (splitCoord >= dimSize) splitCoord = dimSize - 1;\r\n\r\n                // Create the two new spaces\r\n                const space1 = { ...spaceToSplit };\r\n                const space2 = { ...spaceToSplit };\r\n\r\n                switch (axis) {\r\n                    case 'x':\r\n                        space1.w = splitCoord;\r\n                        space2.x = spaceToSplit.x + splitCoord;\r\n                        space2.w = spaceToSplit.w - splitCoord;\r\n                        break;\r\n                    case 'y':\r\n                        space1.h = splitCoord;\r\n                        space2.y = spaceToSplit.y + splitCoord;\r\n                        space2.h = spaceToSplit.h - splitCoord;\r\n                        break;\r\n                    case 'z':\r\n                        space1.d = splitCoord;\r\n                        space2.z = spaceToSplit.z + splitCoord;\r\n                        space2.d = spaceToSplit.d - splitCoord;\r\n                        break;\r\n                }\r\n\r\n                 if(space1.w > 0 && space1.h > 0 && space1.d > 0) spaces.push(space1);\r\n                 if(space2.w > 0 && space2.h > 0 && space2.d > 0) spaces.push(space2);\r\n            }\r\n\r\n             if (boxes.length === 0) {\r\n                 spaces.forEach(space => {\r\n                     boxes.push({\r\n                         id: boxIdCounter++,\r\n                         x: space.x, y: space.y, z: space.z,\r\n                         w: space.w, h: space.h, d: space.d,\r\n                         volume: space.w * space.h * space.d\r\n                     });\r\n                 });\r\n             }\r\n\r\n            let totalVolume = 0;\r\n            boxes.forEach(b => totalVolume += b.volume);\r\n            console.log(`Generated ${boxes.length} boxes.`);\r\n            console.log(`Target Volume: ${containerW * containerH * containerD}`);\r\n            console.log(`Sum of Box Volumes: ${totalVolume}`);\r\n            if (boxes.length !== count || totalVolume !== containerW * containerH * containerD) {\r\n                 console.warn(\"Volume or count mismatch!\");\r\n            }\r\n\r\n            const dimensionStrings = new Set();\r\n            let duplicateDimensions = 0;\r\n            boxes.forEach(b => {\r\n                const dims = [b.w, b.h, b.d].sort((a,b) => a-b).join(',');\r\n                if (dimensionStrings.has(dims)) {\r\n                    duplicateDimensions++;\r\n                }\r\n                dimensionStrings.add(dims);\r\n            });\r\n             if (duplicateDimensions > 0) {\r\n                 console.warn(`Algorithm resulted in ${duplicateDimensions} boxes with non-unique dimension triplets.`);\r\n             } else {\r\n                  console.log(\"All generated boxes have unique dimension triplets.\");\r\n             }\r\n\r\n            return boxes;\r\n        }\r\n\r\n        // --- ThreeJS Initialization ---\r\n        function init() {\r\n            // Scene\r\n            scene = new THREE.Scene();\r\n            scene.background = new THREE.Color(0x1a1a1a);\r\n\r\n            // Camera\r\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 10, 5000);\r\n             camera.position.set(\r\n                 containerDimensions.w * 0.8,\r\n                 containerDimensions.h * 1.0,\r\n                 containerDimensions.d * 0.8\r\n             );\r\n             camera.lookAt(0, 0, 0);\r\n\r\n\r\n            // Renderer\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            document.body.appendChild(renderer.domElement);\r\n\r\n            // Controls\r\n            controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n             controls.target.set(containerDimensions.w / 2, containerDimensions.h / 2, containerDimensions.d / 2);\r\n             controls.update();\r\n\r\n\r\n            // Lighting\r\n            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);\r\n            scene.add(ambientLight);\r\n            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\r\n            directionalLight.position.set(1, 1, 1).normalize();\r\n            scene.add(directionalLight);\r\n\r\n            // Raycaster\r\n            raycaster = new THREE.Raycaster();\r\n            mouse = new THREE.Vector2();\r\n\r\n            // --- Create Geometry ---\r\n\r\n            // Main Container\r\n            const containerGeo = new THREE.BoxGeometry(containerDimensions.w, containerDimensions.h, containerDimensions.d);\r\n            const containerMat = new THREE.MeshBasicMaterial({\r\n                color: 0xaaaaaa,\r\n                transparent: true,\r\n                opacity: 0.15,\r\n                depthWrite: false\r\n            });\r\n            containerMesh = new THREE.Mesh(containerGeo, containerMat);\r\n            containerMesh.position.set(containerDimensions.w / 2, containerDimensions.h / 2, containerDimensions.d / 2);\r\n            scene.add(containerMesh);\r\n\r\n             const edges = new THREE.EdgesGeometry( containerGeo );\r\n             const lineMat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 1 } );\r\n             const wireframe = new THREE.LineSegments( edges, lineMat );\r\n             wireframe.position.copy(containerMesh.position);\r\n             scene.add( wireframe );\r\n\r\n\r\n            // Internal Boxes\r\n            internalBoxesGroup = new THREE.Group();\r\n            scene.add(internalBoxesGroup);\r\n\r\n            // *** Generate Box Data ***\r\n            const boxData = generateBoxes(containerDimensions.w, containerDimensions.h, containerDimensions.d, targetBoxCount);\r\n\r\n            // *** Output Box Data as JSON ***\r\n            const boxDataJson = JSON.stringify(boxData, null, 2); // Pretty print JSON\r\n            jsonOutputTextarea.value = boxDataJson; // Set textarea content\r\n            console.log(\"--- Generated Box Data (JSON) ---\");\r\n            console.log(boxDataJson); // Log to console\r\n            console.log(\"---------------------------------\");\r\n\r\n            // *** Create Meshes from Box Data ***\r\n            boxData.forEach(box => {\r\n                const geometry = new THREE.BoxGeometry(box.w, box.h, box.d);\r\n                const randomColor = Math.random() * 0xffffff;\r\n                const material = new THREE.MeshStandardMaterial({\r\n                    color: randomColor,\r\n                    metalness: 0.2,\r\n                    roughness: 0.8,\r\n                });\r\n                const mesh = new THREE.Mesh(geometry, material);\r\n                mesh.position.set(\r\n                    box.x + box.w / 2,\r\n                    box.y + box.h / 2,\r\n                    box.z + box.d / 2\r\n                );\r\n\r\n                 const boxEdges = new THREE.EdgesGeometry( geometry );\r\n                 const boxOutlineMat = new THREE.LineBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.3 } );\r\n                 const boxOutline = new THREE.LineSegments( boxEdges, boxOutlineMat );\r\n                 mesh.add( boxOutline );\r\n\r\n                mesh.userData = {\r\n                    id: box.id,\r\n                    dimensions: { w: box.w, h: box.h, d: box.d },\r\n                    volume: box.volume,\r\n                    originalMaterial: material,\r\n                    outlineMaterial: boxOutlineMat\r\n                };\r\n\r\n                internalBoxesGroup.add(mesh);\r\n                clickableBoxes.push(mesh);\r\n            });\r\n\r\n            // --- Event Listeners ---\r\n            window.addEventListener('resize', onWindowResize);\r\n            window.addEventListener('pointerdown', onPointerDown);\r\n            visibilityToggle.addEventListener('change', onVisibilityToggleChange);\r\n\r\n            // Initial Info Panel State\r\n            resetInfoPanel();\r\n        }\r\n\r\n        // --- Event Handlers ---\r\n        // [ SAME onWindowResize, onPointerDown, onVisibilityToggleChange functions as before ]\r\n         function onWindowResize() {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n\r\n        function onPointerDown(event) {\r\n            // Adjust mouse calculation if the canvas is not full window or has offset\r\n            const rect = renderer.domElement.getBoundingClientRect();\r\n            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n\r\n            raycaster.setFromCamera(mouse, camera);\r\n            const intersects = raycaster.intersectObjects(clickableBoxes);\r\n\r\n            if (intersects.length > 0) {\r\n                const clickedObject = intersects[0].object;\r\n                 if (clickedObject !== selectedBoxMesh) {\r\n                     selectBox(clickedObject);\r\n                 } else {\r\n                     deselectBox();\r\n                 }\r\n            } else {\r\n                 if (selectedBoxMesh) {\r\n                     deselectBox();\r\n                 }\r\n            }\r\n        }\r\n\r\n        function onVisibilityToggleChange() {\r\n            if (selectedBoxMesh) {\r\n                const isVisible = !visibilityToggle.checked;\r\n                selectedBoxMesh.visible = isVisible;\r\n                // Also toggle outline visibility (assuming it's the first child)\r\n                 if (selectedBoxMesh.children.length > 0) {\r\n                    selectedBoxMesh.children[0].visible = isVisible;\r\n                 }\r\n            }\r\n        }\r\n\r\n\r\n        // --- Interaction Logic ---\r\n        // [ SAME deselectBox, selectBox, resetInfoPanel functions as before ]\r\n        function deselectBox() {\r\n             if (selectedBoxMesh) {\r\n                 selectedBoxMesh.material = selectedBoxMesh.userData.originalMaterial;\r\n                  if (selectedBoxMesh.userData.outlineMaterial) {\r\n                     selectedBoxMesh.userData.outlineMaterial.color.set(0xffffff);\r\n                     selectedBoxMesh.userData.outlineMaterial.opacity = 0.3;\r\n                  }\r\n                 selectedBoxMesh = null;\r\n                 resetInfoPanel();\r\n                 visibilityToggle.checked = false;\r\n                 visibilityToggle.disabled = true;\r\n             }\r\n         }\r\n\r\n         function selectBox(boxMesh) {\r\n             deselectBox();\r\n             selectedBoxMesh = boxMesh;\r\n\r\n              if (selectedBoxMesh.material.color) {\r\n                  selectedBoxMesh.material = selectedBoxMesh.material.clone();\r\n                  selectedBoxMesh.material.color.setHex(highlightColor);\r\n                   if (selectedBoxMesh.userData.outlineMaterial) {\r\n                      selectedBoxMesh.userData.outlineMaterial.color.setHex(highlightColor);\r\n                      selectedBoxMesh.userData.outlineMaterial.opacity = 0.9;\r\n                   }\r\n              } else {\r\n                  console.warn(\"Selected mesh material doesn't have a standard color property for highlighting.\");\r\n              }\r\n\r\n             infoPanel.title.textContent = `Selected Box Info`;\r\n             infoPanel.defaultText.style.display = 'none';\r\n             infoPanel.id.textContent = `ID: ${selectedBoxMesh.userData.id}`;\r\n             const dims = selectedBoxMesh.userData.dimensions;\r\n             infoPanel.dims.textContent = `Dimensions: ${dims.w} x ${dims.h} x ${dims.d}`;\r\n             infoPanel.vol.textContent = `Volume: ${selectedBoxMesh.userData.volume.toLocaleString()}`;\r\n\r\n             visibilityToggle.checked = !selectedBoxMesh.visible;\r\n             visibilityToggle.disabled = false;\r\n         }\r\n\r\n         function resetInfoPanel() {\r\n             infoPanel.title.textContent = `Box Information`;\r\n             infoPanel.defaultText.style.display = 'block';\r\n             infoPanel.id.textContent = `ID: -`;\r\n             infoPanel.dims.textContent = `Dimensions: -`;\r\n             infoPanel.vol.textContent = `Volume: -`;\r\n         }\r\n\r\n\r\n        // --- Animation Loop ---\r\n        // [ SAME animate function as before ]\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n            controls.update();\r\n            renderer.render(scene, camera);\r\n        }\r\n\r\n        // --- Start ---\r\n        init();\r\n        animate();\r\n\r\n    </script>\r\n</body>\r\n</html>",
  "id": "container-divide-55-json-box-gemini-pro-2-5",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.905Z",
    "model": "gemini-pro-2.5",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, architecture."
  }
}
