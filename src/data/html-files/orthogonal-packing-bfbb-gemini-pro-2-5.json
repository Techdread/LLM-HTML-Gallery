{
  "title": "Orthogonal Rectangular Packing (BFBB + Three.js)",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Orthogonal Rectangular Packing (BFBB + Three.js)</title>\r\n    <script src=\"https://cdn.tailwindcss.com\"></script>\r\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js\"></script>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            font-family: 'Inter', sans-serif;\r\n            background-color: #f3f4f6;\r\n        }\r\n\r\n        canvas {\r\n            display: block;\r\n        }\r\n\r\n        #container {\r\n            display: flex;\r\n            flex-direction: column;\r\n            height: 100vh;\r\n        }\r\n\r\n        #controls {\r\n            padding: 1rem;\r\n            background-color: white;\r\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\r\n            z-index: 10;\r\n            max-height: 40vh;\r\n            /* Limit control panel height */\r\n            overflow-y: auto;\r\n            /* Add scroll if needed */\r\n        }\r\n\r\n        #visualization {\r\n            flex-grow: 1;\r\n            position: relative;\r\n            /* Needed for overlay */\r\n            min-height: 60vh;\r\n            /* Ensure visualization area has height */\r\n        }\r\n\r\n        #messageBox {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 50%;\r\n            transform: translateX(-50%);\r\n            background-color: rgba(0, 0, 0, 0.7);\r\n            color: white;\r\n            padding: 10px 20px;\r\n            border-radius: 5px;\r\n            z-index: 100;\r\n            display: none;\r\n            /* Hidden by default */\r\n            text-align: center;\r\n        }\r\n\r\n        /* Simple Priority Queue Styling (Optional) */\r\n        .priority-queue-item {\r\n            border: 1px solid #eee;\r\n            padding: 2px 4px;\r\n            margin-bottom: 2px;\r\n            font-size: 0.8em;\r\n            background-color: #fafafa;\r\n        }\r\n\r\n        /* Style the button */\r\n        button {\r\n            background-color: #4CAF50;\r\n            /* Green */\r\n            border: none;\r\n            color: white;\r\n            padding: 10px 20px;\r\n            text-align: center;\r\n            text-decoration: none;\r\n            display: inline-block;\r\n            font-size: 16px;\r\n            margin: 4px 2px;\r\n            cursor: pointer;\r\n            border-radius: 8px;\r\n            transition: background-color 0.3s ease;\r\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\r\n        }\r\n\r\n        button:hover {\r\n            background-color: #45a049;\r\n        }\r\n\r\n        button:disabled {\r\n            background-color: #cccccc;\r\n            cursor: not-allowed;\r\n        }\r\n\r\n        textarea {\r\n            border: 1px solid #ccc;\r\n            border-radius: 4px;\r\n            padding: 8px;\r\n            width: 100%;\r\n            min-height: 80px;\r\n            font-family: monospace;\r\n        }\r\n\r\n        label {\r\n            font-weight: bold;\r\n            margin-bottom: 0.5rem;\r\n            display: block;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"container\">\r\n        <div id=\"controls\" class=\"space-y-4\">\r\n            <h1 class=\"text-xl font-bold text-gray-800\">Orthogonal Rectangular Packing</h1>\r\n            <div>\r\n                <label for=\"piecesInput\">Input Pieces (JSON format: [{id, l, w, b}, ...]):</label>\r\n                <textarea id=\"piecesInput\" placeholder='[\r\n  {\"id\": \"A\", \"l\": 5, \"w\": 4, \"b\": 1},\r\n  {\"id\": \"B\", \"l\": 3, \"w\": 6, \"b\": 1},\r\n  {\"id\": \"C\", \"l\": 4, \"w\": 4, \"b\": 1}\r\n]'>[\r\n  {\"id\": \"R1\", \"l\": 4, \"w\": 3, \"b\": 1},\r\n  {\"id\": \"R2\", \"l\": 2, \"w\": 5, \"b\": 1},\r\n  {\"id\": \"R3\", \"l\": 3, \"w\": 3, \"b\": 1}\r\n]</textarea>\r\n            </div>\r\n            <div>\r\n                <label for=\"maxNodes\">Max Nodes to Explore (Performance Limit):</label>\r\n                <input type=\"number\" id=\"maxNodes\" value=\"5000\" class=\"border rounded p-1 w-32\">\r\n            </div>\r\n            <button id=\"startButton\">Start Packing</button>\r\n            <div id=\"output\" class=\"text-sm text-gray-700 space-y-1\">\r\n                <p>Status: Ready</p>\r\n                <p>Optimal Area Found: N/A</p>\r\n                <p>Dimensions (L x W): N/A</p>\r\n                <p>Nodes Explored: 0</p>\r\n                <p>Time Taken: 0 ms</p>\r\n            </div>\r\n        </div>\r\n        <div id=\"visualization\">\r\n            <div id=\"messageBox\"></div>\r\n        </div>\r\n    </div>\r\n\r\n    <script type=\"module\">\r\n        // --- Three.js Setup ---\r\n        let scene, camera, renderer, controls, mainContainer, vizContainer;\r\n        let packedGroup = new THREE.Group(); // Group to hold packed items\r\n\r\n        function initThreeJS() {\r\n            vizContainer = document.getElementById('visualization');\r\n            if (!vizContainer) {\r\n                console.error(\"Visualization container not found!\");\r\n                return;\r\n            }\r\n\r\n            // Scene\r\n            scene = new THREE.Scene();\r\n            scene.background = new THREE.Color(0xf3f4f6); // Match body background\r\n\r\n            // Camera\r\n            const aspect = vizContainer.clientWidth / vizContainer.clientHeight;\r\n            // Adjust camera position based on expected packing size - start further out\r\n            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);\r\n            camera.position.set(10, 10, 20); // Positioned to look down slightly at XY plane\r\n            camera.lookAt(0, 0, 0);\r\n\r\n            // Renderer\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setSize(vizContainer.clientWidth, vizContainer.clientHeight);\r\n            vizContainer.appendChild(renderer.domElement);\r\n\r\n            // Lights\r\n            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\r\n            scene.add(ambientLight);\r\n            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\r\n            directionalLight.position.set(5, 10, 7.5);\r\n            scene.add(directionalLight);\r\n\r\n            // Controls\r\n            controls = new THREE.OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true; // Smooths camera movement\r\n            controls.dampingFactor = 0.05;\r\n            controls.screenSpacePanning = false;\r\n            controls.maxPolarAngle = Math.PI / 2; // Prevent looking from below\r\n\r\n            // Add packed group to scene\r\n            scene.add(packedGroup);\r\n\r\n            // Handle Resize\r\n            window.addEventListener('resize', onWindowResize, false);\r\n\r\n            // Start animation loop\r\n            animate();\r\n        }\r\n\r\n        function onWindowResize() {\r\n            if (!vizContainer || !renderer || !camera) return;\r\n            camera.aspect = vizContainer.clientWidth / vizContainer.clientHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(vizContainer.clientWidth, vizContainer.clientHeight);\r\n        }\r\n\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n            controls.update(); // Only required if controls.enableDamping or autoRotate are set to true\r\n            renderer.render(scene, camera);\r\n        }\r\n\r\n        function clearVisualization() {\r\n            // Remove all children from the packedGroup\r\n            while (packedGroup.children.length > 0) {\r\n                packedGroup.remove(packedGroup.children[0]);\r\n            }\r\n            // Optionally remove bounding box if drawn\r\n            const existingBox = scene.getObjectByName(\"boundingBox\");\r\n            if (existingBox) {\r\n                scene.remove(existingBox);\r\n            }\r\n        }\r\n\r\n        // Function to generate distinct colors\r\n        function getRandomColor(seed) {\r\n            // Simple pseudo-random color based on a seed string (like piece ID)\r\n            let hash = 0;\r\n            for (let i = 0; i < seed.length; i++) {\r\n                hash = seed.charCodeAt(i) + ((hash << 5) - hash);\r\n                hash = hash & hash; // Convert to 32bit integer\r\n            }\r\n            // Generate color components - avoid very dark/light colors\r\n            const r = (hash & 0xFF0000) >> 16;\r\n            const g = (hash & 0x00FF00) >> 8;\r\n            const b = hash & 0x0000FF;\r\n            // Ensure some brightness\r\n            const brightnessFactor = 0.5;\r\n            const finalR = Math.min(255, Math.max(50, Math.floor(r * brightnessFactor + 128 * (1 - brightnessFactor))));\r\n            const finalG = Math.min(255, Math.max(50, Math.floor(g * brightnessFactor + 128 * (1 - brightnessFactor))));\r\n            const finalB = Math.min(255, Math.max(50, Math.floor(b * brightnessFactor + 128 * (1 - brightnessFactor))));\r\n\r\n            return new THREE.Color(`rgb(${finalR}, ${finalG}, ${finalB})`);\r\n        }\r\n\r\n\r\n        // --- Packing Node Tree ---\r\n        // Represents the structure of a packing (how pieces are combined)\r\n        class PackingNode {\r\n            constructor({ isLeaf = false, piece = null, children = null, buildType = null, l = 0, w = 0, x = 0, y = 0 }) {\r\n                this.isLeaf = isLeaf; // boolean: true if this is an original piece\r\n                this.piece = piece;   // Original Piece object {id, l, w} (if leaf)\r\n                this.children = children; // [PackingNode, PackingNode] (if internal node)\r\n                this.buildType = buildType; // 'horizontal' or 'vertical' (if internal node)\r\n                this.l = l; // length (x-dimension) of this node's bounding box\r\n                this.w = w; // width (y-dimension) of this node's bounding box\r\n                this.x = x; // x-position relative to parent (or absolute if root)\r\n                this.y = y; // y-position relative to parent (or absolute if root)\r\n                this.area = this.l * this.w;\r\n            }\r\n        }\r\n\r\n        // --- RPacking State (for BFBB Algorithm) ---\r\n        // Represents a state (a potential packing) in the search space\r\n        class RPacking {\r\n            constructor({ node, pieceCounts, totalPieceCounts }) {\r\n                this.node = node; // Root PackingNode of the layout tree\r\n                this.l = node.l;  // Overall length\r\n                this.w = node.w;  // Overall width\r\n                this.G = this.l * this.w; // Gross area of the bounding box\r\n                this.pieceCounts = pieceCounts; // Map { piece_id: count } of pieces *in this packing*\r\n                this.totalPieceCounts = totalPieceCounts; // Map { piece_id: count } of *all* target pieces\r\n\r\n                // Calculate g (sum of areas of pieces included)\r\n                this.g = 0;\r\n                for (const pieceId in this.pieceCounts) {\r\n                    const pieceInfo = this.findPieceInfo(pieceId); // Find original dimensions\r\n                    if (pieceInfo) {\r\n                        this.g += pieceInfo.l * pieceInfo.w * this.pieceCounts[pieceId];\r\n                    } else {\r\n                        console.warn(`Piece info not found for ID: ${pieceId} during g calculation`);\r\n                    }\r\n                }\r\n\r\n                this.c = this.G - this.g; // Waste\r\n\r\n                // Calculate remaining counts\r\n                this.remainingCounts = { ...this.totalPieceCounts };\r\n                for (const pieceId in this.pieceCounts) {\r\n                    this.remainingCounts[pieceId] -= this.pieceCounts[pieceId];\r\n                }\r\n\r\n                // Check if terminal (all pieces included)\r\n                this.isTerminal = Object.values(this.remainingCounts).every(count => count === 0);\r\n\r\n                // Calculate h' (lower bound estimate for remaining pieces' area)\r\n                this.h_prime = 0;\r\n                for (const pieceId in this.remainingCounts) {\r\n                    if (this.remainingCounts[pieceId] > 0) {\r\n                        const pieceInfo = this.findPieceInfo(pieceId);\r\n                        if (pieceInfo) {\r\n                            this.h_prime += pieceInfo.l * pieceInfo.w * this.remainingCounts[pieceId];\r\n                        } else {\r\n                            console.warn(`Piece info not found for ID: ${pieceId} during h' calculation`);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Calculate f' (lower bound estimate for the total area)\r\n                this.f_prime = this.G + this.h_prime;\r\n            }\r\n\r\n            // Helper to find original piece dimensions (assumes piecesData is accessible)\r\n            findPieceInfo(pieceId) {\r\n                // piecesData should be available in the scope where RPacking is used\r\n                return piecesData.find(p => p.id === pieceId);\r\n            }\r\n\r\n            // Generate a unique key for this packing state based on dimensions and piece counts\r\n            getKey() {\r\n                const sortedCounts = Object.entries(this.pieceCounts)\r\n                    .sort(([idA], [idB]) => idA.localeCompare(idB))\r\n                    .map(([id, count]) => `${id}:${count}`)\r\n                    .join(',');\r\n                // Using dimensions and counts should be reasonably unique for non-rotated orthogonal packing\r\n                return `L${this.l}W${this.w}_C[${sortedCounts}]`;\r\n            }\r\n        }\r\n\r\n        // --- Simple Priority Queue ---\r\n        class PriorityQueue {\r\n            constructor() {\r\n                this.items = [];\r\n            }\r\n\r\n            enqueue(item, priority) {\r\n                this.items.push({ item, priority });\r\n                this.items.sort((a, b) => a.priority - b.priority); // Simple sort, inefficient for large queues\r\n            }\r\n\r\n            dequeue() {\r\n                if (this.isEmpty()) {\r\n                    return null;\r\n                }\r\n                return this.items.shift().item; // Remove and return the item with the lowest priority\r\n            }\r\n\r\n            peek() {\r\n                if (this.isEmpty()) {\r\n                    return null;\r\n                }\r\n                return this.items[0].item;\r\n            }\r\n\r\n            isEmpty() {\r\n                return this.items.length === 0;\r\n            }\r\n\r\n            size() {\r\n                return this.items.length;\r\n            }\r\n\r\n            // For debugging: get top N items\r\n            getTopN(n) {\r\n                return this.items.slice(0, n);\r\n            }\r\n        }\r\n\r\n\r\n        // --- BFBB Algorithm ---\r\n        let piecesData = []; // To store parsed input pieces {id, l, w, b}\r\n        let allPieceInstances = []; // Expanded list of individual pieces {id, l, w, instanceId}\r\n        let totalPieceCounts = {}; // Target counts {id: b}\r\n        let nodesExplored = 0;\r\n        let maxNodesToExplore = 5000; // Performance limit\r\n\r\n        function combinePieceCounts(counts1, counts2) {\r\n            const combined = { ...counts1 };\r\n            for (const pieceId in counts2) {\r\n                combined[pieceId] = (combined[pieceId] || 0) + counts2[pieceId];\r\n            }\r\n            return combined;\r\n        }\r\n\r\n        function checkDemandConstraints(combinedCounts, totalCounts) {\r\n            for (const pieceId in combinedCounts) {\r\n                if (combinedCounts[pieceId] > (totalCounts[pieceId] || 0)) {\r\n                    return false; // Exceeded demand for this piece type\r\n                }\r\n            }\r\n            return true; // Constraints met\r\n        }\r\n\r\n        // --- Build Functions ---\r\n        function buildHorizontal(rpack1, rpack2) {\r\n            const combinedCounts = combinePieceCounts(rpack1.pieceCounts, rpack2.pieceCounts);\r\n            if (!checkDemandConstraints(combinedCounts, totalPieceCounts)) {\r\n                return null; // Invalid combination\r\n            }\r\n\r\n            const newL = rpack1.l + rpack2.l;\r\n            const newW = Math.max(rpack1.w, rpack2.w);\r\n\r\n            // Create the new layout node\r\n            // Place rpack1 at (0,0) relative to the new node's origin\r\n            // Place rpack2 at (rpack1.l, 0) relative to the new node's origin\r\n            const newNode = new PackingNode({\r\n                isLeaf: false,\r\n                children: [rpack1.node, rpack2.node], // Order matters for relative positioning\r\n                buildType: 'horizontal',\r\n                l: newL,\r\n                w: newW,\r\n                x: 0, // Root node has 0,0 absolute position initially\r\n                y: 0\r\n            });\r\n            // Adjust children's relative positions (might not be strictly needed if traversal calculates absolute)\r\n            rpack1.node.x = 0;\r\n            rpack1.node.y = 0;\r\n            rpack2.node.x = rpack1.l;\r\n            rpack2.node.y = 0;\r\n\r\n\r\n            return new RPacking({\r\n                node: newNode,\r\n                pieceCounts: combinedCounts,\r\n                totalPieceCounts: totalPieceCounts\r\n            });\r\n        }\r\n\r\n        function buildVertical(rpack1, rpack2) {\r\n            const combinedCounts = combinePieceCounts(rpack1.pieceCounts, rpack2.pieceCounts);\r\n            if (!checkDemandConstraints(combinedCounts, totalPieceCounts)) {\r\n                return null; // Invalid combination\r\n            }\r\n\r\n            const newL = Math.max(rpack1.l, rpack2.l);\r\n            const newW = rpack1.w + rpack2.w;\r\n\r\n            // Create the new layout node\r\n            // Place rpack1 at (0,0) relative to the new node's origin\r\n            // Place rpack2 at (0, rpack1.w) relative to the new node's origin\r\n            const newNode = new PackingNode({\r\n                isLeaf: false,\r\n                children: [rpack1.node, rpack2.node], // Order matters\r\n                buildType: 'vertical',\r\n                l: newL,\r\n                w: newW,\r\n                x: 0,\r\n                y: 0\r\n            });\r\n            // Adjust children's relative positions\r\n            rpack1.node.x = 0;\r\n            rpack1.node.y = 0;\r\n            rpack2.node.x = 0;\r\n            rpack2.node.y = rpack1.w;\r\n\r\n\r\n            return new RPacking({\r\n                node: newNode,\r\n                pieceCounts: combinedCounts,\r\n                totalPieceCounts: totalPieceCounts\r\n            });\r\n        }\r\n\r\n        // --- Main BFBB Function ---\r\n        function bestFirstBranchAndBound() {\r\n            nodesExplored = 0;\r\n            const startTime = performance.now();\r\n\r\n            const E1 = new PriorityQueue(); // Open list (subproblems to explore)\r\n            const E2 = new Map(); // Closed list {key: RPacking} (explored subproblems) - Use Map for quick lookup\r\n\r\n            let Opt = Infinity; // Best total area found so far\r\n            let bestTerminalPacking = null;\r\n\r\n            // 1. Initialization\r\n            allPieceInstances.forEach(piece => {\r\n                const initialNode = new PackingNode({\r\n                    isLeaf: true,\r\n                    piece: piece, // Store the specific instance info if needed, or just type\r\n                    l: piece.l,\r\n                    w: piece.w,\r\n                    x: 0,\r\n                    y: 0\r\n                });\r\n                const initialCounts = { [piece.id]: 1 };\r\n                const initialPacking = new RPacking({\r\n                    node: initialNode,\r\n                    pieceCounts: initialCounts,\r\n                    totalPieceCounts: totalPieceCounts\r\n                });\r\n                // Enqueue initial pieces only if their f_prime is potentially useful (though f_prime includes h')\r\n                E1.enqueue(initialPacking, initialPacking.f_prime);\r\n                // Don't add to E2 yet\r\n            });\r\n\r\n            if (E1.isEmpty()) {\r\n                updateStatus(\"No pieces to pack.\", 0, 0);\r\n                return null;\r\n            }\r\n\r\n            updateStatus(\"Running...\", nodesExplored, performance.now() - startTime);\r\n\r\n            // 2. Main Loop\r\n            while (!E1.isEmpty()) {\r\n                const R = E1.dequeue(); // Get packing with lowest f'\r\n\r\n                // Performance Cutoff\r\n                nodesExplored++;\r\n                if (nodesExplored > maxNodesToExplore) {\r\n                    console.warn(`Reached max node limit (${maxNodesToExplore}). Stopping search.`);\r\n                    showMessage(`Search stopped: Reached max node limit (${maxNodesToExplore}). Result might be suboptimal.`);\r\n                    break;\r\n                }\r\n\r\n                // Pruning: If current best estimate is already worse than Opt, skip\r\n                // (Also handles the termination condition Opt - f_min <= 0)\r\n                if (R.f_prime >= Opt) {\r\n                    continue; // Don't explore this path further\r\n                }\r\n\r\n                // Avoid re-exploring identical states (based on key)\r\n                const rKey = R.getKey();\r\n                if (E2.has(rKey) && E2.get(rKey).f_prime <= R.f_prime) {\r\n                    continue; // Already found a state as good or better\r\n                }\r\n                E2.set(rKey, R); // Add/Update explored state\r\n\r\n                // Update Debug UI (Optional, can slow things down)\r\n                // if (nodesExplored % 50 === 0) {\r\n                //     updateDebugQueue(E1);\r\n                //     updateStatus(\"Running...\", nodesExplored, performance.now() - startTime, Opt);\r\n                // }\r\n\r\n\r\n                // Check if Terminal\r\n                if (R.isTerminal) {\r\n                    if (R.G < Opt) {\r\n                        Opt = R.G;\r\n                        bestTerminalPacking = R;\r\n                        console.log(`Found new best terminal packing: Area = ${Opt}, L=${R.l}, W=${R.w}`);\r\n                        // Update Opt immediately to help prune other branches\r\n                        updateStatus(\"Running... (New best found)\", nodesExplored, performance.now() - startTime, Opt, R.l, R.w);\r\n                    }\r\n                    // Continue searching even after finding a terminal packing,\r\n                    // as other branches might yield a better one.\r\n                    continue; // No need to expand a terminal node\r\n                }\r\n\r\n\r\n                // 3. Expansion: Generate Successors (Combine R with elements in E2)\r\n                // The paper says \"combine R with elements of E2 (including R)\"\r\n                // This implies combining R with *all* previously explored states.\r\n                // Let's iterate through E2 values.\r\n\r\n                const e2Values = Array.from(E2.values()); // Get all explored packings\r\n\r\n                e2Values.forEach(R_prev => {\r\n                    // Try Horizontal Build (R_prev on left, R on right)\r\n                    const H1 = buildHorizontal(R_prev, R);\r\n                    if (H1 && H1.f_prime < Opt) {\r\n                        const h1Key = H1.getKey();\r\n                        if (!E2.has(h1Key) || E2.get(h1Key).f_prime > H1.f_prime) {\r\n                            E1.enqueue(H1, H1.f_prime);\r\n                        }\r\n                    }\r\n                    // Try Horizontal Build (R on left, R_prev on right)\r\n                    const H2 = buildHorizontal(R, R_prev);\r\n                    if (H2 && H2.f_prime < Opt) {\r\n                        const h2Key = H2.getKey();\r\n                        if (!E2.has(h2Key) || E2.get(h2Key).f_prime > H2.f_prime) {\r\n                            E1.enqueue(H2, H2.f_prime);\r\n                        }\r\n                    }\r\n\r\n                    // Try Vertical Build (R_prev on bottom, R on top)\r\n                    const V1 = buildVertical(R_prev, R);\r\n                    if (V1 && V1.f_prime < Opt) {\r\n                        const v1Key = V1.getKey();\r\n                        if (!E2.has(v1Key) || E2.get(v1Key).f_prime > V1.f_prime) {\r\n                            E1.enqueue(V1, V1.f_prime);\r\n                        }\r\n                    }\r\n                    // Try Vertical Build (R on bottom, R_prev on top)\r\n                    const V2 = buildVertical(R, R_prev);\r\n                    if (V2 && V2.f_prime < Opt) {\r\n                        const v2Key = V2.getKey();\r\n                        if (!E2.has(v2Key) || E2.get(v2Key).f_prime > V2.f_prime) {\r\n                            E1.enqueue(V2, V2.f_prime);\r\n                        }\r\n                    }\r\n                });\r\n\r\n            } // End while loop\r\n\r\n            const endTime = performance.now();\r\n            const duration = endTime - startTime;\r\n\r\n            if (bestTerminalPacking) {\r\n                updateStatus(`Finished. Optimal Area: ${Opt}`, nodesExplored, duration, Opt, bestTerminalPacking.l, bestTerminalPacking.w);\r\n                console.log(`Optimal Packing Found: Area=${Opt}, L=${bestTerminalPacking.l}, W=${bestTerminalPacking.w}`);\r\n                return bestTerminalPacking;\r\n            } else {\r\n                let finalMessage = \"Finished. No feasible packing found.\";\r\n                if (nodesExplored >= maxNodesToExplore) {\r\n                    finalMessage = `Finished (Max nodes reached). No feasible packing found within limit.`;\r\n                }\r\n                updateStatus(finalMessage, nodesExplored, duration);\r\n                console.log(\"No feasible packing found.\");\r\n                showMessage(finalMessage);\r\n                return null;\r\n            }\r\n        }\r\n\r\n\r\n        // --- Visualization Drawing ---\r\n        function drawFinalPacking(terminalPacking) {\r\n            clearVisualization();\r\n            if (!terminalPacking) return;\r\n\r\n            const rootNode = terminalPacking.node;\r\n            const finalWidth = rootNode.l;\r\n            const finalHeight = rootNode.w;\r\n\r\n            // Center the packing visually\r\n            const offsetX = -finalWidth / 2;\r\n            const offsetY = -finalHeight / 2;\r\n\r\n            // Recursive function to traverse the tree and draw leaf nodes (pieces)\r\n            function drawNode(node, currentX, currentY) {\r\n                if (node.isLeaf) {\r\n                    const piece = node.piece;\r\n                    const geometry = new THREE.PlaneGeometry(piece.l, piece.w);\r\n                    const material = new THREE.MeshLambertMaterial({\r\n                        color: getRandomColor(piece.id), // Color by piece type ID\r\n                        side: THREE.DoubleSide\r\n                    });\r\n                    const mesh = new THREE.Mesh(geometry, material);\r\n\r\n                    // Calculate center position for the plane\r\n                    const posX = currentX + piece.l / 2 + offsetX;\r\n                    const posY = currentY + piece.w / 2 + offsetY;\r\n                    mesh.position.set(posX, posY, 0); // Place on XY plane\r\n\r\n                    // Add outline for clarity\r\n                    const edges = new THREE.EdgesGeometry(geometry);\r\n                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 }); // Thicker line\r\n                    const lineSegments = new THREE.LineSegments(edges, lineMaterial);\r\n                    mesh.add(lineSegments); // Add outline as child of mesh\r\n\r\n                    packedGroup.add(mesh);\r\n                } else {\r\n                    // Recursively draw children based on build type\r\n                    const [child1, child2] = node.children;\r\n                    if (node.buildType === 'horizontal') {\r\n                        // Child1 is at (currentX, currentY)\r\n                        // Child2 is at (currentX + child1.l, currentY)\r\n                        drawNode(child1, currentX, currentY);\r\n                        drawNode(child2, currentX + child1.l, currentY);\r\n                    } else if (node.buildType === 'vertical') {\r\n                        // Child1 is at (currentX, currentY)\r\n                        // Child2 is at (currentX, currentY + child1.w)\r\n                        drawNode(child1, currentX, currentY);\r\n                        drawNode(child2, currentX, currentY + child1.w);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Start drawing from the root node at logical origin (0,0)\r\n            drawNode(rootNode, 0, 0);\r\n\r\n\r\n            // Draw bounding box outline for the final packing\r\n            const boxGeom = new THREE.PlaneGeometry(finalWidth, finalHeight);\r\n            const boxEdges = new THREE.EdgesGeometry(boxGeom);\r\n            const boxLineMat = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 3 });\r\n            const boxLine = new THREE.LineSegments(boxEdges, boxLineMat);\r\n            boxLine.position.set(offsetX + finalWidth / 2, offsetY + finalHeight / 2, -0.01); // Slightly behind pieces\r\n            boxLine.name = \"boundingBox\";\r\n            scene.add(boxLine);\r\n\r\n\r\n            // Adjust camera to view the packing\r\n            const maxSize = Math.max(finalWidth, finalHeight);\r\n            const distance = maxSize * 1.5; // Adjust multiplier as needed\r\n            camera.position.set(0, 0, distance);\r\n            camera.lookAt(0, 0, 0);\r\n            controls.target.set(0, 0, 0); // Ensure controls focus on the center\r\n            controls.update();\r\n\r\n            showMessage(`Packing complete! Area: ${terminalPacking.G.toFixed(2)}`);\r\n\r\n        }\r\n\r\n        // --- UI Interaction ---\r\n        const piecesInput = document.getElementById('piecesInput');\r\n        const startButton = document.getElementById('startButton');\r\n        const outputDiv = document.getElementById('output');\r\n        const maxNodesInput = document.getElementById('maxNodes');\r\n        const messageBox = document.getElementById('messageBox');\r\n        // const e1ListDiv = document.getElementById('e1List'); // Debug\r\n\r\n        function showMessage(text, duration = 3000) {\r\n            messageBox.textContent = text;\r\n            messageBox.style.display = 'block';\r\n            setTimeout(() => {\r\n                messageBox.style.display = 'none';\r\n            }, duration);\r\n        }\r\n\r\n        function updateStatus(statusText, nodes = nodesExplored, time = 0, optArea = null, optL = null, optW = null) {\r\n            outputDiv.innerHTML = `\r\n                <p>Status: ${statusText}</p>\r\n                <p>Optimal Area Found: ${optArea !== null && optArea !== Infinity ? optArea.toFixed(2) : 'N/A'}</p>\r\n                <p>Dimensions (L x W): ${optL !== null ? `${optL.toFixed(2)} x ${optW.toFixed(2)}` : 'N/A'}</p>\r\n                <p>Nodes Explored: ${nodes}</p>\r\n                <p>Time Taken: ${time.toFixed(0)} ms</p>\r\n            `;\r\n        }\r\n\r\n        // function updateDebugQueue(queue) {\r\n        //      const topItems = queue.getTopN(5);\r\n        //      e1ListDiv.innerHTML = topItems.map(item =>\r\n        //         `<div class=\"priority-queue-item\">f': ${item.priority.toFixed(2)}, G: ${item.item.G.toFixed(1)}, L: ${item.item.l}, W: ${item.item.w}, Counts: ${JSON.stringify(item.item.pieceCounts)}</div>`\r\n        //     ).join('');\r\n        // }\r\n\r\n\r\n        startButton.addEventListener('click', () => {\r\n            startButton.disabled = true;\r\n            startButton.textContent = \"Running...\";\r\n            updateStatus(\"Parsing input...\");\r\n            clearVisualization(); // Clear previous viz\r\n\r\n            try {\r\n                piecesData = JSON.parse(piecesInput.value);\r\n                if (!Array.isArray(piecesData) || piecesData.some(p => typeof p.l !== 'number' || typeof p.w !== 'number' || typeof p.b !== 'number' || typeof p.id === 'undefined')) {\r\n                    throw new Error(\"Invalid input format. Ensure it's an array of {id, l, w, b} objects.\");\r\n                }\r\n\r\n                // Expand pieces based on demand 'b'\r\n                allPieceInstances = [];\r\n                totalPieceCounts = {};\r\n                let instanceCounter = 0;\r\n                piecesData.forEach(p => {\r\n                    totalPieceCounts[p.id] = p.b;\r\n                    for (let i = 0; i < p.b; i++) {\r\n                        allPieceInstances.push({\r\n                            ...p,\r\n                            instanceId: `${p.id}_${i}` // Unique ID for each instance\r\n                        });\r\n                    }\r\n                });\r\n\r\n                maxNodesToExplore = parseInt(maxNodesInput.value, 10) || 5000;\r\n\r\n\r\n                // Use setTimeout to allow UI update before potentially long calculation\r\n                setTimeout(() => {\r\n                    const resultPacking = bestFirstBranchAndBound();\r\n                    drawFinalPacking(resultPacking);\r\n                    startButton.disabled = false;\r\n                    startButton.textContent = \"Start Packing\";\r\n                }, 50); // Short delay\r\n\r\n            } catch (error) {\r\n                console.error(\"Input Error:\", error);\r\n                updateStatus(`Error: ${error.message}`);\r\n                showMessage(`Error: ${error.message}`);\r\n                startButton.disabled = false;\r\n                startButton.textContent = \"Start Packing\";\r\n            }\r\n        });\r\n\r\n        // --- Initialization ---\r\n        initThreeJS();\r\n        updateStatus(\"Ready\"); // Initial status\r\n\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "orthogonal-packing-bfbb-gemini-pro-2-5",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders"
    ],
    "timestamp": "2025-08-04T21:59:57.971Z",
    "model": "gemini-pro-2.5",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders."
  }
}
