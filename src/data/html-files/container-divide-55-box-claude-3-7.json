{
  "title": "3D Container Visualization",
  "htmlContent": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>3D Container Visualization</title>\n\n    <!-- Import Map for ES Modules -->\n    <script type=\"importmap\">\n        {\n          \"imports\": {\n            \"three\": \"https://cdn.skypack.dev/three@0.128.0\",\n            \"three/addons/\": \"https://cdn.skypack.dev/three@0.128.0/examples/jsm/\"\n          }\n        }\n    </script>\n\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n            font-family: Arial, sans-serif;\n            display: flex;\n            flex-direction: column;\n            height: 100vh;\n        }\n        #container {\n            flex: 1;\n            position: relative;\n        }\n        #info-panel {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            background-color: rgba(0, 0, 0, 0.7);\n            color: white;\n            padding: 15px;\n            border-radius: 5px;\n            width: 300px;\n            z-index: 100;\n        }\n        #box-info {\n            margin-top: 10px;\n            font-size: 14px;\n        }\n        h1 {\n            margin: 0 0 10px 0;\n            font-size: 18px;\n        }\n        #controls {\n            margin-top: 15px;\n        }\n        button {\n            padding: 8px 12px;\n            margin-right: 5px;\n            cursor: pointer;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        .toggle-label {\n            color: white;\n            margin-left: 5px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"container\"></div>\n    <div id=\"info-panel\">\n        <h1>3D Container Visualization</h1>\n        <div>Container dimensions: 1200×1000×1200</div>\n        <div>Total boxes: 55</div>\n        <div id=\"box-info\">Click on a box to see its details</div>\n        <div id=\"controls\">\n            <button id=\"toggle-container\">Toggle Container</button>\n            <button id=\"toggle-selected\">Toggle Selected Box</button>\n            <button id=\"reset-view\">Reset View</button>\n        </div>\n    </div>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n        // Main variables\n        let scene, camera, renderer, controls;\n        let container, boxes = [];\n        let raycaster = new THREE.Raycaster();\n        let mouse = new THREE.Vector2();\n        let selectedBox = null;\n        let containerVisible = true;\n        \n        // Container dimensions\n        const containerWidth = 1200;\n        const containerHeight = 1000;\n        const containerDepth = 1200;\n        \n        // Initialize the scene\n        function init() {\n            // Create scene\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(0x111133);\n            \n            // Create camera\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);\n            camera.position.set(1500, 1500, 1500);\n            \n            // Create renderer\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            document.getElementById('container').appendChild(renderer.domElement);\n            \n            // Add orbit controls\n            controls = new OrbitControls(camera, renderer.domElement);\n            controls.enableDamping = true;\n            controls.dampingFactor = 0.05;\n            \n            // Add lights\n            const ambientLight = new THREE.AmbientLight(0x404040, 1);\n            scene.add(ambientLight);\n            \n            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);\n            directionalLight1.position.set(1, 1, 1);\n            scene.add(directionalLight1);\n            \n            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);\n            directionalLight2.position.set(-1, -1, -1);\n            scene.add(directionalLight2);\n            \n            // Create container box\n            createContainer();\n            \n            // Generate and create internal boxes\n            const boxesData = generateBoxes();\n            createBoxes(boxesData);\n            \n            // Event listeners\n            window.addEventListener('resize', onWindowResize);\n            renderer.domElement.addEventListener('click', onClick);\n            \n            // UI Control buttons\n            document.getElementById('toggle-container').addEventListener('click', toggleContainer);\n            document.getElementById('toggle-selected').addEventListener('click', toggleSelectedBox);\n            document.getElementById('reset-view').addEventListener('click', resetView);\n            \n            // Start animation loop\n            animate();\n        }\n        \n        // Create container box (wireframe)\n        function createContainer() {\n            const geometry = new THREE.BoxGeometry(containerWidth, containerHeight, containerDepth);\n            const edges = new THREE.EdgesGeometry(geometry);\n            container = new THREE.LineSegments(\n                edges,\n                new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })\n            );\n            \n            // Center the container at origin\n            container.position.set(0, 0, 0);\n            scene.add(container);\n            \n            // Add semi-transparent faces\n            const material = new THREE.MeshBasicMaterial({\n                color: 0xffffff,\n                transparent: true,\n                opacity: 0.05,\n                side: THREE.DoubleSide\n            });\n            const containerMesh = new THREE.Mesh(geometry, material);\n            containerMesh.position.set(0, 0, 0);\n            container.add(containerMesh);\n        }\n        \n        // Algorithm to generate 55 unique boxes that fill the container\n        function generateBoxes() {\n            // Strategy: Binary space partitioning with adjustments to ensure unique dimensions\n            // We'll start with the full container and recursively divide it\n            \n            const boxes = [];\n            const minDimension = 100; // Minimum box dimension\n            \n            // Initialize with the full container positioned at the origin (center)\n            const initialBox = {\n                x: -containerWidth / 2,\n                y: -containerHeight / 2,\n                z: -containerDepth / 2,\n                width: containerWidth,\n                height: containerHeight,\n                depth: containerDepth\n            };\n            \n            // Use a queue to process boxes\n            const queue = [initialBox];\n            \n            // Keep track of dimensions used to ensure uniqueness\n            const usedDimensions = new Set();\n            \n            // Function to check if dimensions are unique\n            function areDimensionsUnique(w, h, d) {\n                // We consider dimensions unique if the combination of width, height, depth is unique\n                // Order matters for our visualization (e.g., 100x200x300 is different from 200x100x300)\n                const key = `${w}_${h}_${d}`;\n                if (usedDimensions.has(key)) {\n                    return false;\n                }\n                usedDimensions.add(key);\n                return true;\n            }\n            \n            // Function to split a box into two parts\n            function splitBox(box, axis, ratio) {\n                const box1 = { ...box };\n                const box2 = { ...box };\n                \n                if (axis === 'x') {\n                    const splitWidth = Math.floor(box.width * ratio);\n                    box1.width = splitWidth;\n                    box2.width = box.width - splitWidth;\n                    box2.x = box.x + splitWidth;\n                } else if (axis === 'y') {\n                    const splitHeight = Math.floor(box.height * ratio);\n                    box1.height = splitHeight;\n                    box2.height = box.height - splitHeight;\n                    box2.y = box.y + splitHeight;\n                } else { // axis === 'z'\n                    const splitDepth = Math.floor(box.depth * ratio);\n                    box1.depth = splitDepth;\n                    box2.depth = box.depth - splitDepth;\n                    box2.z = box.z + splitDepth;\n                }\n                \n                return [box1, box2];\n            }\n            \n            // Function to find the best split for a box\n            function findBestSplit(box) {\n                // Try to split along each axis with different ratios\n                const possibleSplits = [];\n                \n                // Try different ratios for splitting\n                const ratios = [0.3, 0.4, 0.5, 0.6, 0.7];\n                \n                for (const ratio of ratios) {\n                    for (const axis of ['x', 'y', 'z']) {\n                        // Skip if the resulting dimensions would be too small\n                        if (axis === 'x' && (box.width * ratio < minDimension || box.width * (1-ratio) < minDimension)) continue;\n                        if (axis === 'y' && (box.height * ratio < minDimension || box.height * (1-ratio) < minDimension)) continue;\n                        if (axis === 'z' && (box.depth * ratio < minDimension || box.depth * (1-ratio) < minDimension)) continue;\n                        \n                        const [box1, box2] = splitBox(box, axis, ratio);\n                        \n                        // Check if both resulting boxes would have unique dimensions\n                        if (areDimensionsUnique(box1.width, box1.height, box1.depth) && \n                            areDimensionsUnique(box2.width, box2.height, box2.depth)) {\n                            possibleSplits.push({ axis, ratio, uniqueness: 2 });\n                        } else if (areDimensionsUnique(box1.width, box1.height, box1.depth) || \n                                  areDimensionsUnique(box2.width, box2.height, box2.depth)) {\n                            possibleSplits.push({ axis, ratio, uniqueness: 1 });\n                        } else {\n                            possibleSplits.push({ axis, ratio, uniqueness: 0 });\n                        }\n                        \n                        // Remove the dimensions we just checked from the used set\n                        // since we haven't actually added these boxes yet\n                        usedDimensions.delete(`${box1.width}_${box1.height}_${box1.depth}`);\n                        usedDimensions.delete(`${box2.width}_${box2.height}_${box2.depth}`);\n                    }\n                }\n                \n                // Sort by uniqueness (prefer splits that result in unique dimensions)\n                possibleSplits.sort((a, b) => b.uniqueness - a.uniqueness);\n                \n                // Return the best split or null if no valid split found\n                return possibleSplits.length > 0 ? possibleSplits[0] : null;\n            }\n            \n            // Add small variations to ensure uniqueness if needed\n            function ensureUniqueDimensions(box) {\n                const original = { ...box };\n                let attempts = 0;\n                const maxAttempts = 100;\n                \n                while (!areDimensionsUnique(box.width, box.height, box.depth) && attempts < maxAttempts) {\n                    // Reset to original dimensions\n                    box.width = original.width;\n                    box.height = original.height;\n                    box.depth = original.depth;\n                    \n                    // Apply small adjustments\n                    box.width = Math.max(minDimension, box.width + Math.floor(Math.random() * 21) - 10);\n                    box.height = Math.max(minDimension, box.height + Math.floor(Math.random() * 21) - 10);\n                    box.depth = Math.max(minDimension, box.depth + Math.floor(Math.random() * 21) - 10);\n                    \n                    attempts++;\n                }\n                \n                if (attempts >= maxAttempts) {\n                    // If we've tried too many times, make a more dramatic change\n                    box.width = Math.max(minDimension, original.width + 50 + Math.floor(Math.random() * 50));\n                    box.height = Math.max(minDimension, original.height + 50 + Math.floor(Math.random() * 50));\n                    box.depth = Math.max(minDimension, original.depth + 50 + Math.floor(Math.random() * 50));\n                    \n                    // Make one final attempt to ensure uniqueness\n                    areDimensionsUnique(box.width, box.height, box.depth);\n                }\n                \n                return box;\n            }\n            \n            // Main box generation loop\n            while (boxes.length < 55 && queue.length > 0) {\n                const currentBox = queue.shift();\n                \n                if (boxes.length === 54 && queue.length === 0) {\n                    // Last box - add as is if dimensions are unique, or adjust if needed\n                    const finalBox = ensureUniqueDimensions(currentBox);\n                    boxes.push(finalBox);\n                } else {\n                    // Find best split for current box\n                    const bestSplit = findBestSplit(currentBox);\n                    \n                    if (bestSplit) {\n                        // Split the box\n                        const [box1, box2] = splitBox(currentBox, bestSplit.axis, bestSplit.ratio);\n                        \n                        // Add box1 to final boxes (if we need more than one more box)\n                        if (boxes.length < 54) {\n                            boxes.push(box1);\n                            areDimensionsUnique(box1.width, box1.height, box1.depth); // Mark dimensions as used\n                            queue.push(box2);\n                        } else {\n                            // We only need one more box after this, so add both to queue\n                            // and let the algorithm choose the best one\n                            queue.push(box1, box2);\n                        }\n                    } else {\n                        // If no good split found, add current box as is (after ensuring uniqueness)\n                        const uniqueBox = ensureUniqueDimensions(currentBox);\n                        boxes.push(uniqueBox);\n                    }\n                }\n            }\n            \n            // Constraint check: no box touches more than 3 of container's outer faces\n            boxes.forEach(box => {\n                let touchCount = 0;\n                \n                // Check if the box touches each of the 6 container faces\n                if (box.x <= -containerWidth/2 + 1) touchCount++; // Left face\n                if (box.x + box.width >= containerWidth/2 - 1) touchCount++; // Right face\n                if (box.y <= -containerHeight/2 + 1) touchCount++; // Bottom face\n                if (box.y + box.height >= containerHeight/2 - 1) touchCount++; // Top face\n                if (box.z <= -containerDepth/2 + 1) touchCount++; // Back face\n                if (box.z + box.depth >= containerDepth/2 - 1) touchCount++; // Front face\n                \n                // If a box touches more than 3 faces, adjust it slightly\n                if (touchCount > 3) {\n                    // Shrink the box slightly on each dimension\n                    const shrinkAmount = 10;\n                    if (box.x <= -containerWidth/2 + 1) {\n                        box.x += shrinkAmount;\n                        box.width -= shrinkAmount;\n                    }\n                    if (box.x + box.width >= containerWidth/2 - 1) {\n                        box.width -= shrinkAmount;\n                    }\n                    if (box.y <= -containerHeight/2 + 1) {\n                        box.y += shrinkAmount;\n                        box.height -= shrinkAmount;\n                    }\n                    if (box.y + box.height >= containerHeight/2 - 1) {\n                        box.height -= shrinkAmount;\n                    }\n                    if (box.z <= -containerDepth/2 + 1) {\n                        box.z += shrinkAmount;\n                        box.depth -= shrinkAmount;\n                    }\n                    if (box.z + box.depth >= containerDepth/2 - 1) {\n                        box.depth -= shrinkAmount;\n                    }\n                }\n            });\n            \n            // If we didn't generate enough boxes, fill in with more divisions\n            while (boxes.length < 55) {\n                // Find the largest box to divide\n                const largestBoxIndex = boxes.reduce((maxIndex, box, index, array) => {\n                    const maxBox = array[maxIndex];\n                    const maxVolume = maxBox.width * maxBox.height * maxBox.depth;\n                    const currentVolume = box.width * box.height * box.depth;\n                    return currentVolume > maxVolume ? index : maxIndex;\n                }, 0);\n                \n                const boxToDivide = boxes[largestBoxIndex];\n                boxes.splice(largestBoxIndex, 1); // Remove this box\n                \n                // Determine which axis to split on (prefer the largest dimension)\n                let axis = 'x';\n                if (boxToDivide.height > boxToDivide.width && boxToDivide.height > boxToDivide.depth) {\n                    axis = 'y';\n                } else if (boxToDivide.depth > boxToDivide.width && boxToDivide.depth > boxToDivide.height) {\n                    axis = 'z';\n                }\n                \n                // Split at a random ratio between 0.3 and 0.7\n                const ratio = 0.3 + Math.random() * 0.4;\n                const [box1, box2] = splitBox(boxToDivide, axis, ratio);\n                \n                // Ensure unique dimensions for both new boxes\n                const uniqueBox1 = ensureUniqueDimensions(box1);\n                const uniqueBox2 = ensureUniqueDimensions(box2);\n                \n                boxes.push(uniqueBox1, uniqueBox2);\n            }\n            \n            // Final check: make sure we have exactly 55 boxes\n            console.assert(boxes.length === 55, `Generated ${boxes.length} boxes instead of 55`);\n            \n            // Convert from coordinate system to ThreeJS positioning and return\n            return boxes.map(box => ({\n                width: box.width,\n                height: box.height,\n                depth: box.depth,\n                position: [\n                    box.x + box.width/2,\n                    box.y + box.height/2,\n                    box.z + box.depth/2\n                ]\n            }));\n        }\n        \n        // Create all the internal boxes\n        function createBoxes(boxesData) {\n            // Generate a set of distinguishable colors\n            const colors = [];\n            for (let i = 0; i < 55; i++) {\n                // Use HSL color model to generate evenly distributed colors\n                const hue = (i / 55) * 360;\n                const saturation = 0.7 + Math.random() * 0.3; // 70-100%\n                const lightness = 0.4 + Math.random() * 0.3; // 40-70%\n                \n                const color = new THREE.Color().setHSL(hue/360, saturation, lightness);\n                colors.push(color);\n            }\n            \n            // Create each box\n            boxesData.forEach((boxData, index) => {\n                const [width, height, depth] = [boxData.width, boxData.height, boxData.depth];\n                const [x, y, z] = boxData.position;\n                \n                const geometry = new THREE.BoxGeometry(width, height, depth);\n                const material = new THREE.MeshLambertMaterial({\n                    color: colors[index],\n                    transparent: true,\n                    opacity: 0.8\n                });\n                \n                const box = new THREE.Mesh(geometry, material);\n                box.position.set(x, y, z);\n                \n                // Store original color and dimensions for later reference\n                box.userData = {\n                    originalColor: colors[index].clone(),\n                    width: width,\n                    height: height,\n                    depth: depth,\n                    volume: width * height * depth,\n                    index: index + 1 // 1-based index for display\n                };\n                \n                scene.add(box);\n                boxes.push(box);\n            });\n        }\n        \n        // Handle window resize\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n        \n        // Handle click events for box selection\n        function onClick(event) {\n            // Calculate mouse position in normalized device coordinates (-1 to +1)\n            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n            \n            // Update the raycaster\n            raycaster.setFromCamera(mouse, camera);\n            \n            // Check for intersections with boxes\n            const intersects = raycaster.intersectObjects(boxes);\n            \n            if (intersects.length > 0) {\n                const clickedBox = intersects[0].object;\n                \n                // If clicking on already selected box, deselect it\n                if (selectedBox === clickedBox) {\n                    deselectBox();\n                } else {\n                    // Otherwise, select the clicked box\n                    selectBox(clickedBox);\n                }\n            } else {\n                // Clicked on empty space, deselect current box\n                deselectBox();\n            }\n        }\n        \n        // Select a box\n        function selectBox(box) {\n            // Deselect previous box if any\n            deselectBox();\n            \n            // Highlight the new selected box\n            selectedBox = box;\n            selectedBox.material.emissive = new THREE.Color(0x555555);\n            selectedBox.material.emissiveIntensity = 1;\n            selectedBox.material.opacity = 1.0;\n            \n            // Update info panel\n            const boxInfo = document.getElementById('box-info');\n            const { width, height, depth, volume, index } = box.userData;\n            boxInfo.innerHTML = `\n                <strong>Box #${index}</strong><br>\n                Width: ${width.toFixed(0)}<br>\n                Height: ${height.toFixed(0)}<br>\n                Depth: ${depth.toFixed(0)}<br>\n                Volume: ${volume.toFixed(0)} cubic units\n            `;\n        }\n        \n        // Deselect the currently selected box\n        function deselectBox() {\n            if (selectedBox) {\n                selectedBox.material.emissive = new THREE.Color(0x000000);\n                selectedBox.material.opacity = 0.8;\n                selectedBox = null;\n                \n                // Reset info panel\n                const boxInfo = document.getElementById('box-info');\n                boxInfo.innerHTML = 'Click on a box to see its details';\n            }\n        }\n        \n        // Toggle container visibility\n        function toggleContainer() {\n            containerVisible = !containerVisible;\n            container.visible = containerVisible;\n        }\n        \n        // Toggle visibility of selected box\n        function toggleSelectedBox() {\n            if (selectedBox) {\n                selectedBox.visible = !selectedBox.visible;\n            }\n        }\n        \n        // Reset camera view\n        function resetView() {\n            camera.position.set(1500, 1500, 1500);\n            controls.target.set(0, 0, 0);\n            controls.update();\n        }\n        \n        // Animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n            controls.update();\n            renderer.render(scene, camera);\n        }\n        \n        // Start the application\n        init();\n    </script>\n</body>\n</html>",
  "id": "container-divide-55-box-claude-3-7",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.718Z",
    "model": "claude-3.7",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, architecture."
  }
}
