{
  "title": "Voxel Fire Spread Simulation",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>Voxel Fire Spread Simulation</title>\r\n  <style>\r\n    body {\r\n      margin: 0;\r\n      overflow: hidden;\r\n      font-family: Arial, sans-serif;\r\n    }\r\n    canvas {\r\n      display: block;\r\n    }\r\n    .controls {\r\n      position: absolute;\r\n      top: 10px;\r\n      left: 10px;\r\n      background-color: rgba(0, 0, 0, 0.5);\r\n      padding: 10px;\r\n      border-radius: 5px;\r\n      color: white;\r\n    }\r\n    button {\r\n      background-color: #4CAF50;\r\n      border: none;\r\n      color: white;\r\n      padding: 8px 16px;\r\n      text-align: center;\r\n      text-decoration: none;\r\n      display: inline-block;\r\n      font-size: 14px;\r\n      margin: 4px 2px;\r\n      cursor: pointer;\r\n      border-radius: 4px;\r\n    }\r\n    .instructions {\r\n      position: absolute;\r\n      bottom: 10px;\r\n      left: 10px;\r\n      background-color: rgba(0, 0, 0, 0.5);\r\n      padding: 10px;\r\n      border-radius: 5px;\r\n      color: white;\r\n    }\r\n  </style>\r\n</head>\r\n<body>\r\n  <div class=\"controls\">\r\n    <button id=\"reset\">Reset Simulation</button>\r\n    <button id=\"random-fire\">Random Fire</button>\r\n    <div>\r\n      <label for=\"spread-probability\">Spread Probability: </label>\r\n      <input type=\"range\" id=\"spread-probability\" min=\"0\" max=\"100\" step=\"1\" value=\"30\">\r\n      <span id=\"spread-value\">30%</span>\r\n    </div>\r\n    <div>\r\n      <label for=\"fuel-amount\">Fuel Amount: </label>\r\n      <input type=\"range\" id=\"fuel-amount\" min=\"10\" max=\"100\" step=\"5\" value=\"50\">\r\n      <span id=\"fuel-value\">50</span>\r\n    </div>\r\n  </div>\r\n  \r\n  <div class=\"instructions\">\r\n    <p>Click on a voxel to start a fire | Drag to rotate | Scroll to zoom</p>\r\n  </div>\r\n\r\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\r\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js\"></script>\r\n  <script>\r\n    // Constants\r\n    const GRID_SIZE = 10;\r\n    const VOXEL_SIZE = 1;\r\n    const GAP = 0.05;\r\n    \r\n    // Simulation configuration\r\n    let config = {\r\n      spreadProbability: 0.3,\r\n      fuelAmount: 50\r\n    };\r\n\r\n    // Scene setup\r\n    const scene = new THREE.Scene();\r\n    scene.background = new THREE.Color(0x111122);\r\n\r\n    // Camera setup\r\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n    camera.position.set(GRID_SIZE * 1.5, GRID_SIZE * 1.5, GRID_SIZE * 1.5);\r\n    camera.lookAt(GRID_SIZE/2, GRID_SIZE/2, GRID_SIZE/2);\r\n\r\n    // Renderer setup\r\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\r\n    renderer.setSize(window.innerWidth, window.innerHeight);\r\n    document.body.appendChild(renderer.domElement);\r\n\r\n    // Orbit Controls\r\n    const OrbitControls = function(object, domElement) {\r\n      this.object = object;\r\n      this.domElement = domElement;\r\n      \r\n      // Variables\r\n      let rotateStart = new THREE.Vector2();\r\n      let rotateEnd = new THREE.Vector2();\r\n      let rotateDelta = new THREE.Vector2();\r\n      \r\n      let isDragging = false;\r\n      let rotateSpeed = 1.0;\r\n      \r\n      // Methods\r\n      this.update = function() {};\r\n      \r\n      // Event handlers\r\n      const onMouseDown = (event) => {\r\n        event.preventDefault();\r\n        \r\n        rotateStart.set(event.clientX, event.clientY);\r\n        isDragging = true;\r\n      };\r\n      \r\n      const onMouseMove = (event) => {\r\n        if (!isDragging) return;\r\n        \r\n        rotateEnd.set(event.clientX, event.clientY);\r\n        rotateDelta.subVectors(rotateEnd, rotateStart);\r\n        \r\n        // Rotate based on mouse movement\r\n        const targetPosition = new THREE.Vector3(GRID_SIZE/2, GRID_SIZE/2, GRID_SIZE/2);\r\n        const radius = camera.position.distanceTo(targetPosition);\r\n        \r\n        // Rotate around target\r\n        let theta = -rotateDelta.x * 0.002 * rotateSpeed;\r\n        let phi = rotateDelta.y * 0.002 * rotateSpeed;\r\n        \r\n        const position = camera.position.clone().sub(targetPosition);\r\n        \r\n        // Convert to spherical coordinates\r\n        let spherical = new THREE.Spherical().setFromVector3(position);\r\n        \r\n        // Apply rotation\r\n        spherical.theta += theta;\r\n        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi + phi));\r\n        \r\n        // Convert back to Cartesian\r\n        position.setFromSpherical(spherical);\r\n        camera.position.copy(position.add(targetPosition));\r\n        camera.lookAt(targetPosition);\r\n        \r\n        rotateStart.copy(rotateEnd);\r\n      };\r\n      \r\n      const onMouseUp = () => {\r\n        isDragging = false;\r\n      };\r\n      \r\n      const onMouseWheel = (event) => {\r\n        const targetPosition = new THREE.Vector3(GRID_SIZE/2, GRID_SIZE/2, GRID_SIZE/2);\r\n        const direction = camera.position.clone().sub(targetPosition).normalize();\r\n        const distance = camera.position.distanceTo(targetPosition);\r\n        \r\n        // Zoom in or out\r\n        const delta = event.deltaY * 0.01;\r\n        const newDistance = Math.max(GRID_SIZE * 0.8, Math.min(GRID_SIZE * 3, distance + delta));\r\n        \r\n        camera.position.copy(targetPosition.clone().add(direction.multiplyScalar(newDistance)));\r\n      };\r\n      \r\n      // Event listeners\r\n      domElement.addEventListener('mousedown', onMouseDown, false);\r\n      domElement.addEventListener('mousemove', onMouseMove, false);\r\n      domElement.addEventListener('mouseup', onMouseUp, false);\r\n      domElement.addEventListener('wheel', onMouseWheel, false);\r\n    };\r\n    \r\n    const controls = new OrbitControls(camera, renderer.domElement);\r\n\r\n    // Lighting\r\n    const ambientLight = new THREE.AmbientLight(0xcccccc, 0.6);\r\n    scene.add(ambientLight);\r\n\r\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);\r\n    directionalLight.position.set(GRID_SIZE * 2, GRID_SIZE * 3, GRID_SIZE * 1);\r\n    scene.add(directionalLight);\r\n\r\n    // Materials\r\n    const flammableMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Wood brown\r\n    const burningMaterials = [\r\n      new THREE.MeshLambertMaterial({ color: 0xFF4500 }), // OrangeRed\r\n      new THREE.MeshLambertMaterial({ color: 0xFF8C00 }), // DarkOrange\r\n      new THREE.MeshLambertMaterial({ color: 0xFFD700 })  // Gold\r\n    ];\r\n    const burntMaterial = new THREE.MeshLambertMaterial({ color: 0x2F2F2F }); // Dark grey\r\n\r\n    // Voxel geometry\r\n    const voxelGeometry = new THREE.BoxGeometry(VOXEL_SIZE - GAP, VOXEL_SIZE - GAP, VOXEL_SIZE - GAP);\r\n\r\n    // Grid setup\r\n    let voxelGrid = [];\r\n    \r\n    // Initialize the grid\r\n    function initializeGrid() {\r\n      // Remove existing voxels from the scene\r\n      if (voxelGrid.length > 0) {\r\n        for (let x = 0; x < GRID_SIZE; x++) {\r\n          for (let y = 0; y < GRID_SIZE; y++) {\r\n            for (let z = 0; z < GRID_SIZE; z++) {\r\n              if (voxelGrid[x][y][z].mesh) {\r\n                scene.remove(voxelGrid[x][y][z].mesh);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      voxelGrid = Array(GRID_SIZE).fill().map(() => \r\n        Array(GRID_SIZE).fill().map(() => \r\n          Array(GRID_SIZE).fill().map(() => ({\r\n            mesh: null,\r\n            isFlammable: true,\r\n            isOnFire: false,\r\n            fuel: config.fuelAmount,\r\n            burnTimer: 0\r\n          }))\r\n        )\r\n      );\r\n      \r\n      // Create voxels\r\n      for (let x = 0; x < GRID_SIZE; x++) {\r\n        for (let y = 0; y < GRID_SIZE; y++) {\r\n          for (let z = 0; z < GRID_SIZE; z++) {\r\n            const voxel = new THREE.Mesh(voxelGeometry, flammableMaterial);\r\n            voxel.position.set(x + VOXEL_SIZE/2, y + VOXEL_SIZE/2, z + VOXEL_SIZE/2);\r\n            voxel.userData = { x, y, z }; // Store position for raycasting\r\n            scene.add(voxel);\r\n            \r\n            voxelGrid[x][y][z].mesh = voxel;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Raycasting for interaction\r\n    const raycaster = new THREE.Raycaster();\r\n    const mouse = new THREE.Vector2();\r\n\r\n    function onMouseClick(event) {\r\n      // Convert mouse position to normalized device coordinates\r\n      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\r\n      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\r\n      \r\n      // Update raycaster\r\n      raycaster.setFromCamera(mouse, camera);\r\n      \r\n      // Get intersections\r\n      const intersects = raycaster.intersectObjects(scene.children);\r\n      \r\n      if (intersects.length > 0) {\r\n        const voxel = intersects[0].object;\r\n        \r\n        // Check if it's a voxel (has userData with coordinates)\r\n        if (voxel.userData && typeof voxel.userData.x !== 'undefined') {\r\n          const { x, y, z } = voxel.userData;\r\n          \r\n          if (voxelGrid[x][y][z].isFlammable && !voxelGrid[x][y][z].isOnFire) {\r\n            igniteVoxel(x, y, z);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Ignite a voxel\r\n    function igniteVoxel(x, y, z) {\r\n      if (!voxelGrid[x][y][z].isFlammable || voxelGrid[x][y][z].isOnFire) return;\r\n      \r\n      voxelGrid[x][y][z].isOnFire = true;\r\n      voxelGrid[x][y][z].burnTimer = 0;\r\n      \r\n      // Assign a random burning material\r\n      const randomBurningMaterial = burningMaterials[Math.floor(Math.random() * burningMaterials.length)];\r\n      voxelGrid[x][y][z].mesh.material = randomBurningMaterial;\r\n    }\r\n\r\n    // Start fire at a random location\r\n    function startRandomFire() {\r\n      const x = Math.floor(Math.random() * GRID_SIZE);\r\n      const y = Math.floor(Math.random() * GRID_SIZE);\r\n      const z = Math.floor(Math.random() * GRID_SIZE);\r\n      \r\n      igniteVoxel(x, y, z);\r\n    }\r\n\r\n    // Update the simulation\r\n    function updateSimulation() {\r\n      // Create a list of voxels to ignite in the next step to avoid immediate spread\r\n      const toIgnite = [];\r\n      \r\n      // Process all voxels\r\n      for (let x = 0; x < GRID_SIZE; x++) {\r\n        for (let y = 0; y < GRID_SIZE; y++) {\r\n          for (let z = 0; z < GRID_SIZE; z++) {\r\n            const voxel = voxelGrid[x][y][z];\r\n            \r\n            if (voxel.isOnFire) {\r\n              // Increment burn timer\r\n              voxel.burnTimer++;\r\n              \r\n              // Animate fire color\r\n              if (voxel.burnTimer % 5 === 0) {\r\n                const randomBurningMaterial = burningMaterials[Math.floor(Math.random() * burningMaterials.length)];\r\n                voxel.mesh.material = randomBurningMaterial;\r\n              }\r\n              \r\n              // Consume fuel\r\n              voxel.fuel--;\r\n              \r\n              // Check if the fire burns out\r\n              if (voxel.fuel <= 0) {\r\n                voxel.isOnFire = false;\r\n                voxel.isFlammable = false;\r\n                voxel.mesh.material = burntMaterial;\r\n              } else {\r\n                // Try to spread fire to neighbors\r\n                const neighbors = getNeighbors(x, y, z);\r\n                \r\n                neighbors.forEach(neighbor => {\r\n                  const [nx, ny, nz] = neighbor;\r\n                  \r\n                  if (voxelGrid[nx][ny][nz].isFlammable && !voxelGrid[nx][ny][nz].isOnFire) {\r\n                    // Apply spread probability\r\n                    if (Math.random() < config.spreadProbability) {\r\n                      toIgnite.push([nx, ny, nz]);\r\n                    }\r\n                  }\r\n                });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Ignite new voxels\r\n      toIgnite.forEach(coords => {\r\n        const [x, y, z] = coords;\r\n        igniteVoxel(x, y, z);\r\n      });\r\n    }\r\n\r\n    // Get valid neighbors\r\n    function getNeighbors(x, y, z) {\r\n      const neighbors = [];\r\n      \r\n      // Check all 6 faces (not diagonals)\r\n      const directions = [\r\n        [1, 0, 0], [-1, 0, 0],\r\n        [0, 1, 0], [0, -1, 0],\r\n        [0, 0, 1], [0, 0, -1]\r\n      ];\r\n      \r\n      directions.forEach(dir => {\r\n        const nx = x + dir[0];\r\n        const ny = y + dir[1];\r\n        const nz = z + dir[2];\r\n        \r\n        // Check if neighbor is within grid bounds\r\n        if (nx >= 0 && nx < GRID_SIZE && \r\n            ny >= 0 && ny < GRID_SIZE && \r\n            nz >= 0 && nz < GRID_SIZE) {\r\n          neighbors.push([nx, ny, nz]);\r\n        }\r\n      });\r\n      \r\n      return neighbors;\r\n    }\r\n\r\n    // Animation loop\r\n    function animate() {\r\n      requestAnimationFrame(animate);\r\n      \r\n      updateSimulation();\r\n      renderer.render(scene, camera);\r\n    }\r\n\r\n    // Handle window resize\r\n    function onWindowResize() {\r\n      camera.aspect = window.innerWidth / window.innerHeight;\r\n      camera.updateProjectionMatrix();\r\n      renderer.setSize(window.innerWidth, window.innerHeight);\r\n    }\r\n\r\n    // UI Controls\r\n    document.getElementById('reset').addEventListener('click', () => {\r\n      initializeGrid();\r\n    });\r\n\r\n    document.getElementById('random-fire').addEventListener('click', () => {\r\n      startRandomFire();\r\n    });\r\n\r\n    document.getElementById('spread-probability').addEventListener('input', (e) => {\r\n      config.spreadProbability = parseInt(e.target.value) / 100;\r\n      document.getElementById('spread-value').textContent = e.target.value + '%';\r\n    });\r\n\r\n    document.getElementById('fuel-amount').addEventListener('input', (e) => {\r\n      config.fuelAmount = parseInt(e.target.value);\r\n      document.getElementById('fuel-value').textContent = e.target.value;\r\n    });\r\n\r\n    // Event listeners\r\n    window.addEventListener('resize', onWindowResize, false);\r\n    renderer.domElement.addEventListener('click', onMouseClick, false);\r\n\r\n    // Initialize and start the simulation\r\n    initializeGrid();\r\n    animate();\r\n  </script>\r\n</body>\r\n</html>",
  "id": "voxel-fire-simulation-claude-3-7",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Simulation"
    ],
    "timestamp": "2025-08-04T21:59:57.733Z",
    "model": "claude-3.7",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, simulation."
  }
}
