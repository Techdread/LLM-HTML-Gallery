{
  "title": "3D Bin Packing Visualization",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>3D Bin Packing Visualization</title>\r\n    <style>\r\n        /* Basic styling for the page */\r\n        body {\r\n            margin: 0;\r\n            font-family: 'Inter', sans-serif;\r\n            /* Using Inter font */\r\n            background-color: #f0f0f0;\r\n            /* Light gray background */\r\n            color: #333;\r\n            overflow: hidden;\r\n            /* Prevent scrollbars */\r\n        }\r\n\r\n        canvas {\r\n            display: block;\r\n            /* Remove extra space below canvas */\r\n            width: 100%;\r\n            /* Make canvas responsive */\r\n            height: 100%;\r\n        }\r\n\r\n        /* Style for a potential info overlay */\r\n        #info {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            padding: 10px;\r\n            background-color: rgba(255, 255, 255, 0.8);\r\n            border-radius: 8px;\r\n            font-size: 0.9em;\r\n            max-width: 300px;\r\n            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\r\n        }\r\n    </style>\r\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\r\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\r\n    <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap\" rel=\"stylesheet\">\r\n</head>\r\n\r\n<body>\r\n    <div id=\"info\">\r\n        <strong>3D Bin Packing Visualization</strong><br>\r\n        Drag to rotate, scroll to zoom.<br>\r\n        Packing based on simplified heuristic from PDF concepts.\r\n    </div>\r\n\r\n    <script type=\"importmap\">\r\n        {\r\n            \"imports\": {\r\n                \"three\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js\",\r\n                \"three/addons/\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/\"\r\n            }\r\n        }\r\n    </script>\r\n\r\n    <script type=\"module\">\r\n        // Import necessary Three.js components\r\n        import * as THREE from 'three';\r\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\n\r\n        // --- 1. Data Structures (Based on PDF Section 3) ---\r\n\r\n        /**\r\n         * Represents a single piece/item to be packed.\r\n         * @param {number} id - Unique identifier for the piece.\r\n         * @param {number} width - Width (x-dimension).\r\n         * @param {number} height - Height (y-dimension).\r\n         * @param {number} depth - Depth (z-dimension).\r\n         * @param {number} [value=0] - Value (for knapsack) or other metric.\r\n         */\r\n        class Piece {\r\n            constructor(id, width, height, depth, value = 0) {\r\n                this.id = id;\r\n                this.width = width;\r\n                this.height = height;\r\n                this.depth = depth;\r\n                this.value = value; // Useful for knapsack variations\r\n                this.volume = width * height * depth;\r\n                this.position = null; // {x, y, z} coordinates of the back-left-bottom corner when placed\r\n                this.orientation = 0; // Orientation index (0-5) when placed\r\n                this.isPlaced = false; // Flag indicating if the piece is in the bin\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Represents an available corner (potential placement location).\r\n         * @param {number} x - X-coordinate of the corner.\r\n         * @param {number} y - Y-coordinate of the corner.\r\n         * @param {number} z - Z-coordinate of the corner.\r\n         */\r\n        class Corner {\r\n            constructor(x, y, z) {\r\n                // Represents the back-left-bottom coordinate of available space\r\n                this.x = x;\r\n                this.y = y;\r\n                this.z = z;\r\n                // Note: A full implementation based on the paper would store detailed\r\n                // information about the three surfaces defining this corner.\r\n                // This example simplifies the corner representation.\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Represents the container (bin) into which pieces are packed.\r\n         * @param {number} width - Width (x-dimension) of the bin.\r\n         * @param {number} height - Height (y-dimension) of the bin.\r\n         * @param {number} depth - Depth (z-dimension) of the bin.\r\n         */\r\n        class Bin {\r\n            constructor(width, height, depth) {\r\n                this.width = width;\r\n                this.height = height;\r\n                this.depth = depth;\r\n                this.volume = width * height * depth;\r\n                this.placedPieces = []; // Array to store references to placed Piece objects\r\n                // Start with a single corner at the origin (back-left-bottom)\r\n                this.corners = [new Corner(0, 0, 0)];\r\n                // Epsilon for floating point comparisons\r\n                this.epsilon = 0.0001;\r\n            }\r\n\r\n            // --- Placement Validation & Update Logic ---\r\n\r\n            /**\r\n             * Checks if a piece, in a specific orientation, can be validly placed at a given corner.\r\n             * Checks against bin boundaries and collisions with already placed pieces.\r\n             * @param {Piece} piece - The piece to check.\r\n             * @param {Corner} corner - The corner to check placement at.\r\n             * @param {number} orientation - The orientation index (0-5) to check.\r\n             * @returns {boolean} - True if placement is valid, false otherwise.\r\n             */\r\n            checkPlacement(piece, corner, orientation) {\r\n                const dims = this.getOrientationDims(piece, orientation);\r\n\r\n                // 1. Check bin boundaries (using epsilon for float safety)\r\n                if (corner.x + dims.w > this.width + this.epsilon ||\r\n                    corner.y + dims.h > this.height + this.epsilon ||\r\n                    corner.z + dims.d > this.depth + this.epsilon) {\r\n                    // console.log(`Piece ${piece.id} failed boundary check at (${corner.x}, ${corner.y}, ${corner.z}) orientation ${orientation}`);\r\n                    return false;\r\n                }\r\n\r\n                // 2. Check for collisions with other placed pieces\r\n                // Define the bounding box of the piece if placed at this corner/orientation\r\n                const pieceBox = new THREE.Box3(\r\n                    new THREE.Vector3(corner.x, corner.y, corner.z),\r\n                    new THREE.Vector3(corner.x + dims.w, corner.y + dims.h, corner.z + dims.d)\r\n                );\r\n\r\n                // Iterate through pieces already placed in the bin\r\n                for (const placed of this.placedPieces) {\r\n                    // Get the dimensions of the placed piece in its placed orientation\r\n                    const placedDims = this.getOrientationDims(placed, placed.orientation);\r\n                    // Define the bounding box of the already placed piece\r\n                    const placedBox = new THREE.Box3(\r\n                        new THREE.Vector3(placed.position.x, placed.position.y, placed.position.z),\r\n                        new THREE.Vector3(placed.position.x + placedDims.w, placed.position.y + placedDims.h, placed.position.z + placedDims.d)\r\n                    );\r\n\r\n                    // Use intersectsBox for an initial check, then a more precise overlap check\r\n                    if (pieceBox.intersectsBox(placedBox)) {\r\n                        // Refined check to ensure actual overlap, not just touching faces/edges\r\n                        if (this.boxesOverlap(pieceBox, placedBox)) {\r\n                            // console.log(`Piece ${piece.id} failed collision check with Piece ${placed.id} at (${corner.x}, ${corner.y}, ${corner.z}) orientation ${orientation}`);\r\n                            return false; // Collision detected\r\n                        }\r\n                    }\r\n                }\r\n                // If no boundary or collision issues found, placement is valid\r\n                return true;\r\n            }\r\n\r\n            /**\r\n             * Checks for actual volumetric overlap between two bounding boxes.\r\n             * THREE.Box3.intersectsBox() returns true even if boxes only touch.\r\n             * @param {THREE.Box3} box1\r\n             * @param {THREE.Box3} box2\r\n             * @returns {boolean} True if boxes overlap volumetrically, false otherwise.\r\n             */\r\n            boxesOverlap(box1, box2) {\r\n                // Check if the intervals overlap on each axis\r\n                const overlapX = box1.max.x > box2.min.x + this.epsilon && box1.min.x < box2.max.x - this.epsilon;\r\n                const overlapY = box1.max.y > box2.min.y + this.epsilon && box1.min.y < box2.max.y - this.epsilon;\r\n                const overlapZ = box1.max.z > box2.min.z + this.epsilon && box1.min.z < box2.max.z - this.epsilon;\r\n                return overlapX && overlapY && overlapZ;\r\n            }\r\n\r\n\r\n            /**\r\n             * Places a piece in the bin at the specified corner and orientation.\r\n             * Updates the list of placed pieces and the list of available corners.\r\n             * @param {Piece} piece - The piece to place.\r\n             * @param {Corner} corner - The corner where the piece is placed.\r\n             * @param {number} orientation - The orientation index (0-5) used for placement.\r\n             */\r\n            placePiece(piece, corner, orientation) {\r\n                const dims = this.getOrientationDims(piece, orientation);\r\n\r\n                // Assign placement details to the piece object\r\n                piece.position = { x: corner.x, y: corner.y, z: corner.z };\r\n                piece.orientation = orientation; // Store the orientation used\r\n                piece.isPlaced = true;\r\n                this.placedPieces.push(piece); // Add to the list of placed pieces\r\n\r\n                // --- Corner Management (Simplified) ---\r\n\r\n                // 1. Remove the corner that was just used\r\n                this.corners = this.corners.filter(c =>\r\n                    !(Math.abs(c.x - corner.x) < this.epsilon &&\r\n                        Math.abs(c.y - corner.y) < this.epsilon &&\r\n                        Math.abs(c.z - corner.z) < this.epsilon)\r\n                );\r\n\r\n                // 2. Add new potential corners created by the placed piece\r\n                //    (at the front-top-right relative positions from the placed corner)\r\n                const cornerX = new Corner(corner.x + dims.w, corner.y, corner.z);\r\n                const cornerY = new Corner(corner.x, corner.y + dims.h, corner.z);\r\n                const cornerZ = new Corner(corner.x, corner.y, corner.z + dims.d);\r\n\r\n                // Add new corners only if they are within bin bounds and not already present\r\n                if (cornerX.x < this.width - this.epsilon) this.addCornerIfNotExists(cornerX);\r\n                if (cornerY.y < this.height - this.epsilon) this.addCornerIfNotExists(cornerY);\r\n                if (cornerZ.z < this.depth - this.epsilon) this.addCornerIfNotExists(cornerZ);\r\n\r\n                // 3. Remove existing corners that are now inside the newly placed piece.\r\n                //    This is a crucial but complex step in robust packing algorithms.\r\n                //    This simplified version removes corners strictly inside the new piece's volume.\r\n                //    A full implementation would need to check against the piece's bounding box\r\n                //    and potentially modify existing corners rather than just deleting them.\r\n                this.corners = this.corners.filter(c => {\r\n                    const pieceBox = new THREE.Box3(\r\n                        new THREE.Vector3(corner.x, corner.y, corner.z),\r\n                        new THREE.Vector3(corner.x + dims.w, corner.y + dims.h, corner.z + dims.d)\r\n                    );\r\n                    const point = new THREE.Vector3(c.x, c.y, c.z);\r\n                    // Check if the corner point is strictly inside the box (using epsilon)\r\n                    const isInside = point.x > pieceBox.min.x + this.epsilon && point.x < pieceBox.max.x - this.epsilon &&\r\n                        point.y > pieceBox.min.y + this.epsilon && point.y < pieceBox.max.y - this.epsilon &&\r\n                        point.z > pieceBox.min.z + this.epsilon && point.z < pieceBox.max.z - this.epsilon;\r\n                    return !isInside; // Keep corner if it's NOT strictly inside\r\n                });\r\n            }\r\n\r\n            /**\r\n             * Adds a new corner to the list if a corner at the same coordinates doesn't already exist.\r\n             * Uses epsilon for floating point comparisons.\r\n             * @param {Corner} newCorner - The potential new corner to add.\r\n             */\r\n            addCornerIfNotExists(newCorner) {\r\n                const exists = this.corners.some(c =>\r\n                    Math.abs(c.x - newCorner.x) < this.epsilon &&\r\n                    Math.abs(c.y - newCorner.y) < this.epsilon &&\r\n                    Math.abs(c.z - newCorner.z) < this.epsilon\r\n                );\r\n                if (!exists) {\r\n                    this.corners.push(newCorner);\r\n                }\r\n            }\r\n\r\n            /**\r\n             * Calculates the width, height, and depth of a piece based on a given orientation.\r\n             * Orientation indices correspond to different axis alignments.\r\n             * @param {Piece} piece - The piece object.\r\n             * @param {number} orientation - The orientation index (0-5).\r\n             * @returns {{w: number, h: number, d: number}} - Dimensions in the specified orientation.\r\n             */\r\n            getOrientationDims(piece, orientation) {\r\n                // 0: (w,h,d) - Original\r\n                // 1: (h,w,d) - Rotated Z\r\n                // 2: (w,d,h) - Rotated Y\r\n                // 3: (d,w,h) - Rotated Y, then Z\r\n                // 4: (h,d,w) - Rotated X\r\n                // 5: (d,h,w) - Rotated X, then Z\r\n                switch (orientation) {\r\n                    case 0: return { w: piece.width, h: piece.height, d: piece.depth };\r\n                    case 1: return { w: piece.height, h: piece.width, d: piece.depth };\r\n                    case 2: return { w: piece.width, h: piece.depth, d: piece.height };\r\n                    case 3: return { w: piece.depth, h: piece.width, d: piece.height };\r\n                    case 4: return { w: piece.height, h: piece.depth, d: piece.width };\r\n                    case 5: return { w: piece.depth, h: piece.height, d: piece.width };\r\n                    default: return { w: piece.width, h: piece.height, d: piece.depth }; // Default to 0\r\n                }\r\n            }\r\n        }\r\n\r\n        // --- 2. Packing Algorithm (Simplified Heuristic) ---\r\n\r\n        /**\r\n         * Packs pieces into the bin using a simple greedy heuristic.\r\n         * Sorts pieces by volume (descending) and tries to place them at the\r\n         * first available valid corner/orientation found.\r\n         * @param {Bin} bin - The bin object to pack into.\r\n         * @param {Piece[]} pieces - An array of Piece objects to pack.\r\n         * @returns {Piece[]} - An array of the pieces that were successfully placed.\r\n         */\r\n        function packBin(bin, pieces) {\r\n            console.log(\"Starting packing process...\");\r\n            // Sort pieces by volume, largest first (a common simple heuristic)\r\n            pieces.sort((a, b) => b.volume - a.volume);\r\n            console.log(\"Pieces sorted by volume (desc).\");\r\n\r\n            let piecesPlacedCount = 0;\r\n            const totalPieces = pieces.length;\r\n            let remainingPieces = pieces.filter(p => !p.isPlaced); // Start with all pieces\r\n\r\n            // Keep trying to place pieces until no more can be placed in a full pass\r\n            let passMadePlacement = true;\r\n            while (passMadePlacement && remainingPieces.length > 0) {\r\n                passMadePlacement = false; // Assume no placement in this pass initially\r\n                // Sort corners by position (e.g., bottom-left-first approach)\r\n                bin.corners.sort((a, b) => {\r\n                    if (Math.abs(a.z - b.z) > bin.epsilon) return a.z - b.z; // Prioritize Z first (back)\r\n                    if (Math.abs(a.y - b.y) > bin.epsilon) return a.y - b.y; // Then Y (bottom)\r\n                    return a.x - b.x; // Then X (left)\r\n                });\r\n\r\n                // Iterate through remaining pieces for this pass\r\n                pieceLoop: // Label for the outer loop iterating through pieces\r\n                for (let i = remainingPieces.length - 1; i >= 0; i--) {\r\n                    const piece = remainingPieces[i];\r\n\r\n                    // Try placing this piece at each available corner\r\n                    for (const corner of bin.corners) {\r\n                        // Try all 6 possible orientations\r\n                        for (let orientation = 0; orientation < 6; orientation++) {\r\n                            // Check if this placement is valid\r\n                            if (bin.checkPlacement(piece, corner, orientation)) {\r\n                                // If valid, place the piece\r\n                                bin.placePiece(piece, corner, orientation);\r\n                                piecesPlacedCount++;\r\n                                console.log(`Placed Piece ${piece.id} (Vol: ${piece.volume}) at (${corner.x.toFixed(2)}, ${corner.y.toFixed(2)}, ${corner.z.toFixed(2)}) orientation ${orientation}. Total placed: ${piecesPlacedCount}`);\r\n\r\n                                // Remove the placed piece from the remaining list\r\n                                remainingPieces.splice(i, 1);\r\n                                passMadePlacement = true; // Mark that a placement occurred in this pass\r\n\r\n                                // *** FIX: Use break to exit inner loops and continue outer loop ***\r\n                                break pieceLoop; // Exit corner and orientation loops, continue to next piece iteration in this pass\r\n                            }\r\n                        }\r\n                    }\r\n                    // *** REMOVED: Unnecessary label definition ***\r\n                    // gotoNextPiece:;\r\n                } // End of loop through remaining pieces for this pass (pieceLoop)\r\n\r\n            } // End of while loop (packing attempts)\r\n\r\n            console.log(`Packing finished. Placed ${piecesPlacedCount} out of ${totalPieces} pieces.`);\r\n            console.log(`Total volume placed: ${bin.placedPieces.reduce((sum, p) => sum + p.volume, 0)} / Bin volume: ${bin.volume}`);\r\n            console.log(`Remaining corners: ${bin.corners.length}`);\r\n            return bin.placedPieces;\r\n        }\r\n\r\n\r\n        // --- 3. Three.js Visualization Setup ---\r\n        let scene, camera, renderer, controls;\r\n        let binMesh; // Reference to the bin wireframe\r\n        const pieceMeshes = new THREE.Group(); // Group to hold all piece meshes\r\n\r\n        /**\r\n         * Initializes the Three.js scene, camera, renderer, controls, and lighting.\r\n         */\r\n        function initVisualization() {\r\n            // Scene setup\r\n            scene = new THREE.Scene();\r\n            scene.background = new THREE.Color(0xf0f0f0); // Light gray background\r\n\r\n            // Camera setup\r\n            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n            // Position camera to provide a good overview of the bin\r\n            camera.position.set(binDimensions.width * 1.2, binDimensions.height * 1.5, binDimensions.depth * 1.8);\r\n            // Point the camera towards the center of the bin\r\n            camera.lookAt(binDimensions.width / 2, binDimensions.height / 2, binDimensions.depth / 2);\r\n\r\n            // Renderer setup\r\n            renderer = new THREE.WebGLRenderer({ antialias: true }); // Enable anti-aliasing\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            renderer.setPixelRatio(window.devicePixelRatio); // Adjust for high-DPI screens\r\n            document.body.appendChild(renderer.domElement); // Add canvas to the page\r\n\r\n            // Lighting setup\r\n            const ambientLight = new THREE.AmbientLight(0x606060, 1.5); // Soft ambient light\r\n            scene.add(ambientLight);\r\n            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);\r\n            directionalLight1.position.set(1, 0.75, 0.5).normalize();\r\n            scene.add(directionalLight1);\r\n            const directionalLight2 = new THREE.DirectionalLight(0xaaaaaa, 0.8);\r\n            directionalLight2.position.set(-1, -0.75, -0.5).normalize();\r\n            scene.add(directionalLight2);\r\n\r\n\r\n            // OrbitControls setup for user interaction\r\n            controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.target.set(binDimensions.width / 2, binDimensions.height / 2, binDimensions.depth / 2); // Center controls on the bin\r\n            controls.enableDamping = true; // Smooth camera movement\r\n            controls.dampingFactor = 0.1;\r\n            controls.update(); // Apply initial target\r\n\r\n            // Axes Helper for orientation reference (X=red, Y=green, Z=blue)\r\n            const axesHelper = new THREE.AxesHelper(Math.max(binDimensions.width, binDimensions.height, binDimensions.depth) * 1.2);\r\n            scene.add(axesHelper);\r\n\r\n            // Bin Visualization (Wireframe Box)\r\n            const binGeometry = new THREE.BoxGeometry(binDimensions.width, binDimensions.height, binDimensions.depth);\r\n            const binEdges = new THREE.EdgesGeometry(binGeometry);\r\n            binMesh = new THREE.LineSegments(binEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })); // Black, slightly thicker lines\r\n            // Position the center of the wireframe bin at the center of its volume\r\n            binMesh.position.set(binDimensions.width / 2, binDimensions.height / 2, binDimensions.depth / 2);\r\n            scene.add(binMesh); // Add bin wireframe to the scene\r\n            scene.add(pieceMeshes); // Add the group that will hold piece meshes\r\n\r\n\r\n            // Handle window resize events\r\n            window.addEventListener('resize', onWindowResize, false);\r\n\r\n            // Start the animation loop\r\n            animate();\r\n            console.log(\"Three.js visualization initialized.\");\r\n        }\r\n\r\n        /**\r\n         * Updates the visualization to show the packed pieces.\r\n         * Clears previous piece meshes and creates new ones based on the packing result.\r\n         * @param {Piece[]} packedPieces - Array of placed Piece objects.\r\n         * @param {Bin} bin - The Bin object (needed for getOrientationDims).\r\n         */\r\n        function visualizePacking(packedPieces, bin) {\r\n            // Clear any previously rendered piece meshes\r\n            pieceMeshes.clear();\r\n\r\n            // Create a mesh for each placed piece\r\n            packedPieces.forEach(piece => {\r\n                // Get dimensions based on the orientation the piece was placed in\r\n                const dims = bin.getOrientationDims(piece, piece.orientation);\r\n                // Create box geometry with these dimensions\r\n                const geometry = new THREE.BoxGeometry(dims.w, dims.h, dims.d);\r\n                // Create material with a unique random color for each piece\r\n                const material = new THREE.MeshLambertMaterial({\r\n                    color: new THREE.Color(Math.random() * 0xffffff),\r\n                    transparent: true, // Enable transparency\r\n                    opacity: 0.9 // Slightly transparent to see overlaps if any\r\n                });\r\n                const cube = new THREE.Mesh(geometry, material);\r\n\r\n                // Position the center of the cube mesh correctly\r\n                // The piece's position is its back-left-bottom corner\r\n                cube.position.set(\r\n                    piece.position.x + dims.w / 2,\r\n                    piece.position.y + dims.h / 2,\r\n                    piece.position.z + dims.d / 2\r\n                );\r\n                pieceMeshes.add(cube); // Add the piece mesh to the group\r\n\r\n                // Optional: Add wireframe edges to each piece for better definition\r\n                const edges = new THREE.EdgesGeometry(geometry);\r\n                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.6 }));\r\n                line.position.copy(cube.position); // Position edges same as the cube\r\n                pieceMeshes.add(line);\r\n            });\r\n            console.log(\"Visualization updated with packed pieces.\");\r\n        }\r\n\r\n        /**\r\n         * Handles window resize events to keep the visualization proportional.\r\n         */\r\n        function onWindowResize() {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n\r\n        /**\r\n         * The main animation loop called recursively via requestAnimationFrame.\r\n         * Renders the scene and updates controls.\r\n         */\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n            controls.update(); // Update controls (needed for damping)\r\n            renderer.render(scene, camera); // Render the scene\r\n        }\r\n\r\n        // --- 4. Example Usage ---\r\n\r\n        // Define the dimensions of the bin\r\n        const binDimensions = { width: 10, height: 10, depth: 10 };\r\n        // Create the Bin object\r\n        const theBin = new Bin(binDimensions.width, binDimensions.height, binDimensions.depth);\r\n\r\n        // Define a list of pieces to pack\r\n        const piecesToPack = [\r\n            new Piece(1, 4, 4, 4), // Large cube\r\n            new Piece(2, 3, 3, 3), // Medium cube\r\n            new Piece(3, 5, 2, 2), // Flat-ish\r\n            new Piece(4, 2, 5, 2), // Tall-ish\r\n            new Piece(5, 2, 2, 5), // Deep-ish\r\n            new Piece(6, 6, 1, 1), // Very flat\r\n            new Piece(7, 1, 6, 1), // Very tall\r\n            new Piece(8, 1, 1, 6), // Very deep\r\n            new Piece(9, 3, 4, 5), // Large irregular\r\n            new Piece(10, 5, 3, 4),// Large irregular\r\n            new Piece(11, 4, 5, 3),// Large irregular\r\n            new Piece(12, 2, 2, 2), // Small cube\r\n            new Piece(13, 2, 2, 2), // Small cube\r\n            new Piece(14, 1, 1, 1), // Unit cube\r\n            new Piece(15, 1, 1, 1), // Unit cube\r\n            new Piece(16, 1, 1, 1), // Unit cube\r\n            new Piece(17, 3, 1, 3),\r\n            new Piece(18, 1, 3, 3),\r\n            new Piece(19, 3, 3, 1),\r\n            new Piece(20, 4, 2, 3),\r\n        ];\r\n\r\n        // Run the packing algorithm\r\n        const finalPlacement = packBin(theBin, piecesToPack);\r\n\r\n        // Initialize the Three.js visualization environment\r\n        initVisualization();\r\n        // Visualize the result of the packing algorithm\r\n        visualizePacking(finalPlacement, theBin);\r\n\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "bin-packing-ga-gemini-pro-2-5",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.894Z",
    "model": "gemini-pro-2.5",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, architecture."
  }
}
