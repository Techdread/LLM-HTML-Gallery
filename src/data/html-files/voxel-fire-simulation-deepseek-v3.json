{
  "title": "Voxel Fire Spread Simulation",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Voxel Fire Spread Simulation</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n            font-family: Arial, sans-serif;\r\n        }\r\n        canvas {\r\n            display: block;\r\n        }\r\n        #ui {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            color: white;\r\n            background-color: rgba(0,0,0,0.5);\r\n            padding: 10px;\r\n            border-radius: 5px;\r\n        }\r\n        button {\r\n            padding: 5px 10px;\r\n            margin: 5px 0;\r\n            cursor: pointer;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"ui\">\r\n        <h2>Voxel Fire Spread</h2>\r\n        <p>Click on flammable voxels (brown) to start the fire</p>\r\n        <button id=\"resetBtn\">Reset Simulation</button>\r\n    </div>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js\"></script>\r\n    <script>\r\n        // Scene setup\r\n        const scene = new THREE.Scene();\r\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\r\n        renderer.setSize(window.innerWidth, window.innerHeight);\r\n        renderer.setClearColor(0x333333);\r\n        document.body.appendChild(renderer.domElement);\r\n\r\n        // Camera controls\r\n        const controls = new THREE.OrbitControls(camera, renderer.domElement);\r\n        camera.position.set(15, 15, 15);\r\n        controls.update();\r\n\r\n        // Lighting\r\n        const ambientLight = new THREE.AmbientLight(0x404040);\r\n        scene.add(ambientLight);\r\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\r\n        directionalLight.position.set(1, 1, 1);\r\n        scene.add(directionalLight);\r\n\r\n        // Grid parameters\r\n        const gridSize = 10;\r\n        const voxelSize = 1;\r\n        const voxelSpacing = 0.1;\r\n        const totalSize = gridSize * (voxelSize + voxelSpacing) - voxelSpacing;\r\n\r\n        // Voxel materials\r\n        const flammableMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // Brown (wood)\r\n        const burningMaterial = new THREE.MeshPhongMaterial({ \r\n            color: 0xFF4500, \r\n            emissive: 0xFF4500,\r\n            emissiveIntensity: 0.5\r\n        }); // Orange-red\r\n        const burntMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 }); // Dark gray\r\n\r\n        // Voxel geometry\r\n        const voxelGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);\r\n\r\n        // Voxel grid\r\n        const voxels = [];\r\n        const voxelMeshes = [];\r\n\r\n        // Initialize voxel grid\r\n        function initVoxels() {\r\n            // Clear existing voxels\r\n            voxelMeshes.forEach(mesh => scene.remove(mesh));\r\n            voxels.length = 0;\r\n            voxelMeshes.length = 0;\r\n\r\n            // Create new voxels\r\n            for (let x = 0; x < gridSize; x++) {\r\n                voxels[x] = [];\r\n                voxelMeshes[x] = [];\r\n                for (let y = 0; y < gridSize; y++) {\r\n                    voxels[x][y] = [];\r\n                    voxelMeshes[x][y] = [];\r\n                    for (let z = 0; z < gridSize; z++) {\r\n                        // Randomly determine if voxel is flammable (70% chance)\r\n                        const isFlammable = Math.random() < 0.7;\r\n                        \r\n                        // Create voxel data\r\n                        voxels[x][y][z] = {\r\n                            isFlammable: isFlammable,\r\n                            isOnFire: false,\r\n                            fuel: isFlammable ? Math.random() * 50 + 50 : 0, // Random fuel between 50-100\r\n                            neighbors: []\r\n                        };\r\n\r\n                        // Create voxel mesh\r\n                        const material = isFlammable ? flammableMaterial : burntMaterial;\r\n                        const voxelMesh = new THREE.Mesh(voxelGeometry, material);\r\n                        \r\n                        // Position the voxel\r\n                        const offset = -(totalSize / 2) + (voxelSize / 2);\r\n                        voxelMesh.position.set(\r\n                            offset + x * (voxelSize + voxelSpacing),\r\n                            offset + y * (voxelSize + voxelSpacing),\r\n                            offset + z * (voxelSize + voxelSpacing)\r\n                        );\r\n                        \r\n                        scene.add(voxelMesh);\r\n                        voxelMeshes[x][y][z] = voxelMesh;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Set up neighbor references\r\n            for (let x = 0; x < gridSize; x++) {\r\n                for (let y = 0; y < gridSize; y++) {\r\n                    for (let z = 0; z < gridSize; z++) {\r\n                        const neighbors = [];\r\n                        if (x > 0) neighbors.push(voxels[x-1][y][z]);\r\n                        if (x < gridSize-1) neighbors.push(voxels[x+1][y][z]);\r\n                        if (y > 0) neighbors.push(voxels[x][y-1][z]);\r\n                        if (y < gridSize-1) neighbors.push(voxels[x][y+1][z]);\r\n                        if (z > 0) neighbors.push(voxels[x][y][z-1]);\r\n                        if (z < gridSize-1) neighbors.push(voxels[x][y][z+1]);\r\n                        voxels[x][y][z].neighbors = neighbors;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Raycaster for interaction\r\n        const raycaster = new THREE.Raycaster();\r\n        const mouse = new THREE.Vector2();\r\n\r\n        function onMouseClick(event) {\r\n            // Calculate mouse position in normalized device coordinates\r\n            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\r\n            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\r\n\r\n            // Update the raycaster\r\n            raycaster.setFromCamera(mouse, camera);\r\n\r\n            // Find intersected voxels\r\n            const intersects = raycaster.intersectObjects(voxelMeshes.flat(2));\r\n\r\n            if (intersects.length > 0) {\r\n                const clickedVoxelMesh = intersects[0].object;\r\n                \r\n                // Find the voxel data for this mesh\r\n                for (let x = 0; x < gridSize; x++) {\r\n                    for (let y = 0; y < gridSize; y++) {\r\n                        for (let z = 0; z < gridSize; z++) {\r\n                            if (voxelMeshes[x][y][z] === clickedVoxelMesh) {\r\n                                const voxel = voxels[x][y][z];\r\n                                if (voxel.isFlammable && !voxel.isOnFire) {\r\n                                    // Ignite this voxel\r\n                                    voxel.isOnFire = true;\r\n                                    clickedVoxelMesh.material = burningMaterial;\r\n                                }\r\n                                return;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Smoke particles\r\n        let smokeParticles = null;\r\n        function createSmokeParticles() {\r\n            const particleCount = 1000;\r\n            const particles = new THREE.BufferGeometry();\r\n            const positions = new Float32Array(particleCount * 3);\r\n            const scales = new Float32Array(particleCount);\r\n\r\n            for (let i = 0; i < particleCount; i++) {\r\n                positions[i * 3] = (Math.random() - 0.5) * 10;\r\n                positions[i * 3 + 1] = (Math.random() - 0.5) * 10;\r\n                positions[i * 3 + 2] = (Math.random() - 0.5) * 10;\r\n                scales[i] = Math.random() * 0.5 + 0.1;\r\n            }\r\n\r\n            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));\r\n            particles.setAttribute('scale', new THREE.BufferAttribute(scales, 1));\r\n\r\n            const particleMaterial = new THREE.PointsMaterial({\r\n                color: 0x555555,\r\n                size: 0.5,\r\n                transparent: true,\r\n                opacity: 0.6,\r\n                blending: THREE.AdditiveBlending\r\n            });\r\n\r\n            smokeParticles = new THREE.Points(particles, particleMaterial);\r\n            smokeParticles.visible = false;\r\n            scene.add(smokeParticles);\r\n        }\r\n\r\n        // Animation loop\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n\r\n            // Update fire spread\r\n            let burningVoxels = 0;\r\n            for (let x = 0; x < gridSize; x++) {\r\n                for (let y = 0; y < gridSize; y++) {\r\n                    for (let z = 0; z < gridSize; z++) {\r\n                        const voxel = voxels[x][y][z];\r\n                        const mesh = voxelMeshes[x][y][z];\r\n\r\n                        if (voxel.isOnFire) {\r\n                            burningVoxels++;\r\n                            voxel.fuel -= 0.5; // Fuel consumption rate\r\n\r\n                            // Random flickering effect\r\n                            mesh.material.emissiveIntensity = 0.3 + Math.random() * 0.7;\r\n                            \r\n                            if (voxel.fuel <= 0) {\r\n                                // Voxel has burned out\r\n                                voxel.isOnFire = false;\r\n                                voxel.isFlammable = false;\r\n                                mesh.material = burntMaterial;\r\n                            } else {\r\n                                // Try to spread fire to neighbors\r\n                                voxel.neighbors.forEach(neighbor => {\r\n                                    if (neighbor.isFlammable && !neighbor.isOnFire) {\r\n                                        // 10% chance per frame to spread to each neighbor\r\n                                        if (Math.random() < 0.1) {\r\n                                            neighbor.isOnFire = true;\r\n                                            // Find and update the neighbor's mesh\r\n                                            for (let nx = 0; nx < gridSize; nx++) {\r\n                                                for (let ny = 0; ny < gridSize; ny++) {\r\n                                                    for (let nz = 0; nz < gridSize; nz++) {\r\n                                                        if (voxels[nx][ny][nz] === neighbor) {\r\n                                                            voxelMeshes[nx][ny][nz].material = burningMaterial;\r\n                                                            return;\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update smoke particles\r\n            if (smokeParticles) {\r\n                smokeParticles.visible = burningVoxels > 0;\r\n                if (smokeParticles.visible) {\r\n                    // Animate smoke particles\r\n                    const positions = smokeParticles.geometry.attributes.position.array;\r\n                    for (let i = 0; i < positions.length; i += 3) {\r\n                        positions[i + 1] += 0.02; // Particles rise\r\n                        if (positions[i + 1] > 5) {\r\n                            // Reset particle to bottom\r\n                            positions[i] = (Math.random() - 0.5) * 10;\r\n                            positions[i + 1] = -5;\r\n                            positions[i + 2] = (Math.random() - 0.5) * 10;\r\n                        }\r\n                    }\r\n                    smokeParticles.geometry.attributes.position.needsUpdate = true;\r\n                }\r\n            }\r\n\r\n            controls.update();\r\n            renderer.render(scene, camera);\r\n        }\r\n\r\n        // Reset button\r\n        document.getElementById('resetBtn').addEventListener('click', initVoxels);\r\n\r\n        // Event listeners\r\n        window.addEventListener('click', onMouseClick, false);\r\n        window.addEventListener('resize', () => {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        });\r\n\r\n        // Initialize\r\n        initVoxels();\r\n        createSmokeParticles();\r\n        animate();\r\n    </script>\r\n</body>\r\n</html>",
  "id": "voxel-fire-simulation-deepseek-v3",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "Particles",
      "WebGL",
      "Shaders",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.834Z",
    "model": "deepseek-v3",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, particles, webgl, shaders, simulation, architecture."
  }
}
