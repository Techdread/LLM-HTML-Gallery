{
  "title": "Galaxy Formation Simulation",
  "htmlContent": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Galaxy Formation Simulation</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n            font-family: Arial, sans-serif;\n            background-color: #000;\n            color: #fff;\n        }\n\n        #canvas-container {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n        }\n\n        #ui-container {\n            position: absolute;\n            top: 20px;\n            right: 20px;\n            width: 250px;\n            background-color: rgba(0, 0, 0, 0.7);\n            padding: 15px;\n            border-radius: 8px;\n            z-index: 100;\n        }\n\n        h1 {\n            margin: 0 0 15px 0;\n            font-size: 18px;\n            text-align: center;\n        }\n\n        .control-group {\n            margin-bottom: 15px;\n        }\n\n        label {\n            display: block;\n            margin-bottom: 5px;\n        }\n\n        input[type=\"range\"] {\n            width: 100%;\n        }\n\n        button {\n            background-color: #4CAF50;\n            border: none;\n            color: white;\n            padding: 8px 15px;\n            text-align: center;\n            text-decoration: none;\n            display: inline-block;\n            font-size: 14px;\n            margin: 4px 2px;\n            cursor: pointer;\n            border-radius: 4px;\n        }\n\n        button:hover {\n            background-color: #45a049;\n        }\n\n        .button-group {\n            display: flex;\n            justify-content: space-between;\n        }\n\n        select {\n            width: 100%;\n            padding: 5px;\n            border-radius: 4px;\n        }\n\n        input[type=\"color\"] {\n            width: 100%;\n            height: 30px;\n        }\n\n        .value-display {\n            text-align: right;\n            font-size: 12px;\n            margin-top: 3px;\n        }\n\n        .footer {\n            position: absolute;\n            bottom: 20px;\n            left: 20px;\n            font-size: 12px;\n            opacity: 0.7;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"canvas-container\"></div>\n    \n    <div id=\"ui-container\">\n        <h1>Galaxy Formation Simulation</h1>\n        \n        <div class=\"button-group\">\n            <button id=\"startBtn\">Start</button>\n            <button id=\"pauseBtn\">Pause</button>\n            <button id=\"resetBtn\">Reset</button>\n        </div>\n        \n        <div class=\"control-group\">\n            <label for=\"distribution\">Initial Distribution:</label>\n            <select id=\"distribution\">\n                <option value=\"random\">Random</option>\n                <option value=\"disk\">Disk</option>\n                <option value=\"sphere\">Sphere</option>\n                <option value=\"clusters\">Clustered</option>\n            </select>\n        </div>\n        \n        <div class=\"control-group\">\n            <label for=\"gravityStrength\">Gravity Strength: <span id=\"gravityValue\">0.05</span></label>\n            <input type=\"range\" id=\"gravityStrength\" min=\"0.01\" max=\"0.2\" step=\"0.01\" value=\"0.05\">\n        </div>\n        \n        <div class=\"control-group\">\n            <label for=\"particleSize\">Particle Size: <span id=\"sizeValue\">0.5</span></label>\n            <input type=\"range\" id=\"particleSize\" min=\"0.1\" max=\"2\" step=\"0.1\" value=\"0.5\">\n        </div>\n        \n        <div class=\"control-group\">\n            <label for=\"particleCount\">Particle Count: <span id=\"countValue\">5000</span></label>\n            <input type=\"range\" id=\"particleCount\" min=\"1000\" max=\"10000\" step=\"1000\" value=\"5000\">\n        </div>\n        \n        <div class=\"control-group\">\n            <label for=\"particleColor\">Particle Color:</label>\n            <input type=\"color\" id=\"particleColor\" value=\"#4287f5\">\n        </div>\n        \n        <div class=\"control-group\">\n            <label for=\"speedFactor\">Simulation Speed: <span id=\"speedValue\">1.0</span></label>\n            <input type=\"range\" id=\"speedFactor\" min=\"0.1\" max=\"3\" step=\"0.1\" value=\"1.0\">\n        </div>\n    </div>\n\n    <div class=\"footer\">\n        Use mouse to rotate. Scroll to zoom. Right-click and drag to pan.\n    </div>\n\n    <script type=\"module\">\n        // Import necessary modules\n        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0/build/three.module.js';\n        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';\n        import Stats from 'https://cdn.skypack.dev/stats.js@0.17.0';\n\n        // Main simulation variables\n        let scene, camera, renderer, particles;\n        let controls, stats;\n        let positions, velocities, accelerations;\n        let isSimulationRunning = false;\n        let particleSystem;\n        let particleCount = 5000;\n        let particleGeometry, particleMaterial;\n        let gravityStrength = 0.05;\n        let particleSize = 0.5;\n        let distributionType = 'random';\n        let speedFactor = 1.0;\n\n        // Initialize the application\n        init();\n        createControls();\n        animate();\n\n        function init() {\n            // Create scene\n            scene = new THREE.Scene();\n            \n            // Create camera\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);\n            camera.position.z = 100;\n            \n            // Create renderer\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.setClearColor(0x000000, 1);\n            document.getElementById('canvas-container').appendChild(renderer.domElement);\n            \n            // Add ambient light\n            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n            scene.add(ambientLight);\n\n            // Add directional light\n            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\n            directionalLight.position.set(1, 1, 1);\n            scene.add(directionalLight);\n            \n            // Create particle system\n            createParticles();\n\n            // Setup camera controls\n            setupCameraControls();\n\n            // Setup Stats\n            stats = new Stats();\n            stats.domElement.style.position = 'absolute';\n            stats.domElement.style.top = '10px';\n            stats.domElement.style.left = '10px';\n            document.getElementById('canvas-container').appendChild(stats.domElement);\n\n            // Add event listener for window resize\n            window.addEventListener('resize', onWindowResize, false);\n        }\n\n        function createParticles() {\n            // Clean up previous particles if they exist\n            if (particleSystem) {\n                scene.remove(particleSystem);\n                particleGeometry.dispose();\n                particleMaterial.dispose();\n            }\n            \n            // Create arrays to store particle properties\n            positions = new Float32Array(particleCount * 3);\n            velocities = new Float32Array(particleCount * 3);\n            accelerations = new Float32Array(particleCount * 3);\n            \n            // Initialize particles based on distribution type\n            initializeParticleDistribution();\n            \n            // Create particle geometry\n            particleGeometry = new THREE.BufferGeometry();\n            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n            \n            // Create particle material\n            const color = document.getElementById('particleColor').value;\n            particleMaterial = new THREE.PointsMaterial({\n                color: color,\n                size: particleSize,\n                transparent: true,\n                opacity: 0.8,\n                vertexColors: false,\n                sizeAttenuation: true,\n            });\n            \n            // Create particle system\n            particleSystem = new THREE.Points(particleGeometry, particleMaterial);\n            scene.add(particleSystem);\n        }\n\n        function initializeParticleDistribution() {\n            const radius = 50;\n            \n            for (let i = 0; i < particleCount; i++) {\n                const i3 = i * 3;\n                \n                // Initialize position\n                switch (distributionType) {\n                    case 'random':\n                        positions[i3] = (Math.random() - 0.5) * radius * 2;\n                        positions[i3 + 1] = (Math.random() - 0.5) * radius * 2;\n                        positions[i3 + 2] = (Math.random() - 0.5) * radius * 2;\n                        break;\n                        \n                    case 'disk':\n                        const r = Math.random() * radius;\n                        const theta = Math.random() * Math.PI * 2;\n                        positions[i3] = r * Math.cos(theta);\n                        positions[i3 + 1] = (Math.random() - 0.5) * radius * 0.2; // Thin disk\n                        positions[i3 + 2] = r * Math.sin(theta);\n                        \n                        // Add initial rotation to create a spiral\n                        const vScale = Math.sqrt(r) * 0.1;\n                        velocities[i3] = -positions[i3 + 2] * vScale;\n                        velocities[i3 + 1] = (Math.random() - 0.5) * 0.01;\n                        velocities[i3 + 2] = positions[i3] * vScale;\n                        break;\n                        \n                    case 'sphere':\n                        // Generate points on a sphere\n                        const phi = Math.acos(2 * Math.random() - 1);\n                        const theta2 = Math.random() * Math.PI * 2;\n                        const r2 = radius * Math.pow(Math.random(), 1/3); // Uniform density\n                        \n                        positions[i3] = r2 * Math.sin(phi) * Math.cos(theta2);\n                        positions[i3 + 1] = r2 * Math.sin(phi) * Math.sin(theta2);\n                        positions[i3 + 2] = r2 * Math.cos(phi);\n                        \n                        // Add some initial velocity\n                        const p = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);\n                        const cross = new THREE.Vector3(0, 1, 0).cross(p.normalize());\n                        velocities[i3] = cross.x * 0.1;\n                        velocities[i3 + 1] = cross.y * 0.1;\n                        velocities[i3 + 2] = cross.z * 0.1;\n                        break;\n                        \n                    case 'clusters':\n                        // Generate multiple clusters\n                        const numClusters = 3;\n                        const clusterRadius = radius / 3;\n                        const clusterIndex = Math.floor(Math.random() * numClusters);\n                        \n                        // Generate cluster centers\n                        const centers = [];\n                        for (let j = 0; j < numClusters; j++) {\n                            centers.push({\n                                x: (Math.random() - 0.5) * radius,\n                                y: (Math.random() - 0.5) * radius,\n                                z: (Math.random() - 0.5) * radius\n                            });\n                        }\n                        \n                        // Position within the cluster\n                        positions[i3] = centers[clusterIndex].x + (Math.random() - 0.5) * clusterRadius;\n                        positions[i3 + 1] = centers[clusterIndex].y + (Math.random() - 0.5) * clusterRadius;\n                        positions[i3 + 2] = centers[clusterIndex].z + (Math.random() - 0.5) * clusterRadius;\n                        break;\n                }\n                \n                // Initialize velocity (if not already set in the distribution logic)\n                if (distributionType === 'random' || distributionType === 'clusters') {\n                    velocities[i3] = (Math.random() - 0.5) * 0.01;\n                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.01;\n                    velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;\n                }\n                \n                // Initialize acceleration\n                accelerations[i3] = 0;\n                accelerations[i3 + 1] = 0;\n                accelerations[i3 + 2] = 0;\n            }\n        }\n\n        function setupCameraControls() {\n            // Setup OrbitControls\n            controls = new OrbitControls(camera, renderer.domElement); \n            controls.enableDamping = true;\n            controls.dampingFactor = 0.05;\n            controls.screenSpacePanning = false;\n            controls.minDistance = 10;\n            controls.maxDistance = 500;\n        }\n\n        function createControls() {\n            // Control button event listeners\n            document.getElementById('startBtn').addEventListener('click', startSimulation);\n            document.getElementById('pauseBtn').addEventListener('click', pauseSimulation);\n            document.getElementById('resetBtn').addEventListener('click', resetSimulation);\n            \n            // Slider controls\n            document.getElementById('gravityStrength').addEventListener('input', function(e) {\n                gravityStrength = parseFloat(e.target.value);\n                document.getElementById('gravityValue').textContent = gravityStrength.toFixed(2);\n            });\n            \n            document.getElementById('particleSize').addEventListener('input', function(e) {\n                particleSize = parseFloat(e.target.value);\n                document.getElementById('sizeValue').textContent = particleSize.toFixed(1);\n                particleMaterial.size = particleSize;\n            });\n            \n            document.getElementById('particleCount').addEventListener('input', function(e) {\n                document.getElementById('countValue').textContent = e.target.value;\n            });\n            \n            document.getElementById('particleCount').addEventListener('change', function(e) {\n                particleCount = parseInt(e.target.value);\n                resetSimulation();\n            });\n            \n            document.getElementById('distribution').addEventListener('change', function(e) {\n                distributionType = e.target.value;\n                resetSimulation();\n            });\n            \n            document.getElementById('particleColor').addEventListener('input', function(e) {\n                particleMaterial.color.set(e.target.value);\n            });\n            \n            document.getElementById('speedFactor').addEventListener('input', function(e) {\n                speedFactor = parseFloat(e.target.value);\n                document.getElementById('speedValue').textContent = speedFactor.toFixed(1);\n            });\n        }\n\n        function startSimulation() {\n            isSimulationRunning = true;\n        }\n\n        function pauseSimulation() {\n            isSimulationRunning = false;\n        }\n\n        function resetSimulation() {\n            isSimulationRunning = false;\n            createParticles();\n        }\n\n        function updateParticles() {\n            if (!isSimulationRunning) return;\n            \n            // Reset accelerations\n            for (let i = 0; i < particleCount * 3; i++) {\n                accelerations[i] = 0;\n            }\n            \n            // Calculate gravitational forces\n            calculateGravitationalForces();\n            \n            // Update velocities and positions\n            const dt = 0.016 * speedFactor; // Time step with speed factor\n            \n            for (let i = 0; i < particleCount; i++) {\n                const i3 = i * 3;\n                \n                // Update velocity using acceleration\n                velocities[i3] += accelerations[i3] * dt;\n                velocities[i3 + 1] += accelerations[i3 + 1] * dt;\n                velocities[i3 + 2] += accelerations[i3 + 2] * dt;\n                \n                // Update position using velocity\n                positions[i3] += velocities[i3] * dt;\n                positions[i3 + 1] += velocities[i3 + 1] * dt;\n                positions[i3 + 2] += velocities[i3 + 2] * dt;\n            }\n            \n            // Update particle system\n            particleGeometry.attributes.position.needsUpdate = true;\n        }\n\n        function calculateGravitationalForces() {\n            // Simplification: Only calculate forces from a subset of particles\n            const sampleSize = Math.min(100, particleCount);\n            const samples = [];\n            \n            // Select sample particles\n            for (let i = 0; i < sampleSize; i++) {\n                const index = Math.floor(Math.random() * particleCount);\n                samples.push({\n                    x: positions[index * 3],\n                    y: positions[index * 3 + 1],\n                    z: positions[index * 3 + 2],\n                    mass: 1.0\n                });\n            }\n            \n            // Calculate acceleration due to gravitational force for each particle\n            for (let i = 0; i < particleCount; i++) {\n                const i3 = i * 3;\n                \n                for (let j = 0; j < samples.length; j++) {\n                    const sample = samples[j];\n                    \n                    // Vector from particle to sample\n                    const dx = sample.x - positions[i3];\n                    const dy = sample.y - positions[i3 + 1];\n                    const dz = sample.z - positions[i3 + 2];\n                    \n                    // Distance squared\n                    let distSquared = dx * dx + dy * dy + dz * dz;\n                    \n                    // Prevent division by zero and extremely high accelerations\n                    const minDist = 1.0;\n                    if (distSquared < minDist) {\n                        distSquared = minDist;\n                    }\n                    \n                    // Calculate gravitational force\n                    const force = gravityStrength * sample.mass / distSquared;\n                    \n                    // Distance\n                    const dist = Math.sqrt(distSquared);\n                    \n                    // Add acceleration\n                    accelerations[i3] += force * dx / dist;\n                    accelerations[i3 + 1] += force * dy / dist;\n                    accelerations[i3 + 2] += force * dz / dist;\n                }\n            }\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n            \n            controls.update();\n            updateParticles();\n            \n            renderer.render(scene, camera);\n            stats.update();\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n    </script>\n</body>\n</html>",
  "id": "galaxy-simulation-claude-3-7",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "Particles",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.726Z",
    "model": "claude-3.7",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, particles, webgl, shaders, astronomy, simulation, architecture."
  }
}
