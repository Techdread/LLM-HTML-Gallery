{
  "title": "Futuristic Cityscape - ThreeJS Simulation",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Futuristic Cityscape - ThreeJS Simulation</title>\r\n    <style>\r\n        * {\r\n            margin: 0;\r\n            padding: 0;\r\n            box-sizing: border-box;\r\n        }\r\n\r\n        body {\r\n            overflow: hidden;\r\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n            background: #000;\r\n            color: #fff;\r\n        }\r\n\r\n        #canvas-container {\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            width: 100%;\r\n            height: 100%;\r\n            background: #000;\r\n        }\r\n\r\n        #ui-panel {\r\n            position: absolute;\r\n            top: 20px;\r\n            left: 20px;\r\n            width: 300px;\r\n            background: rgba(0, 0, 0, 0.7);\r\n            border-radius: 12px;\r\n            padding: 16px;\r\n            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);\r\n            z-index: 100;\r\n            backdrop-filter: blur(8px);\r\n        }\r\n\r\n        h2 {\r\n            margin-bottom: 12px;\r\n            font-size: 1.4em;\r\n            color: #0ff;\r\n            text-align: center;\r\n            border-bottom: 1px dashed #0ff;\r\n            padding-bottom: 8px;\r\n        }\r\n\r\n        .control-group {\r\n            margin-bottom: 16px;\r\n        }\r\n\r\n        label {\r\n            display: block;\r\n            margin-bottom: 6px;\r\n            font-size: 0.9em;\r\n            color: #ccc;\r\n        }\r\n\r\n        input[type=\"range\"],\r\n        input[type=\"number\"] {\r\n            width: 100%;\r\n            height: 8px;\r\n            border-radius: 4px;\r\n            background: #333;\r\n            outline: none;\r\n        }\r\n\r\n        input[type=\"range\"]::-webkit-slider-thumb,\r\n        input[type=\"number\"]::-webkit-inner-spin-button {\r\n            appearance: none;\r\n        }\r\n\r\n        input[type=\"range\"]::-webkit-slider-thumb {\r\n            width: 16px;\r\n            height: 16px;\r\n            border-radius: 50%;\r\n            background: #0ff;\r\n            cursor: pointer;\r\n        }\r\n\r\n        input[type=\"number\"] {\r\n            background: #222;\r\n            border: 1px solid #444;\r\n            color: #fff;\r\n            padding: 6px 8px;\r\n            border-radius: 4px;\r\n            font-size: 0.9em;\r\n        }\r\n\r\n        .info {\r\n            font-size: 0.8em;\r\n            color: #aaa;\r\n            margin-top: 8px;\r\n            text-align: center;\r\n        }\r\n\r\n        #instructions {\r\n            position: absolute;\r\n            bottom: 20px;\r\n            left: 20px;\r\n            background: rgba(0, 0, 0, 0.6);\r\n            padding: 12px 16px;\r\n            border-radius: 8px;\r\n            font-size: 0.85em;\r\n            color: #ccc;\r\n            max-width: 300px;\r\n            z-index: 100;\r\n            backdrop-filter: blur(6px);\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n\r\n    <div id=\"canvas-container\"></div>\r\n\r\n    <div id=\"ui-panel\">\r\n        <h2>Futuristic City Simulator</h2>\r\n\r\n        <div class=\"control-group\">\r\n            <label for=\"grid-size\">Grid Size (x, z)</label>\r\n            <input type=\"range\" id=\"grid-size\" min=\"5\" max=\"20\" value=\"10\" step=\"1\" />\r\n            <span id=\"grid-size-val\">10</span>\r\n        </div>\r\n\r\n        <div class=\"control-group\">\r\n            <label for=\"city-size\">City Size (Scale)</label>\r\n            <input type=\"range\" id=\"city-size\" min=\"1\" max=\"5\" value=\"2\" step=\"0.1\" />\r\n            <span id=\"city-size-val\">2.0</span>\r\n        </div>\r\n\r\n        <div class=\"control-group\">\r\n            <label for=\"vehicle-count\">Flying Vehicles</label>\r\n            <input type=\"range\" id=\"vehicle-count\" min=\"1\" max=\"50\" value=\"10\" step=\"1\" />\r\n            <span id=\"vehicle-count-val\">10</span>\r\n        </div>\r\n\r\n        <div class=\"info\">\r\n            Use WASD + Mouse to move camera. Scroll to zoom.\r\n        </div>\r\n    </div>\r\n\r\n    <div id=\"instructions\">\r\n        <strong>Controls:</strong><br>\r\n        WASD: Move<br>\r\n        Mouse: Look around<br>\r\n        Scroll: Zoom<br>\r\n        Adjust settings in the panel to customize the city.\r\n    </div>\r\n\r\n    <!-- ThreeJS Library -->\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/controls/OrbitControls.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/geometries/ParametricGeometries.js\"></script>\r\n\r\n    <script>\r\n        // Main simulation variables\r\n        let scene, camera, renderer, controls;\r\n        let grid = 10, cityScale = 2.0, vehicleCount = 10;\r\n        let buildings = [];\r\n        let vehicles = [];\r\n        let sun, moon;\r\n        let clock = new THREE.Clock();\r\n        let time = 0;\r\n\r\n        // Initialize scene\r\n        function init() {\r\n            scene = new THREE.Scene();\r\n            scene.background = new THREE.Color(0x000814);\r\n\r\n            // Camera\r\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n            camera.position.set(0, 30, 50);\r\n\r\n            // Renderer\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            renderer.setPixelRatio(window.devicePixelRatio);\r\n            renderer.shadowMap.enabled = true;\r\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n            document.getElementById('canvas-container').appendChild(renderer.domElement);\r\n\r\n            // Controls\r\n            controls = new THREE.OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n            controls.minDistance = 10;\r\n            controls.maxDistance = 100;\r\n\r\n            // Lights\r\n            const ambientLight = new THREE.AmbientLight(0x404040, 1);\r\n            scene.add(ambientLight);\r\n\r\n            sun = new THREE.DirectionalLight(0xffffff, 1);\r\n            sun.position.set(100, 100, 50);\r\n            sun.castShadow = true;\r\n            sun.shadow.mapSize.set(2048, 2048);\r\n            sun.shadow.camera.near = 0.5;\r\n            sun.shadow.camera.far = 500;\r\n            scene.add(sun);\r\n\r\n            moon = new THREE.DirectionalLight(0x88ccff, 0.3);\r\n            moon.position.set(-100, 100, -50);\r\n            scene.add(moon);\r\n\r\n            // Ground\r\n            const groundGeo = new THREE.PlaneGeometry(100, 100);\r\n            const groundMat = new THREE.MeshStandardMaterial({\r\n                color: 0x0a200a,\r\n                roughness: 0.8,\r\n                metalness: 0.1,\r\n                side: THREE.DoubleSide\r\n            });\r\n            const ground = new THREE.Mesh(groundGeo, groundMat);\r\n            ground.rotation.x = -Math.PI / 2;\r\n            ground.position.y = -0.1;\r\n            ground.receiveShadow = true;\r\n            scene.add(ground);\r\n\r\n            // Add terrain (beach, park)\r\n            createTerrain();\r\n\r\n            // Generate city\r\n            generateCity();\r\n\r\n            // Add UI event listeners\r\n            setupUI();\r\n\r\n            // Handle window resize\r\n            window.addEventListener('resize', onWindowResize);\r\n\r\n            // Start animation loop\r\n            animate();\r\n        }\r\n\r\n        function createTerrain() {\r\n            // Beach\r\n            const beachGeo = new THREE.PlaneGeometry(30, 30);\r\n            const beachMat = new THREE.MeshStandardMaterial({\r\n                color: 0xf0e4a0,\r\n                roughness: 0.6,\r\n                metalness: 0.1\r\n            });\r\n            const beach = new THREE.Mesh(beachGeo, beachMat);\r\n            beach.rotation.x = -Math.PI / 2;\r\n            beach.position.set(20, -0.05, 20);\r\n            beach.receiveShadow = true;\r\n            scene.add(beach);\r\n\r\n            // Park\r\n            const parkGeo = new THREE.PlaneGeometry(25, 25);\r\n            const parkMat = new THREE.MeshStandardMaterial({\r\n                color: 0x208020,\r\n                roughness: 0.7,\r\n                metalness: 0.05\r\n            });\r\n            const park = new THREE.Mesh(parkGeo, parkMat);\r\n            park.rotation.x = -Math.PI / 2;\r\n            park.position.set(-20, -0.05, -20);\r\n            park.receiveShadow = true;\r\n            scene.add(park);\r\n\r\n            // Add grass particles\r\n            const grassGeo = new THREE.BufferGeometry();\r\n            const grassCount = 1000;\r\n            const positions = new Float32Array(grassCount * 3);\r\n            for (let i = 0; i < grassCount; i++) {\r\n                const i3 = i * 3;\r\n                positions[i3] = (Math.random() - 0.5) * 50;\r\n                positions[i3 + 1] = -0.01;\r\n                positions[i3 + 2] = (Math.random() - 0.5) * 50;\r\n            }\r\n            grassGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));\r\n            const grassMat = new THREE.PointsMaterial({ color: 0x30a030, size: 0.3, sizeAttenuation: false });\r\n            const grass = new THREE.Points(grassGeo, grassMat);\r\n            scene.add(grass);\r\n        }\r\n\r\n        function generateCity() {\r\n            // Clear previous\r\n            buildings.forEach(b => scene.remove(b));\r\n            buildings = [];\r\n\r\n            const size = grid * cityScale;\r\n            const step = size / grid;\r\n\r\n            // Create buildings\r\n            for (let x = 0; x < grid; x++) {\r\n                for (let z = 0; z < grid; z++) {\r\n                    const posX = (x - grid / 2) * step;\r\n                    const posZ = (z - grid / 2) * step;\r\n\r\n                    const height = 5 + Math.random() * 30;\r\n                    const width = step * 0.8;\r\n                    const depth = step * 0.8;\r\n\r\n                    const building = createBuilding(posX, height, posZ, width, depth);\r\n                    scene.add(building);\r\n                    buildings.push(building);\r\n                }\r\n            }\r\n\r\n            // Create vehicle paths\r\n            createVehiclePaths();\r\n        }\r\n\r\n        function createBuilding(x, height, z, width, depth) {\r\n            const random = Math.random();\r\n            const color = random < 0.3 ? 0x2040a0 :\r\n                random < 0.6 ? 0x6020a0 :\r\n                    0x2080a0;\r\n\r\n            const geo = new THREE.BoxGeometry(width, height, depth);\r\n            const mat = new THREE.MeshStandardMaterial({\r\n                color: color,\r\n                roughness: 0.5,\r\n                metalness: 0.3\r\n            });\r\n            const building = new THREE.Mesh(geo, mat);\r\n            building.position.set(x, height / 2, z);\r\n            building.castShadow = true;\r\n            building.receiveShadow = true;\r\n\r\n            // Add windows\r\n            const windowWidth = width * 0.2;\r\n            const windowDepth = depth * 0.2;\r\n            const windowHeight = height * 0.1;\r\n            const windowCount = Math.floor(height / 10);\r\n\r\n            for (let i = 0; i < windowCount; i++) {\r\n                const windowY = height / 2 - height * 0.2 + i * (height * 0.2);\r\n                const windowX = (Math.random() - 0.5) * width * 0.8;\r\n                const windowZ = (Math.random() - 0.5) * depth * 0.8;\r\n\r\n                const windowGeo = new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth);\r\n                const windowMat = new THREE.MeshStandardMaterial({\r\n                    color: 0x88ccff,\r\n                    roughness: 0.1,\r\n                    metalness: 0.5\r\n                });\r\n                const window = new THREE.Mesh(windowGeo, windowMat);\r\n                window.position.set(x + windowX, windowY, z + windowZ);\r\n                window.castShadow = true;\r\n                window.receiveShadow = true;\r\n                building.add(window);\r\n            }\r\n\r\n            return building;\r\n        }\r\n\r\n        function createVehiclePaths() {\r\n            // Clear old vehicles\r\n            vehicles.forEach(v => scene.remove(v.mesh));\r\n            vehicles = [];\r\n\r\n            const paths = [];\r\n            const totalPaths = vehicleCount;\r\n\r\n            for (let i = 0; i < totalPaths; i++) {\r\n                const start = new THREE.Vector3(\r\n                    Math.random() * 80 - 40,\r\n                    10 + Math.random() * 10,\r\n                    Math.random() * 80 - 40\r\n                );\r\n                const end = new THREE.Vector3(\r\n                    Math.random() * 80 - 40,\r\n                    10 + Math.random() * 10,\r\n                    Math.random() * 80 - 40\r\n                );\r\n\r\n                const path = {\r\n                    start,\r\n                    end,\r\n                    points: [],\r\n                    speed: 0.05 + Math.random() * 0.05,\r\n                    progress: 0,\r\n                    direction: 0\r\n                };\r\n\r\n                // Create a smooth path between start and end\r\n                const steps = 10;\r\n                for (let j = 0; j <= steps; j++) {\r\n                    const t = j / steps;\r\n                    const x = start.x + (end.x - start.x) * t;\r\n                    const y = start.y + (end.y - start.y) * t + Math.sin(t * Math.PI) * 2;\r\n                    const z = start.z + (end.z - start.z) * t;\r\n                    path.points.push(new THREE.Vector3(x, y, z));\r\n                }\r\n\r\n                paths.push(path);\r\n            }\r\n\r\n            // Create vehicle models\r\n            for (let i = 0; i < totalPaths; i++) {\r\n                const path = paths[i];\r\n                const vehicle = createVehicle(path);\r\n                vehicles.push({ mesh: vehicle, path });\r\n            }\r\n        }\r\n\r\n        function createVehicle(path) {\r\n            const geo = new THREE.ConeGeometry(0.5, 2, 8);\r\n            const mat = new THREE.MeshStandardMaterial({\r\n                color: 0x00ff88,\r\n                roughness: 0.2,\r\n                metalness: 0.8\r\n            });\r\n            const body = new THREE.Mesh(geo, mat);\r\n            body.position.copy(path.start);\r\n            body.castShadow = true;\r\n            body.receiveShadow = true;\r\n\r\n            // Add lights\r\n            const light = new THREE.PointLight(0x00ffff, 1, 10);\r\n            light.position.set(0, 0, 1);\r\n            body.add(light);\r\n\r\n            // Add glow\r\n            const glow = new THREE.PointLight(0x00ffff, 0.5, 5);\r\n            glow.position.set(0, 0, -1);\r\n            body.add(glow);\r\n\r\n            // Add thrusters\r\n            const thrusterGeo = new THREE.ConeGeometry(0.3, 0.8, 6);\r\n            const thrusterMat = new THREE.MeshStandardMaterial({ color: 0xff5500 });\r\n            const thruster = new THREE.Mesh(thrusterGeo, thrusterMat);\r\n            thruster.position.set(0, -1, 0);\r\n            thruster.rotation.x = Math.PI;\r\n            body.add(thruster);\r\n\r\n            scene.add(body);\r\n            return body;\r\n        }\r\n\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n\r\n            time += clock.getDelta();\r\n            const hour = (time % (24 * 60 * 60)) / (60 * 60); // 0-24\r\n\r\n            // Day-night cycle\r\n            const sunAngle = (hour / 24) * Math.PI * 2;\r\n            sun.position.set(\r\n                Math.cos(sunAngle) * 100,\r\n                Math.sin(sunAngle) * 100,\r\n                Math.sin(sunAngle) * 50\r\n            );\r\n            moon.position.set(\r\n                -Math.cos(sunAngle) * 100,\r\n                Math.sin(sunAngle) * 100,\r\n                -Math.sin(sunAngle) * 50\r\n            );\r\n\r\n            // Update lighting\r\n            const intensity = Math.max(0.1, Math.sin(hour * Math.PI / 12));\r\n            sun.intensity = intensity;\r\n            moon.intensity = Math.max(0.05, 0.3 - intensity * 0.3);\r\n\r\n            // Update vehicles\r\n            vehicles.forEach(v => {\r\n                const path = v.path;\r\n                const speed = path.speed;\r\n                path.progress += speed;\r\n\r\n                if (path.progress >= path.points.length - 1) {\r\n                    path.progress = 0;\r\n                }\r\n\r\n                const i = Math.floor(path.progress);\r\n                const t = path.progress - i;\r\n                const p1 = path.points[i];\r\n                const p2 = path.points[i + 1];\r\n\r\n                const newPos = new THREE.Vector3().lerpVectors(p1, p2, t);\r\n                v.mesh.position.copy(newPos);\r\n\r\n                // Rotate to face direction\r\n                const dir = new THREE.Vector3().subVectors(p2, p1).normalize();\r\n                v.mesh.quaternion.lookAt(newPos.clone().add(dir));\r\n            });\r\n\r\n            controls.update();\r\n            renderer.render(scene, camera);\r\n        }\r\n\r\n        function onWindowResize() {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n\r\n        function setupUI() {\r\n            const gridSizeInput = document.getElementById('grid-size');\r\n            const gridSizeVal = document.getElementById('grid-size-val');\r\n            const citySizeInput = document.getElementById('city-size');\r\n            const citySizeVal = document.getElementById('city-size-val');\r\n            const vehicleCountInput = document.getElementById('vehicle-count');\r\n            const vehicleCountVal = document.getElementById('vehicle-count-val');\r\n\r\n            gridSizeInput.addEventListener('input', () => {\r\n                grid = parseInt(gridSizeInput.value);\r\n                gridSizeVal.textContent = grid;\r\n                generateCity();\r\n            });\r\n\r\n            citySizeInput.addEventListener('input', () => {\r\n                cityScale = parseFloat(citySizeInput.value);\r\n                citySizeVal.textContent = cityScale.toFixed(1);\r\n                generateCity();\r\n            });\r\n\r\n            vehicleCountInput.addEventListener('input', () => {\r\n                vehicleCount = parseInt(vehicleCountInput.value);\r\n                vehicleCountVal.textContent = vehicleCount;\r\n                createVehiclePaths();\r\n            });\r\n        }\r\n\r\n        // Start the simulation\r\n        init();\r\n    </script>\r\n\r\n</body>\r\n\r\n</html>",
  "id": "futuristic-city-qwen3-30b-a3b-instruct",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "Particles",
      "WebGL",
      "Shaders",
      "Simulation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:58.136Z",
    "model": "qwen3-30b-a3b-instruct",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, particles, webgl, shaders, simulation, architecture."
  }
}
