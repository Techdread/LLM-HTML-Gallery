{
  "title": "Procedural City Generator",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Procedural City Generator</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n        }\r\n\r\n        canvas {\r\n            display: block;\r\n        }\r\n\r\n        #ui {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            z-index: 10;\r\n            background: rgba(255, 255, 255, 0.85);\r\n            border-radius: 8px;\r\n            padding: 12px 20px 8px 16px;\r\n            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\r\n            font-family: sans-serif;\r\n            font-size: 15px;\r\n        }\r\n\r\n        #ui label {\r\n            margin-right: 6px;\r\n        }\r\n\r\n        #ui input[type=range] {\r\n            width: 80px;\r\n        }\r\n\r\n        #ui select {\r\n            margin-left: 5px;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"ui\">\r\n        <label>City Seed: <input type=\"number\" id=\"seed\" min=\"1\" max=\"99999\" value=\"1\" /></label>\r\n        <label>City Size: <input type=\"range\" id=\"size\" min=\"8\" max=\"40\" value=\"20\" /></label>\r\n        <label>Density: <input type=\"range\" id=\"density\" min=\"1\" max=\"3\" step=\"0.1\" value=\"2\" /></label>\r\n        <label>Districts: <select id=\"districtStyle\">\r\n                <option value=\"grid\">Grid</option>\r\n                <option value=\"organic\">Organic</option>\r\n            </select></label>\r\n        <button id=\"regen\">Regenerate</button>\r\n    </div>\r\n    <!-- Import map for three.js and its addons -->\r\n    <script type=\"importmap\">\r\n{\r\n  \"imports\": {\r\n    \"three\": \"https://unpkg.com/three@0.165.0/build/three.module.js\",\r\n    \"three/addons/\": \"https://unpkg.com/three@0.165.0/examples/jsm/\"\r\n  }\r\n}\r\n</script>\r\n    <script type=\"module\">\r\n        import * as THREE from 'three';\r\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\n        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\r\n\r\n        let scene, camera, renderer, controls, cityGroup, clock;\r\n        let SEED = 1, CITY_SIZE = 20, DENSITY = 2, DISTRICT_STYLE = 'grid';\r\n\r\n        init();\r\n        generateCity();\r\n        animate();\r\n\r\n        function init() {\r\n            scene = new THREE.Scene();\r\n            scene.background = new THREE.Color(0xaec6cf);\r\n            clock = new THREE.Clock();\r\n            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n            camera.position.set(0, CITY_SIZE * 1.5, CITY_SIZE * 2.2);\r\n            camera.lookAt(0, 0, 0);\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            document.body.appendChild(renderer.domElement);\r\n            controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.15;\r\n            controls.maxPolarAngle = Math.PI / 2.1;\r\n            controls.minDistance = CITY_SIZE * 0.7;\r\n            controls.maxDistance = CITY_SIZE * 4;\r\n            // UI events\r\n            document.getElementById('regen').onclick = () => {\r\n                updateParams();\r\n                generateCity();\r\n            };\r\n            document.getElementById('seed').oninput = document.getElementById('size').oninput = document.getElementById('density').oninput = document.getElementById('districtStyle').oninput = function () {\r\n                updateParams();\r\n            };\r\n            window.addEventListener('resize', onWindowResize);\r\n        }\r\n\r\n        function updateParams() {\r\n            SEED = parseInt(document.getElementById('seed').value);\r\n            CITY_SIZE = parseInt(document.getElementById('size').value);\r\n            DENSITY = parseFloat(document.getElementById('density').value);\r\n            DISTRICT_STYLE = document.getElementById('districtStyle').value;\r\n        }\r\n\r\n        function generateCity() {\r\n            if (cityGroup) scene.remove(cityGroup);\r\n            cityGroup = new THREE.Group();\r\n            const rng = mulberry32(SEED);\r\n            const districtMap = createDistrictMap(CITY_SIZE, DISTRICT_STYLE, rng);\r\n            // Roads\r\n            const roadMat = new THREE.MeshStandardMaterial({ color: 0x222428, roughness: 0.5, metalness: 0.3 });\r\n            for (let i = 0; i < CITY_SIZE; ++i) for (let j = 0; j < CITY_SIZE; ++j) {\r\n                if (districtMap.roads[i][j]) {\r\n                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 0.08, 1), roadMat);\r\n                    mesh.position.set(i - CITY_SIZE / 2, 0, j - CITY_SIZE / 2);\r\n                    cityGroup.add(mesh);\r\n                }\r\n            }\r\n            // District Zoning + Buildings\r\n            for (let i = 0; i < CITY_SIZE; ++i) for (let j = 0; j < CITY_SIZE; ++j) {\r\n                if (!districtMap.roads[i][j]) {\r\n                    const zone = districtMap.zones[i][j];\r\n                    if (!zone) continue;\r\n                    const height = getBuildingHeight(zone, rng, DENSITY, i, j, CITY_SIZE);\r\n                    const mesh = createBuildingMesh(zone, height, rng);\r\n                    mesh.position.set(i - CITY_SIZE / 2, height / 2, j - CITY_SIZE / 2);\r\n                    cityGroup.add(mesh);\r\n                }\r\n            }\r\n            // Parks/Green spaces\r\n            for (const park of districtMap.parks) {\r\n                const parkGeo = new THREE.BoxGeometry(park.size, 0.06, park.size);\r\n                const parkMat = new THREE.MeshStandardMaterial({ color: 0x61c48a });\r\n                const parkMesh = new THREE.Mesh(parkGeo, parkMat);\r\n                parkMesh.position.set(park.x - CITY_SIZE / 2, 0.035, park.z - CITY_SIZE / 2);\r\n                cityGroup.add(parkMesh);\r\n            }\r\n            // Street lights (simple for demo)\r\n            for (let i = 0; i < CITY_SIZE; ++i) for (let j = 0; j < CITY_SIZE; ++j) {\r\n                if (districtMap.roads[i][j] && rng() < 0.06) {\r\n                    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.7, 10), new THREE.MeshStandardMaterial({ color: 0xe5e3ce, metalness: 0.6, roughness: 0.4 }));\r\n                    pole.position.set(i - CITY_SIZE / 2, 0.35, j - CITY_SIZE / 2);\r\n                    cityGroup.add(pole);\r\n                    const light = new THREE.PointLight(0xffeeaa, 0.7, 2.5, 2);\r\n                    light.position.set(i - CITY_SIZE / 2, 0.72, j - CITY_SIZE / 2);\r\n                    cityGroup.add(light);\r\n                }\r\n            }\r\n            // Add subtle city ambient & sun\r\n            scene.add(new THREE.AmbientLight(0xddddff, 0.35));\r\n            const sun = new THREE.DirectionalLight(0xfffbdb, 1.2);\r\n            sun.position.set(1.8, 2.6, 1.7);\r\n            scene.add(sun);\r\n            // Drop shadow below city\r\n            const cityBase = new THREE.Mesh(\r\n                new THREE.CylinderGeometry(CITY_SIZE * 0.73, CITY_SIZE * 0.68, 0.08, 50),\r\n                new THREE.MeshStandardMaterial({ color: 0x2c393c, roughness: 0.6, metalness: 0.2, transparent: true, opacity: 0.6 })\r\n            );\r\n            cityBase.position.y = -0.04;\r\n            cityGroup.add(cityBase);\r\n            scene.add(cityGroup);\r\n        }\r\n\r\n        function createDistrictMap(size, style, rng) {\r\n            // Initialize empty grid\r\n            const roads = Array(size).fill(0).map(() => Array(size).fill(false));\r\n            const zones = Array(size).fill(0).map(() => Array(size).fill(null));\r\n            // Main road structure\r\n            if (style == \"grid\") {\r\n                for (let i = 0; i < size; i += 4 + Math.floor(rng() * 2)) {\r\n                    for (let j = 0; j < size; ++j) roads[i][j] = true;\r\n                }\r\n                for (let j = 0; j < size; j += 4 + Math.floor(rng() * 2)) {\r\n                    for (let i = 0; i < size; ++i) roads[i][j] = true;\r\n                }\r\n            } else {\r\n                // Simple \"organic\" network: some sine+noise based paths\r\n                for (let k = 0; k < 3; ++k) {\r\n                    let cx = Math.floor(size / 2 + (size / 4) * Math.sin(rng() * Math.PI * 2));\r\n                    let cz = Math.floor(size / 2 + (size / 4) * Math.cos(rng() * Math.PI * 2));\r\n                    for (let t = 0; t < size; ++t) {\r\n                        let x = Math.floor(cx + Math.sin(t / size * Math.PI * 2 + k) * size / 3 + (rng() - 0.5) * 2);\r\n                        let z = Math.floor(cz + Math.cos(t / size * Math.PI * 2 + k) * size / 3 + (rng() - 0.5) * 2);\r\n                        if (x >= 0 && x < size && z >= 0 && z < size) roads[x][z] = true;\r\n                    }\r\n                }\r\n                // Connect some radial lines from center\r\n                let cx = Math.floor(size / 2), cz = Math.floor(size / 2);\r\n                for (let a = 0; a < 6; ++a) {\r\n                    for (let r = 0; r < size / 2 - 1; ++r) {\r\n                        let x = Math.floor(cx + Math.sin(a / 6 * Math.PI * 2) * r);\r\n                        let z = Math.floor(cz + Math.cos(a / 6 * Math.PI * 2) * r);\r\n                        if (x >= 0 && x < size && z >= 0 && z < size) roads[x][z] = true;\r\n                    }\r\n                }\r\n            }\r\n            // Place parks\r\n            const parks = [];\r\n            for (let p = 0; p < size / 5; ++p) {\r\n                let parkSize = Math.round(2.2 + rng() * 2);\r\n                let x = Math.floor(rng() * (size - parkSize));\r\n                let z = Math.floor(rng() * (size - parkSize));\r\n                // Try not to overlap roads\r\n                let clear = true;\r\n                for (let dx = 0; dx < parkSize; ++dx)for (let dz = 0; dz < parkSize; ++dz) {\r\n                    if (roads[x + dx][z + dz]) clear = false;\r\n                }\r\n                if (clear) parks.push({ x: x + parkSize / 2, z: z + parkSize / 2, size: parkSize });\r\n            }\r\n            // Zoning: central = commercial, then residential, then industrial at edge\r\n            for (let i = 0; i < size; ++i) for (let j = 0; j < size; ++j) {\r\n                if (roads[i][j]) continue;\r\n                let distToCenter = Math.sqrt((i - size / 2) ** 2 + (j - size / 2) ** 2);\r\n                let zone = null;\r\n                if (distToCenter < size / 6) zone = 'commercial';\r\n                else if (distToCenter < size / 3) zone = 'residential';\r\n                else zone = 'industrial';\r\n                // Mark park cells as park\r\n                for (const park of parks) {\r\n                    if (Math.abs(i - park.x) < park.size / 2 && Math.abs(j - park.z) < park.size / 2) zone = null;\r\n                }\r\n                zones[i][j] = zone;\r\n            }\r\n            return { roads, zones, parks };\r\n        }\r\n\r\n        function getBuildingHeight(zone, rng, density, i, j, size) {\r\n            if (zone === 'commercial') return 2.8 + rng() * 2.7 + Math.abs(i - size / 2) * 0.12 + density * 0.6;\r\n            if (zone === 'residential') return 1.2 + rng() * 1.2 + density * 0.5;\r\n            if (zone === 'industrial') return 0.8 + rng() * 0.6 + density * 0.2;\r\n            return 0;\r\n        }\r\n\r\n        function createBuildingMesh(zone, h, rng) {\r\n            let w = 0.65 + rng() * 0.5;\r\n            let d = 0.65 + rng() * 0.5;\r\n            if (zone === 'commercial') {\r\n                if (rng() > 0.7) return createSkyscraperMesh(h, rng);\r\n                return new THREE.Mesh(\r\n                    new THREE.BoxGeometry(w, h, d),\r\n                    new THREE.MeshStandardMaterial({ color: 0x22303d, metalness: 0.4, roughness: 0.4 })\r\n                );\r\n            }\r\n            if (zone === 'residential') {\r\n                let color = [0xddeef2, 0xf0d8b0, 0xd9bba0, 0xc7eae4, 0xf4a698][Math.floor(rng() * 5)];\r\n                return new THREE.Mesh(\r\n                    new THREE.BoxGeometry(w, h, d),\r\n                    new THREE.MeshStandardMaterial({ color, metalness: 0.15, roughness: 0.65 })\r\n                );\r\n            }\r\n            if (zone === 'industrial') {\r\n                return new THREE.Mesh(\r\n                    new THREE.BoxGeometry(w * 1.2, h, d * 1.2),\r\n                    new THREE.MeshStandardMaterial({ color: 0xa09ea2, metalness: 0.4, roughness: 0.7 })\r\n                );\r\n            }\r\n        }\r\n        function createSkyscraperMesh(h, rng) {\r\n            // Multi-part tower with alternating shapes\r\n            let group = new THREE.Group();\r\n            let baseH = h * 0.35 + rng() * h * 0.15;\r\n            let midH = h * 0.3 + rng() * h * 0.1;\r\n            let topH = h * 0.18 + rng() * h * 0.1;\r\n            let w = 0.8 + rng() * 0.4;\r\n            let d = 0.8 + rng() * 0.4;\r\n            let base = new THREE.Mesh(\r\n                new THREE.BoxGeometry(w, baseH, d),\r\n                new THREE.MeshStandardMaterial({ color: 0x294c60, metalness: 0.7, roughness: 0.35 })\r\n            );\r\n            base.position.y = baseH / 2;\r\n            let mid = new THREE.Mesh(\r\n                new THREE.CylinderGeometry(w * 0.42, w * 0.56, midH, 10),\r\n                new THREE.MeshStandardMaterial({ color: 0x547a89, metalness: 0.5, roughness: 0.3 })\r\n            );\r\n            mid.position.y = baseH + midH / 2 - 0.02;\r\n            let top = new THREE.Mesh(\r\n                new THREE.CylinderGeometry(w * 0.32, w * 0.32, topH, 10),\r\n                new THREE.MeshStandardMaterial({ color: 0xabb8c3, metalness: 0.5, roughness: 0.25 })\r\n            );\r\n            top.position.y = baseH + midH + topH / 2 - 0.04;\r\n            group.add(base, mid, top);\r\n            return group;\r\n        }\r\n\r\n        function onWindowResize() {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n            controls.update();\r\n            renderer.render(scene, camera);\r\n        }\r\n\r\n        // Simple seeded PRNG\r\n        function mulberry32(a) {\r\n            return function () {\r\n                var t = a += 0x6D2B79F5;\r\n                t = Math.imul(t ^ t >>> 15, t | 1);\r\n                t ^= t + Math.imul(t ^ t >>> 7, t | 61);\r\n                return ((t ^ t >>> 14) >>> 0) / 4294967296;\r\n            }\r\n        }\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "city-gpt-4-1",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Procedural Generation",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:58.032Z",
    "model": "gpt-4.1",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, procedural generation, architecture."
  }
}
