{
  "title": "Procedural Planet - Three.js",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Procedural Planet - Three.js</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n            background: #000;\r\n        }\r\n\r\n        canvas {\r\n            display: block;\r\n        }\r\n\r\n        #info {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            color: white;\r\n            font-family: Arial, sans-serif;\r\n            background: rgba(0, 0, 0, 0.5);\r\n            padding: 10px;\r\n            border-radius: 5px;\r\n            font-size: 14px;\r\n        }\r\n\r\n        #controls {\r\n            position: absolute;\r\n            bottom: 20px;\r\n            left: 20px;\r\n            background: rgba(0, 0, 0, 0.5);\r\n            padding: 10px;\r\n            border-radius: 5px;\r\n            color: white;\r\n            font-family: Arial, sans-serif;\r\n        }\r\n\r\n        button {\r\n            margin: 0 5px;\r\n            padding: 5px 10px;\r\n            font-size: 12px;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"info\">\r\n        Procedural Planet<br />\r\n        Rotation: <span id=\"speed\">1.0</span>Ã—<br />\r\n        Use mouse to rotate, scroll to zoom\r\n    </div>\r\n    <div id=\"controls\">\r\n        <button id=\"pause\">Pause</button>\r\n        <button id=\"speedUp\">Speed Up</button>\r\n        <button id=\"slowDown\">Slow Down</button>\r\n    </div>\r\n\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/libs/simplex-noise.js\"></script>\r\n    <script>\r\n        // === GLOBALS ===\r\n        let scene, camera, renderer, planet, atmosphere, clouds, ocean, clock;\r\n        let isPaused = false;\r\n        let rotationSpeed = 1.0;\r\n        let mouseX = 0, mouseY = 0;\r\n        let targetRotationX = 0, targetRotationY = 0;\r\n        const targetRotationSpeed = 0.01;\r\n\r\n        // === INITIALIZATION ===\r\n        function init() {\r\n            // Scene\r\n            scene = new THREE.Scene();\r\n\r\n            // Camera\r\n            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n            camera.position.z = 3.5;\r\n\r\n            // Renderer\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            renderer.setPixelRatio(window.devicePixelRatio);\r\n            document.body.appendChild(renderer.domElement);\r\n\r\n            // Clock for animation\r\n            clock = new THREE.Clock();\r\n\r\n            // Lighting\r\n            const sunLight = new THREE.DirectionalLight(0xffffff, 1);\r\n            sunLight.position.set(10, 10, 10);\r\n            scene.add(sunLight);\r\n\r\n            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);\r\n            scene.add(ambientLight);\r\n\r\n            // === Planet (Sphere with terrain) ===\r\n            const radius = 1.0;\r\n            const geometry = new THREE.SphereGeometry(radius, 64, 64);\r\n\r\n            // Add noise to vertices\r\n            const positions = geometry.attributes.position.array;\r\n            const simplex = new SimplexNoise();\r\n\r\n            const heightScale = 0.1;\r\n\r\n            for (let i = 0; i < positions.length; i += 3) {\r\n                const x = positions[i];\r\n                const y = positions[i + 1];\r\n                const z = positions[i + 2];\r\n\r\n                const lat = Math.asin(y / radius);\r\n                const lon = Math.atan2(z, x);\r\n\r\n                // Noise at multiple octaves\r\n                let noise = 0.0;\r\n                let amplitude = 1.0;\r\n                let frequency = 1.0;\r\n                for (let o = 0; o < 4; o++) {\r\n                    noise += simplex.noise3D(x * frequency, y * frequency, z * frequency) * amplitude;\r\n                    amplitude *= 0.5;\r\n                    frequency *= 2;\r\n                }\r\n\r\n                // Scale noise to height\r\n                const offset = noise * heightScale;\r\n                positions[i] += x * offset;\r\n                positions[i + 1] += y * offset;\r\n                positions[i + 2] += z * offset;\r\n            }\r\n\r\n            geometry.attributes.position.needsUpdate = true;\r\n            geometry.computeVertexNormals();\r\n\r\n            // Biome-based material\r\n            const material = new THREE.MeshStandardMaterial({\r\n                color: 0x448822,\r\n                roughness: 0.8,\r\n                metalness: 0.2,\r\n                flatShading: false\r\n            });\r\n\r\n            planet = new THREE.Mesh(geometry, material);\r\n            scene.add(planet);\r\n\r\n            // === Ocean ===\r\n            const oceanGeometry = new THREE.SphereGeometry(radius - 0.005, 64, 64);\r\n            const oceanMaterial = new THREE.MeshStandardMaterial({\r\n                color: 0x004499,\r\n                transparent: true,\r\n                opacity: 0.8,\r\n                roughness: 0.5,\r\n                metalness: 0.1,\r\n                side: THREE.DoubleSide\r\n            });\r\n            ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);\r\n            scene.add(ocean);\r\n\r\n            // === Atmosphere ===\r\n            const atmosphereGeometry = new THREE.SphereGeometry(radius + 0.05, 64, 64);\r\n            const atmosphereMaterial = new THREE.ShaderMaterial({\r\n                uniforms: {\r\n                    color: { value: new THREE.Color(0x004499) },\r\n                    radius: { value: radius + 0.05 },\r\n                    glow: { value: 0.5 },\r\n                    time: { value: 0 }\r\n                },\r\n                vertexShader: `\r\n          varying vec3 vNormal;\r\n          void main() {\r\n            vNormal = normalize(normalMatrix * normal);\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n          }\r\n        `,\r\n                fragmentShader: `\r\n          uniform vec3 color;\r\n          uniform float radius;\r\n          uniform float time;\r\n          varying vec3 vNormal;\r\n\r\n          void main() {\r\n            float intensity = pow(0.9 - dot(vNormal, vec3(0, 0, 1)), 2.0);\r\n            float atmosphere = 1.0 - smoothstep(0.0, 1.0, length(vNormal));\r\n            float fade = 1.0 - pow(1.0 - distance(gl_FragCoord.xy, vec2(0.5)), 0.5);\r\n            float glow = 0.5 + 0.5 * cos(time * 0.5 + 0.5);\r\n            float alpha = intensity * 0.8 + glow * 0.2;\r\n            gl_FragColor = vec4(color * 0.7, alpha);\r\n          }\r\n        `,\r\n                transparent: true,\r\n                depthWrite: false\r\n            });\r\n            const atmosphereMesh = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);\r\n            scene.add(atmosphereMesh);\r\n\r\n            // === Clouds ===\r\n            const cloudGeometry = new THREE.SphereGeometry(radius + 0.03, 64, 64);\r\n            const cloudMaterial = new THREE.ShaderMaterial({\r\n                uniforms: {\r\n                    time: { value: 0 },\r\n                    scale: { value: 2.0 },\r\n                    opacity: { value: 0.4 }\r\n                },\r\n                vertexShader: `\r\n          varying vec3 vNormal;\r\n          void main() {\r\n            vNormal = normalize(normalMatrix * normal);\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n          }\r\n        `,\r\n                fragmentShader: `\r\n          uniform float time;\r\n          uniform float scale;\r\n          uniform float opacity;\r\n          varying vec3 vNormal;\r\n\r\n          float noise(vec3 p) {\r\n            return fract(sin(dot(p, vec3(12.9898, 78.233, 45.169)))* 43758.5453);\r\n          }\r\n\r\n          void main() {\r\n            vec3 p = vec3(vNormal * 1.2);\r\n            float noise = noise(p + time * 0.1) * 0.5 + 0.5;\r\n            float cloud = smoothstep(0.4, 1.0, noise);\r\n            cloud *= smoothstep(0.0, 0.5, length(vNormal));\r\n            gl_FragColor = vec4(1.0, 1.0, 1.0, cloud * opacity);\r\n          }\r\n        `,\r\n                transparent: true,\r\n                blending: THREE.AdditiveBlending\r\n            });\r\n\r\n            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);\r\n            scene.add(clouds);\r\n\r\n            // === BIOME SYSTEM (Apply textures) ===\r\n            const textureLoader = new THREE.TextureLoader();\r\n\r\n            // Load base textures (you can replace with real textures)\r\n            const textures = {\r\n                ocean: textureLoader.load('https://threejs.org/examples/textures/planets/earth_ocean_2048.jpg'),\r\n                desert: textureLoader.load('https://threejs.org/examples/textures/planets/earth_desert_2048.jpg'),\r\n                forest: textureLoader.load('https://threejs.org/examples/textures/planets/earth_forest_2048.jpg'),\r\n                tundra: textureLoader.load('https://threejs.org/examples/textures/planets/earth_tundra_2048.jpg')\r\n            };\r\n\r\n            // Set up blend map and biome mapping\r\n            const blendMap = new THREE.CanvasTexture(createBlendMap());\r\n            blendMap.wrapS = THREE.RepeatWrapping;\r\n            blendMap.wrapT = THREE.RepeatWrapping;\r\n\r\n            const biomeMaterial = new THREE.MeshStandardMaterial({\r\n                map: textures.ocean,\r\n                normalMap: textureLoader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg'),\r\n                bumpMap: textureLoader.load('https://threejs.org/examples/textures/planets/earth_bump_2048.jpg'),\r\n                bumpScale: 0.02,\r\n                roughnessMap: textureLoader.load('https://threejs.org/examples/textures/planets/earth_roughness_2048.jpg'),\r\n                metalness: 0.0\r\n            });\r\n\r\n            // Update material based on biome (via shader or dynamic map)\r\n            // We'll use a simple approach: update map based on height & lat\r\n            const biomeShader = new THREE.ShaderMaterial({\r\n                uniforms: {\r\n                    oceanMap: { value: textures.ocean },\r\n                    desertMap: { value: textures.desert },\r\n                    forestMap: { value: textures.forest },\r\n                    tundraMap: { value: textures.tundra },\r\n                    blendMap: { value: blendMap },\r\n                    time: { value: 0 }\r\n                },\r\n                vertexShader: `\r\n          varying vec3 vNormal;\r\n          varying vec2 vUv;\r\n          void main() {\r\n            vNormal = normalize(normalMatrix * normal);\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n          }\r\n        `,\r\n                fragmentShader: `\r\n          uniform sampler2D oceanMap;\r\n          uniform sampler2D desertMap;\r\n          uniform sampler2D forestMap;\r\n          uniform sampler2D tundraMap;\r\n          uniform sampler2D blendMap;\r\n          uniform float time;\r\n          varying vec3 vNormal;\r\n          varying vec2 vUv;\r\n\r\n          void main() {\r\n            float lat = 0.5 - vNormal.y * 0.5;\r\n            float height = (vNormal.y + 1.0) * 0.5;\r\n\r\n            vec4 blend = texture2D(blendMap, vUv);\r\n            vec4 color = texture2D(oceanMap, vUv) * blend.r;\r\n            color += texture2D(desertMap, vUv) * blend.g;\r\n            color += texture2D(forestMap, vUv) * blend.b;\r\n            color += texture2D(tundraMap, vUv) * blend.a;\r\n\r\n            gl_FragColor = color;\r\n          }\r\n        `,\r\n                side: THREE.DoubleSide\r\n            });\r\n\r\n            // Replace planet material\r\n            planet.material = biomeShader;\r\n\r\n            // === CAMERA CONTROLS ===\r\n            const controls = {\r\n                target: new THREE.Vector3(0, 0, 0),\r\n                distance: 3.5,\r\n                angleX: 0,\r\n                angleY: 0,\r\n                minDistance: 2.0,\r\n                maxDistance: 10.0\r\n            };\r\n\r\n            // Mouse events\r\n            document.addEventListener('mousemove', (e) => {\r\n                mouseX = (e.clientX - window.innerWidth / 2) / 100;\r\n                mouseY = (e.clientY - window.innerHeight / 2) / 100;\r\n            });\r\n\r\n            document.addEventListener('wheel', (e) => {\r\n                controls.distance *= 1.0 - e.deltaY * 0.001;\r\n                controls.distance = Math.max(controls.minDistance, Math.min(controls.maxDistance, controls.distance));\r\n            });\r\n\r\n            // Buttons\r\n            document.getElementById('pause').addEventListener('click', () => {\r\n                isPaused = !isPaused;\r\n                document.getElementById('pause').textContent = isPaused ? 'Resume' : 'Pause';\r\n            });\r\n\r\n            document.getElementById('speedUp').addEventListener('click', () => {\r\n                rotationSpeed *= 1.5;\r\n                document.getElementById('speed').textContent = rotationSpeed.toFixed(1);\r\n            });\r\n\r\n            document.getElementById('slowDown').addEventListener('click', () => {\r\n                rotationSpeed *= 0.7;\r\n                document.getElementById('speed').textContent = rotationSpeed.toFixed(1);\r\n            });\r\n\r\n            // Resize handler\r\n            window.addEventListener('resize', () => {\r\n                camera.aspect = window.innerWidth / window.innerHeight;\r\n                camera.updateProjectionMatrix();\r\n                renderer.setSize(window.innerWidth, window.innerHeight);\r\n            });\r\n\r\n            // Start animation loop\r\n            animate();\r\n        }\r\n\r\n        // === CREATE BLEND MAP ===\r\n        function createBlendMap() {\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = 256;\r\n            canvas.height = 128;\r\n            const ctx = canvas.getContext('2d');\r\n            const imageData = ctx.createImageData(canvas.width, canvas.height);\r\n\r\n            for (let y = 0; y < canvas.height; y++) {\r\n                for (let x = 0; x < canvas.width; x++) {\r\n                    const lat = (y / canvas.height) * Math.PI - Math.PI / 2;\r\n                    const lon = (x / canvas.width) * 2 * Math.PI;\r\n\r\n                    const height = Math.sin(lat) * 0.5 + 0.5; // 0 = poles, 1 = equator\r\n                    const ocean = height < 0.3 ? 1.0 : 0.0;\r\n                    const desert = height > 0.4 && height < 0.6 ? 1.0 : 0.0;\r\n                    const forest = height > 0.5 && height < 0.8 ? 1.0 : 0.0;\r\n                    const tundra = height > 0.7 ? 1.0 : 0.0;\r\n\r\n                    const r = ocean;\r\n                    const g = desert;\r\n                    const b = forest;\r\n                    const a = tundra;\r\n\r\n                    const i = (y * canvas.width + x) * 4;\r\n                    imageData.data[i] = Math.floor(r * 255);\r\n                    imageData.data[i + 1] = Math.floor(g * 255);\r\n                    imageData.data[i + 2] = Math.floor(b * 255);\r\n                    imageData.data[i + 3] = Math.floor(a * 255);\r\n                }\r\n            }\r\n\r\n            ctx.putImageData(imageData, 0, 0);\r\n            return canvas;\r\n        }\r\n\r\n        // === ANIMATION LOOP ===\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n\r\n            const delta = clock.getDelta();\r\n            const time = clock.getElapsedTime();\r\n\r\n            if (!isPaused) {\r\n                planet.rotation.y += rotationSpeed * delta;\r\n                clouds.rotation.y += rotationSpeed * 0.7 * delta;\r\n                atmosphere.material.uniforms.time.value = time;\r\n                clouds.material.uniforms.time.value = time;\r\n            }\r\n\r\n            // Smooth camera controls\r\n            targetRotationX += (mouseY - targetRotationX) * targetRotationSpeed;\r\n            targetRotationY += (mouseX - targetRotationY) * targetRotationSpeed;\r\n\r\n            camera.position.x = Math.sin(targetRotationY) * controls.distance;\r\n            camera.position.y = Math.sin(targetRotationX) * controls.distance;\r\n            camera.position.z = Math.cos(targetRotationY) * controls.distance;\r\n\r\n            camera.lookAt(controls.target);\r\n\r\n            // Update UI\r\n            document.getElementById('speed').textContent = rotationSpeed.toFixed(1);\r\n\r\n            renderer.render(scene, camera);\r\n        }\r\n\r\n        // Initialize\r\n        init();\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "procedual-planet-qwen3-30b-a3b",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Procedural Generation",
      "Astronomy",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:58.126Z",
    "model": "qwen3-30b-a3b",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, procedural generation, astronomy, architecture."
  }
}
