{
  "title": "3D Bin Packing Visualization (Step-by-Step)",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>3D Bin Packing Visualization (Step-by-Step)</title>\r\n    <style>\r\n        /* Basic styling for the page */\r\n        body {\r\n            margin: 0;\r\n            font-family: 'Inter', sans-serif;\r\n            /* Using Inter font */\r\n            background-color: #f0f0f0;\r\n            /* Light gray background */\r\n            color: #333;\r\n            overflow: hidden;\r\n            /* Prevent scrollbars */\r\n        }\r\n\r\n        canvas {\r\n            display: block;\r\n            /* Remove extra space below canvas */\r\n            width: 100%;\r\n            /* Make canvas responsive */\r\n            height: 100%;\r\n        }\r\n\r\n        /* Style for the info overlay */\r\n        #info {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            padding: 10px 15px;\r\n            background-color: rgba(255, 255, 255, 0.85);\r\n            border-radius: 8px;\r\n            font-size: 0.9em;\r\n            max-width: 300px;\r\n            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\r\n            z-index: 10;\r\n            /* Ensure it's above the canvas */\r\n        }\r\n\r\n        /* Style for buttons */\r\n        #controls {\r\n            position: absolute;\r\n            bottom: 20px;\r\n            left: 50%;\r\n            transform: translateX(-50%);\r\n            z-index: 10;\r\n            display: flex;\r\n            gap: 10px;\r\n        }\r\n\r\n        button {\r\n            padding: 10px 20px;\r\n            font-size: 1em;\r\n            font-family: 'Inter', sans-serif;\r\n            border: none;\r\n            border-radius: 8px;\r\n            background-color: #4a90e2;\r\n            /* Blue */\r\n            color: white;\r\n            cursor: pointer;\r\n            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\r\n            transition: background-color 0.2s ease;\r\n        }\r\n\r\n        button:hover {\r\n            background-color: #357abd;\r\n            /* Darker blue */\r\n        }\r\n\r\n        button:disabled {\r\n            background-color: #cccccc;\r\n            cursor: not-allowed;\r\n        }\r\n\r\n        #resetButton {\r\n            background-color: #d9534f;\r\n            /* Red */\r\n        }\r\n\r\n        #resetButton:hover {\r\n            background-color: #c9302c;\r\n            /* Darker red */\r\n        }\r\n    </style>\r\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\r\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\r\n    <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap\" rel=\"stylesheet\">\r\n</head>\r\n\r\n<body>\r\n    <div id=\"info\">\r\n        <strong>3D Bin Packing Visualization</strong><br>\r\n        Drag to rotate, scroll to zoom.<br>\r\n        <span id=\"status\">Status: Ready</span>\r\n    </div>\r\n\r\n    <div id=\"controls\">\r\n        <button id=\"startButton\">Start Packing</button>\r\n        <button id=\"resetButton\">Reset</button>\r\n    </div>\r\n\r\n\r\n    <script type=\"importmap\">\r\n        {\r\n            \"imports\": {\r\n                \"three\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js\",\r\n                \"three/addons/\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/\"\r\n            }\r\n        }\r\n    </script>\r\n\r\n    <script type=\"module\">\r\n        // Import necessary Three.js components\r\n        import * as THREE from 'three';\r\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\n\r\n        // --- Global Variables ---\r\n        let scene, camera, renderer, controls;\r\n        let binMesh; // Reference to the bin wireframe\r\n        const pieceMeshes = new THREE.Group(); // Group to hold all piece meshes\r\n        const cornerMeshes = new THREE.Group(); // Group to hold corner visualizations\r\n        let theBin; // The bin object\r\n        let allPieces = []; // The initial list of all pieces\r\n        let remainingPieces = []; // Pieces yet to be packed in the current run\r\n        let packingTimeoutId = null; // To control the step-by-step timeout\r\n        const packingDelay = 300; // Delay between steps in milliseconds\r\n\r\n        const statusElement = document.getElementById('status');\r\n        const startButton = document.getElementById('startButton');\r\n        const resetButton = document.getElementById('resetButton');\r\n\r\n        // --- 1. Data Structures (Identical to previous version) ---\r\n        class Piece {\r\n            constructor(id, width, height, depth, value = 0) {\r\n                this.id = id;\r\n                this.width = width;\r\n                this.height = height;\r\n                this.depth = depth;\r\n                this.value = value;\r\n                this.volume = width * height * depth;\r\n                this.position = null;\r\n                this.orientation = 0;\r\n                this.isPlaced = false;\r\n                // Store original dimensions for reset\r\n                this.originalWidth = width;\r\n                this.originalHeight = height;\r\n                this.originalDepth = depth;\r\n            }\r\n            // Reset piece state\r\n            reset() {\r\n                this.position = null;\r\n                this.orientation = 0;\r\n                this.isPlaced = false;\r\n                this.width = this.originalWidth;\r\n                this.height = this.originalHeight;\r\n                this.depth = this.originalDepth;\r\n            }\r\n        }\r\n        class Corner {\r\n            constructor(x, y, z) {\r\n                this.x = x;\r\n                this.y = y;\r\n                this.z = z;\r\n            }\r\n        }\r\n        class Bin {\r\n            constructor(width, height, depth) {\r\n                this.width = width;\r\n                this.height = height;\r\n                this.depth = depth;\r\n                this.volume = width * height * depth;\r\n                this.placedPieces = [];\r\n                this.corners = [new Corner(0, 0, 0)];\r\n                this.epsilon = 0.0001;\r\n            }\r\n            reset() {\r\n                this.placedPieces = [];\r\n                this.corners = [new Corner(0, 0, 0)];\r\n            }\r\n            // --- Methods: checkPlacement, boxesOverlap, placePiece, addCornerIfNotExists, getOrientationDims ---\r\n            // (These methods remain identical to the previous version)\r\n            checkPlacement(piece, corner, orientation) {\r\n                const dims = this.getOrientationDims(piece, orientation);\r\n                if (corner.x + dims.w > this.width + this.epsilon ||\r\n                    corner.y + dims.h > this.height + this.epsilon ||\r\n                    corner.z + dims.d > this.depth + this.epsilon) {\r\n                    return false;\r\n                }\r\n                const pieceBox = new THREE.Box3(\r\n                    new THREE.Vector3(corner.x, corner.y, corner.z),\r\n                    new THREE.Vector3(corner.x + dims.w, corner.y + dims.h, corner.z + dims.d)\r\n                );\r\n                for (const placed of this.placedPieces) {\r\n                    const placedDims = this.getOrientationDims(placed, placed.orientation);\r\n                    const placedBox = new THREE.Box3(\r\n                        new THREE.Vector3(placed.position.x, placed.position.y, placed.position.z),\r\n                        new THREE.Vector3(placed.position.x + placedDims.w, placed.position.y + placedDims.h, placed.position.z + placedDims.d)\r\n                    );\r\n                    if (pieceBox.intersectsBox(placedBox)) {\r\n                        if (this.boxesOverlap(pieceBox, placedBox)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            boxesOverlap(box1, box2) {\r\n                const overlapX = box1.max.x > box2.min.x + this.epsilon && box1.min.x < box2.max.x - this.epsilon;\r\n                const overlapY = box1.max.y > box2.min.y + this.epsilon && box1.min.y < box2.max.y - this.epsilon;\r\n                const overlapZ = box1.max.z > box2.min.z + this.epsilon && box1.min.z < box2.max.z - this.epsilon;\r\n                return overlapX && overlapY && overlapZ;\r\n            }\r\n            placePiece(piece, corner, orientation) {\r\n                const dims = this.getOrientationDims(piece, orientation);\r\n                piece.position = { x: corner.x, y: corner.y, z: corner.z };\r\n                piece.orientation = orientation;\r\n                piece.isPlaced = true;\r\n                this.placedPieces.push(piece);\r\n                this.corners = this.corners.filter(c =>\r\n                    !(Math.abs(c.x - corner.x) < this.epsilon &&\r\n                        Math.abs(c.y - corner.y) < this.epsilon &&\r\n                        Math.abs(c.z - corner.z) < this.epsilon)\r\n                );\r\n                const cornerX = new Corner(corner.x + dims.w, corner.y, corner.z);\r\n                const cornerY = new Corner(corner.x, corner.y + dims.h, corner.z);\r\n                const cornerZ = new Corner(corner.x, corner.y, corner.z + dims.d);\r\n                if (cornerX.x < this.width - this.epsilon) this.addCornerIfNotExists(cornerX);\r\n                if (cornerY.y < this.height - this.epsilon) this.addCornerIfNotExists(cornerY);\r\n                if (cornerZ.z < this.depth - this.epsilon) this.addCornerIfNotExists(cornerZ);\r\n                this.corners = this.corners.filter(c => {\r\n                    const pieceBox = new THREE.Box3(\r\n                        new THREE.Vector3(corner.x, corner.y, corner.z),\r\n                        new THREE.Vector3(corner.x + dims.w, corner.y + dims.h, corner.z + dims.d)\r\n                    );\r\n                    const point = new THREE.Vector3(c.x, c.y, c.z);\r\n                    const isInside = point.x > pieceBox.min.x + this.epsilon && point.x < pieceBox.max.x - this.epsilon &&\r\n                        point.y > pieceBox.min.y + this.epsilon && point.y < pieceBox.max.y - this.epsilon &&\r\n                        point.z > pieceBox.min.z + this.epsilon && point.z < pieceBox.max.z - this.epsilon;\r\n                    return !isInside;\r\n                });\r\n            }\r\n            addCornerIfNotExists(newCorner) {\r\n                const exists = this.corners.some(c =>\r\n                    Math.abs(c.x - newCorner.x) < this.epsilon &&\r\n                    Math.abs(c.y - newCorner.y) < this.epsilon &&\r\n                    Math.abs(c.z - newCorner.z) < this.epsilon\r\n                );\r\n                if (!exists) {\r\n                    this.corners.push(newCorner);\r\n                }\r\n            }\r\n            getOrientationDims(piece, orientation) {\r\n                switch (orientation) {\r\n                    case 0: return { w: piece.width, h: piece.height, d: piece.depth };\r\n                    case 1: return { w: piece.height, h: piece.width, d: piece.depth };\r\n                    case 2: return { w: piece.width, h: piece.depth, d: piece.height };\r\n                    case 3: return { w: piece.depth, h: piece.width, d: piece.height };\r\n                    case 4: return { w: piece.height, h: piece.depth, d: piece.width };\r\n                    case 5: return { w: piece.depth, h: piece.height, d: piece.width };\r\n                    default: return { w: piece.width, h: piece.height, d: piece.depth };\r\n                }\r\n            }\r\n        }\r\n\r\n        // --- 2. Packing Algorithm (Step-by-Step Logic) ---\r\n\r\n        /**\r\n         * Finds the next valid placement based on the current heuristic.\r\n         * @param {Bin} bin - The bin object.\r\n         * @param {Piece[]} currentRemainingPieces - Array of pieces still to be placed.\r\n         * @returns {object|null} - An object { piece, corner, orientation, pieceIndex } or null if no placement found.\r\n         */\r\n        function findNextPlacement(bin, currentRemainingPieces) {\r\n            // Sort corners by position (e.g., bottom-left-back first approach)\r\n            bin.corners.sort((a, b) => {\r\n                if (Math.abs(a.z - b.z) > bin.epsilon) return a.z - b.z; // Z first\r\n                if (Math.abs(a.y - b.y) > bin.epsilon) return a.y - b.y; // Then Y\r\n                return a.x - b.x; // Then X\r\n            });\r\n\r\n            // Iterate through remaining pieces (sorted by volume desc in initial setup)\r\n            for (let i = 0; i < currentRemainingPieces.length; i++) {\r\n                const piece = currentRemainingPieces[i];\r\n\r\n                // Try placing this piece at each available corner\r\n                for (const corner of bin.corners) {\r\n                    // Try all 6 possible orientations\r\n                    for (let orientation = 0; orientation < 6; orientation++) {\r\n                        // Check if this placement is valid\r\n                        if (bin.checkPlacement(piece, corner, orientation)) {\r\n                            // If valid, return the placement details\r\n                            return { piece, corner, orientation, pieceIndex: i };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // If no valid placement found after checking all pieces/corners/orientations\r\n            return null;\r\n        }\r\n\r\n        /**\r\n         * Executes one step of the packing process. Finds and performs one placement.\r\n         */\r\n        function packStep() {\r\n            if (remainingPieces.length === 0) {\r\n                statusElement.textContent = \"Status: Packing Complete (All pieces placed).\";\r\n                console.log(\"Packing Complete: All pieces placed.\");\r\n                startButton.disabled = false;\r\n                return;\r\n            }\r\n\r\n            // Find the next placement based on the heuristic\r\n            const placement = findNextPlacement(theBin, remainingPieces);\r\n\r\n            if (placement) {\r\n                // Placement found: Place the piece\r\n                const { piece, corner, orientation, pieceIndex } = placement;\r\n                theBin.placePiece(piece, corner, orientation);\r\n\r\n                // Remove the placed piece from the remaining list\r\n                remainingPieces.splice(pieceIndex, 1);\r\n\r\n                statusElement.textContent = `Status: Placed Piece ${piece.id}. Remaining: ${remainingPieces.length}`;\r\n                console.log(`Placed Piece ${piece.id} (Vol: ${piece.volume}) at (${corner.x.toFixed(2)}, ${corner.y.toFixed(2)}, ${corner.z.toFixed(2)}) orientation ${orientation}. Remaining: ${remainingPieces.length}`);\r\n\r\n                // Update visualization\r\n                visualizePacking(theBin.placedPieces, theBin);\r\n                visualizeCorners(theBin.corners);\r\n\r\n                // Schedule the next step\r\n                packingTimeoutId = setTimeout(packStep, packingDelay);\r\n            } else {\r\n                // No placement found for any remaining piece\r\n                statusElement.textContent = `Status: Packing Complete (Cannot place remaining ${remainingPieces.length} pieces).`;\r\n                console.log(`Packing Complete: No valid placement found for remaining ${remainingPieces.length} pieces.`);\r\n                startButton.disabled = false;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Initiates the step-by-step packing process.\r\n         */\r\n        function startPackingProcess() {\r\n            if (packingTimeoutId) {\r\n                clearTimeout(packingTimeoutId); // Clear previous timeout if any\r\n            }\r\n            resetPacking(); // Ensure a clean state before starting\r\n            startButton.disabled = true; // Disable button while packing\r\n\r\n            // Initial sort of pieces (largest volume first)\r\n            remainingPieces = [...allPieces]; // Get a fresh copy\r\n            remainingPieces.sort((a, b) => b.volume - a.volume);\r\n\r\n            statusElement.textContent = \"Status: Packing Started...\";\r\n            console.log(\"Packing Started...\");\r\n\r\n            // Start the first step\r\n            packingTimeoutId = setTimeout(packStep, packingDelay);\r\n        }\r\n\r\n        /**\r\n        * Resets the packing state and visualization.\r\n        */\r\n        function resetPacking() {\r\n            if (packingTimeoutId) {\r\n                clearTimeout(packingTimeoutId);\r\n                packingTimeoutId = null;\r\n            }\r\n            // Reset bin state\r\n            theBin.reset();\r\n            // Reset all piece states\r\n            allPieces.forEach(p => p.reset());\r\n            remainingPieces = [];\r\n\r\n            // Clear visualization\r\n            pieceMeshes.clear();\r\n            cornerMeshes.clear();\r\n\r\n            // Visualize initial state (empty bin, starting corner)\r\n            visualizeCorners(theBin.corners);\r\n\r\n            statusElement.textContent = \"Status: Ready\";\r\n            startButton.disabled = false;\r\n            console.log(\"Packing Reset.\");\r\n\r\n        }\r\n\r\n\r\n        // --- 3. Three.js Visualization Setup ---\r\n\r\n        /**\r\n         * Initializes the Three.js scene, camera, renderer, controls, and lighting.\r\n         */\r\n        function initVisualization() {\r\n            scene = new THREE.Scene();\r\n            scene.background = new THREE.Color(0xf0f0f0);\r\n            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n            renderer.setPixelRatio(window.devicePixelRatio);\r\n            document.body.appendChild(renderer.domElement);\r\n\r\n            const ambientLight = new THREE.AmbientLight(0x606060, 1.5);\r\n            scene.add(ambientLight);\r\n            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);\r\n            directionalLight1.position.set(1, 0.75, 0.5).normalize();\r\n            scene.add(directionalLight1);\r\n            const directionalLight2 = new THREE.DirectionalLight(0xaaaaaa, 0.8);\r\n            directionalLight2.position.set(-1, -0.75, -0.5).normalize();\r\n            scene.add(directionalLight2);\r\n\r\n            controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.1;\r\n\r\n            const axesHelper = new THREE.AxesHelper(Math.max(theBin.width, theBin.height, theBin.depth) * 1.2);\r\n            scene.add(axesHelper);\r\n\r\n            const binGeometry = new THREE.BoxGeometry(theBin.width, theBin.height, theBin.depth);\r\n            const binEdges = new THREE.EdgesGeometry(binGeometry);\r\n            binMesh = new THREE.LineSegments(binEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));\r\n            binMesh.position.set(theBin.width / 2, theBin.height / 2, theBin.depth / 2);\r\n            scene.add(binMesh);\r\n\r\n            // Add groups for pieces and corners to the scene\r\n            scene.add(pieceMeshes);\r\n            scene.add(cornerMeshes);\r\n\r\n            // Set initial camera position and target\r\n            camera.position.set(theBin.width * 1.2, theBin.height * 1.5, theBin.depth * 1.8);\r\n            controls.target.set(theBin.width / 2, theBin.height / 2, theBin.depth / 2);\r\n            controls.update();\r\n\r\n            window.addEventListener('resize', onWindowResize, false);\r\n            animate();\r\n\r\n            // Visualize the initial state (empty bin, starting corner)\r\n            resetPacking(); // Use reset to set initial state\r\n\r\n            console.log(\"Three.js visualization initialized.\");\r\n        }\r\n\r\n        /**\r\n         * Updates the visualization to show the currently placed pieces.\r\n         * @param {Piece[]} packedPieces - Array of placed Piece objects.\r\n         * @param {Bin} bin - The Bin object (needed for getOrientationDims).\r\n         */\r\n        function visualizePacking(packedPieces, bin) {\r\n            pieceMeshes.clear(); // Clear only piece meshes\r\n            packedPieces.forEach(piece => {\r\n                const dims = bin.getOrientationDims(piece, piece.orientation);\r\n                const geometry = new THREE.BoxGeometry(dims.w, dims.h, dims.d);\r\n                const material = new THREE.MeshLambertMaterial({\r\n                    color: new THREE.Color(Math.random() * 0xffffff), // Keep random color generation simple\r\n                    transparent: true,\r\n                    opacity: 0.9\r\n                });\r\n                const cube = new THREE.Mesh(geometry, material);\r\n                cube.position.set(\r\n                    piece.position.x + dims.w / 2,\r\n                    piece.position.y + dims.h / 2,\r\n                    piece.position.z + dims.d / 2\r\n                );\r\n                pieceMeshes.add(cube);\r\n                const edges = new THREE.EdgesGeometry(geometry);\r\n                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.6 }));\r\n                line.position.copy(cube.position);\r\n                pieceMeshes.add(line);\r\n            });\r\n            // console.log(\"Piece visualization updated.\"); // Less verbose logging\r\n        }\r\n\r\n        /**\r\n         * Visualizes the available corner points as small spheres.\r\n         * @param {Corner[]} corners - Array of Corner objects to visualize.\r\n         */\r\n        function visualizeCorners(corners) {\r\n            cornerMeshes.clear(); // Clear previous corner meshes\r\n            const cornerGeometry = new THREE.SphereGeometry(0.1, 8, 8); // Small sphere\r\n            const cornerMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Blue color\r\n\r\n            corners.forEach(corner => {\r\n                const sphere = new THREE.Mesh(cornerGeometry, cornerMaterial);\r\n                sphere.position.set(corner.x, corner.y, corner.z);\r\n                cornerMeshes.add(sphere);\r\n            });\r\n            // console.log(\"Corner visualization updated.\"); // Less verbose logging\r\n        }\r\n\r\n\r\n        /** Handles window resize events. */\r\n        function onWindowResize() {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n\r\n        /** The main animation loop. */\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n            controls.update(); // Update controls for damping\r\n            renderer.render(scene, camera);\r\n        }\r\n\r\n        // --- 4. Initialization and Event Listeners ---\r\n\r\n        // Define the dimensions of the bin\r\n        const binDimensions = { width: 10, height: 10, depth: 10 };\r\n        // Create the Bin object\r\n        theBin = new Bin(binDimensions.width, binDimensions.height, binDimensions.depth);\r\n\r\n        // Define the initial list of all pieces\r\n        allPieces = [\r\n            new Piece(1, 4, 4, 4), new Piece(2, 3, 3, 3), new Piece(3, 5, 2, 2),\r\n            new Piece(4, 2, 5, 2), new Piece(5, 2, 2, 5), new Piece(6, 6, 1, 1),\r\n            new Piece(7, 1, 6, 1), new Piece(8, 1, 1, 6), new Piece(9, 3, 4, 5),\r\n            new Piece(10, 5, 3, 4), new Piece(11, 4, 5, 3), new Piece(12, 2, 2, 2),\r\n            new Piece(13, 2, 2, 2), new Piece(14, 1, 1, 1), new Piece(15, 1, 1, 1),\r\n            new Piece(16, 1, 1, 1), new Piece(17, 3, 1, 3), new Piece(18, 1, 3, 3),\r\n            new Piece(19, 3, 3, 1), new Piece(20, 4, 2, 3),\r\n        ];\r\n\r\n        // Add event listeners for buttons\r\n        startButton.addEventListener('click', startPackingProcess);\r\n        resetButton.addEventListener('click', resetPacking);\r\n\r\n        // Initialize the Three.js visualization environment\r\n        initVisualization(); // This now also calls resetPacking for initial state\r\n\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "bin-packing-ga-1-gemini-pro-2-5",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.876Z",
    "model": "gemini-pro-2.5",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, astronomy, architecture."
  }
}
