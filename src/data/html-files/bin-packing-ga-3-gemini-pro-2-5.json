{
  "title": "3D Bin Packing Visualization (JSON Input)",
  "htmlContent": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>3D Bin Packing Visualization (JSON Input)</title>\r\n    <style>\r\n        /* Basic styling */\r\n        body {\r\n            margin: 0;\r\n            font-family: 'Inter', sans-serif;\r\n            background-color: #f0f0f0;\r\n            color: #333;\r\n            display: flex;\r\n            height: 100vh;\r\n        }\r\n\r\n        canvas {\r\n            display: block;\r\n            width: 100%;\r\n            height: 100%;\r\n        }\r\n\r\n        #controls-container {\r\n            position: absolute;\r\n            top: 10px;\r\n            left: 10px;\r\n            background-color: rgba(255, 255, 255, 0.9);\r\n            padding: 15px;\r\n            border-radius: 8px;\r\n            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\r\n            z-index: 10;\r\n            max-width: 320px;\r\n            max-height: calc(100vh - 40px);\r\n            overflow-y: auto;\r\n        }\r\n\r\n        #info {\r\n            margin-bottom: 10px;\r\n        }\r\n\r\n        #json-input-area label {\r\n            display: block;\r\n            margin-bottom: 5px;\r\n            font-weight: bold;\r\n        }\r\n\r\n        #jsonInput {\r\n            width: 100%;\r\n            min-height: 150px;\r\n            border: 1px solid #ccc;\r\n            border-radius: 4px;\r\n            padding: 5px;\r\n            font-family: monospace;\r\n            font-size: 0.85em;\r\n            box-sizing: border-box;\r\n            margin-bottom: 10px;\r\n        }\r\n\r\n        #action-buttons {\r\n            display: flex;\r\n            justify-content: space-between;\r\n            gap: 10px;\r\n            margin-top: 10px;\r\n        }\r\n\r\n        button {\r\n            padding: 10px 15px;\r\n            font-size: 0.9em;\r\n            font-family: 'Inter', sans-serif;\r\n            border: none;\r\n            border-radius: 8px;\r\n            color: white;\r\n            cursor: pointer;\r\n            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);\r\n            transition: background-color 0.2s ease;\r\n            flex-grow: 1;\r\n        }\r\n\r\n        #loadJsonButton {\r\n            background-color: #5cb85c;\r\n            /* Green */\r\n        }\r\n\r\n        #loadJsonButton:hover {\r\n            background-color: #4cae4c;\r\n        }\r\n\r\n        #startButton {\r\n            background-color: #4a90e2;\r\n            /* Blue */\r\n        }\r\n\r\n        #startButton:hover {\r\n            background-color: #357abd;\r\n        }\r\n\r\n        #resetButton {\r\n            background-color: #d9534f;\r\n            /* Red */\r\n        }\r\n\r\n        #resetButton:hover {\r\n            background-color: #c9302c;\r\n        }\r\n\r\n        button:disabled {\r\n            background-color: #cccccc;\r\n            cursor: not-allowed;\r\n        }\r\n\r\n        #status {\r\n            font-weight: bold;\r\n            margin-top: 5px;\r\n        }\r\n\r\n        #visualization-container {\r\n            flex-grow: 1;\r\n            position: relative;\r\n        }\r\n\r\n        /* Container for canvas */\r\n    </style>\r\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\r\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\r\n    <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap\" rel=\"stylesheet\">\r\n</head>\r\n\r\n<body>\r\n    <div id=\"controls-container\">\r\n        <div id=\"info\">\r\n            <strong>3D Bin Packing Visualization</strong><br>\r\n            Define bin & pieces via JSON, then load & start.\r\n        </div>\r\n        <div id=\"json-input-area\">\r\n            <label for=\"jsonInput\">Bin & Pieces (JSON):</label>\r\n            <textarea id=\"jsonInput\" spellcheck=\"false\">\r\n{\r\n  \"bin\": {\r\n    \"width\": 10,\r\n    \"height\": 10,\r\n    \"depth\": 10\r\n  },\r\n  \"pieces\": [\r\n    { \"id\": 1, \"width\": 4, \"height\": 4, \"depth\": 4 },\r\n    { \"id\": 2, \"width\": 3, \"height\": 3, \"depth\": 3 },\r\n    { \"id\": 3, \"width\": 5, \"height\": 2, \"depth\": 2 },\r\n    { \"id\": 4, \"width\": 2, \"height\": 5, \"depth\": 2 },\r\n    { \"id\": 5, \"width\": 2, \"height\": 2, \"depth\": 5 },\r\n    { \"id\": 6, \"width\": 6, \"height\": 1, \"depth\": 1 },\r\n    { \"id\": 7, \"width\": 1, \"height\": 6, \"depth\": 1 },\r\n    { \"id\": 8, \"width\": 1, \"height\": 1, \"depth\": 6 },\r\n    { \"id\": 9, \"width\": 3, \"height\": 4, \"depth\": 5 },\r\n    { \"id\": 10, \"width\": 5, \"height\": 3, \"depth\": 4 },\r\n    { \"id\": 11, \"width\": 4, \"height\": 5, \"depth\": 3 },\r\n    { \"id\": 12, \"width\": 2, \"height\": 2, \"depth\": 2 },\r\n    { \"id\": 13, \"width\": 2, \"height\": 2, \"depth\": 2 },\r\n    { \"id\": 14, \"width\": 1, \"height\": 1, \"depth\": 1 },\r\n    { \"id\": 15, \"width\": 1, \"height\": 1, \"depth\": 1 }\r\n  ]\r\n}\r\n            </textarea>\r\n        </div>\r\n        <div id=\"action-buttons\">\r\n            <button id=\"loadJsonButton\">Load Data</button>\r\n            <button id=\"startButton\" disabled>Start Packing</button>\r\n            <button id=\"resetButton\">Reset</button>\r\n        </div>\r\n        <div id=\"status\">Status: Ready. Load data first.</div>\r\n    </div>\r\n\r\n    <div id=\"visualization-container\">\r\n    </div>\r\n\r\n\r\n    <script type=\"importmap\">\r\n        {\r\n            \"imports\": {\r\n                \"three\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js\",\r\n                \"three/addons/\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/\"\r\n            }\r\n        }\r\n    </script>\r\n\r\n    <script type=\"module\">\r\n        import * as THREE from 'three';\r\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\n\r\n        // --- Global Variables ---\r\n        let scene, camera, renderer, controls, axesHelper;\r\n        let binMesh = null; // Initialize as null\r\n        const pieceMeshes = new THREE.Group();\r\n        const cornerMeshes = new THREE.Group();\r\n        let theBin = null; // Initialize bin as null\r\n        let allPieces = [];\r\n        let remainingPieces = [];\r\n        let packingTimeoutId = null;\r\n        const packingDelay = 100;\r\n\r\n        const statusElement = document.getElementById('status');\r\n        const startButton = document.getElementById('startButton');\r\n        const resetButton = document.getElementById('resetButton');\r\n        const loadJsonButton = document.getElementById('loadJsonButton');\r\n        const jsonInputElement = document.getElementById('jsonInput');\r\n        const visualizationContainer = document.getElementById('visualization-container');\r\n\r\n\r\n        // --- 1. Data Structures ---\r\n        // (Piece, Corner, Bin classes remain the same as previous version)\r\n        class Piece {\r\n            constructor(id, width, height, depth, value = 0) {\r\n                this.id = id;\r\n                this.width = width;\r\n                this.height = height;\r\n                this.depth = depth;\r\n                this.value = value;\r\n                this.volume = width * height * depth;\r\n                this.position = null;\r\n                this.orientation = 0;\r\n                this.isPlaced = false;\r\n                this.originalWidth = width;\r\n                this.originalHeight = height;\r\n                this.originalDepth = depth;\r\n            }\r\n            reset() {\r\n                this.position = null;\r\n                this.orientation = 0;\r\n                this.isPlaced = false;\r\n                this.width = this.originalWidth;\r\n                this.height = this.originalHeight;\r\n                this.depth = this.originalDepth;\r\n            }\r\n        }\r\n        class Corner {\r\n            constructor(x, y, z) {\r\n                this.x = x;\r\n                this.y = y;\r\n                this.z = z;\r\n            }\r\n        }\r\n        class Bin {\r\n            constructor(width, height, depth) {\r\n                // Basic validation\r\n                if (isNaN(width) || isNaN(height) || isNaN(depth) || width <= 0 || height <= 0 || depth <= 0) {\r\n                    throw new Error(\"Invalid bin dimensions. Width, height, and depth must be positive numbers.\");\r\n                }\r\n                this.width = width;\r\n                this.height = height;\r\n                this.depth = depth;\r\n                this.volume = width * height * depth;\r\n                this.placedPieces = [];\r\n                this.corners = [new Corner(0, 0, 0)];\r\n                this.epsilon = 0.0001;\r\n            }\r\n            reset() {\r\n                this.placedPieces = [];\r\n                this.corners = [new Corner(0, 0, 0)];\r\n            }\r\n            // Methods: checkPlacement, boxesOverlap, placePiece, addCornerIfNotExists, getOrientationDims (Identical)\r\n            checkPlacement(piece, corner, orientation) {\r\n                const dims = this.getOrientationDims(piece, orientation);\r\n                if (corner.x + dims.w > this.width + this.epsilon ||\r\n                    corner.y + dims.h > this.height + this.epsilon ||\r\n                    corner.z + dims.d > this.depth + this.epsilon) {\r\n                    return false;\r\n                }\r\n                const pieceBox = new THREE.Box3(\r\n                    new THREE.Vector3(corner.x, corner.y, corner.z),\r\n                    new THREE.Vector3(corner.x + dims.w, corner.y + dims.h, corner.z + dims.d)\r\n                );\r\n                for (const placed of this.placedPieces) {\r\n                    const placedDims = this.getOrientationDims(placed, placed.orientation);\r\n                    const placedBox = new THREE.Box3(\r\n                        new THREE.Vector3(placed.position.x, placed.position.y, placed.position.z),\r\n                        new THREE.Vector3(placed.position.x + placedDims.w, placed.position.y + placedDims.h, placed.position.z + placedDims.d)\r\n                    );\r\n                    if (pieceBox.intersectsBox(placedBox)) {\r\n                        if (this.boxesOverlap(pieceBox, placedBox)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            boxesOverlap(box1, box2) {\r\n                const overlapX = box1.max.x > box2.min.x + this.epsilon && box1.min.x < box2.max.x - this.epsilon;\r\n                const overlapY = box1.max.y > box2.min.y + this.epsilon && box1.min.y < box2.max.y - this.epsilon;\r\n                const overlapZ = box1.max.z > box2.min.z + this.epsilon && box1.min.z < box2.max.z - this.epsilon;\r\n                return overlapX && overlapY && overlapZ;\r\n            }\r\n            placePiece(piece, corner, orientation) {\r\n                const dims = this.getOrientationDims(piece, orientation);\r\n                piece.position = { x: corner.x, y: corner.y, z: corner.z };\r\n                piece.orientation = orientation;\r\n                piece.isPlaced = true;\r\n                this.placedPieces.push(piece);\r\n                this.corners = this.corners.filter(c =>\r\n                    !(Math.abs(c.x - corner.x) < this.epsilon &&\r\n                        Math.abs(c.y - corner.y) < this.epsilon &&\r\n                        Math.abs(c.z - corner.z) < this.epsilon)\r\n                );\r\n                const cornerX = new Corner(corner.x + dims.w, corner.y, corner.z);\r\n                const cornerY = new Corner(corner.x, corner.y + dims.h, corner.z);\r\n                const cornerZ = new Corner(corner.x, corner.y, corner.z + dims.d);\r\n                if (cornerX.x < this.width - this.epsilon) this.addCornerIfNotExists(cornerX);\r\n                if (cornerY.y < this.height - this.epsilon) this.addCornerIfNotExists(cornerY);\r\n                if (cornerZ.z < this.depth - this.epsilon) this.addCornerIfNotExists(cornerZ);\r\n                this.corners = this.corners.filter(c => {\r\n                    const pieceBox = new THREE.Box3(\r\n                        new THREE.Vector3(corner.x, corner.y, corner.z),\r\n                        new THREE.Vector3(corner.x + dims.w, corner.y + dims.h, corner.z + dims.d)\r\n                    );\r\n                    const point = new THREE.Vector3(c.x, c.y, c.z);\r\n                    const isInside = point.x > pieceBox.min.x + this.epsilon && point.x < pieceBox.max.x - this.epsilon &&\r\n                        point.y > pieceBox.min.y + this.epsilon && point.y < pieceBox.max.y - this.epsilon &&\r\n                        point.z > pieceBox.min.z + this.epsilon && point.z < pieceBox.max.z - this.epsilon;\r\n                    return !isInside;\r\n                });\r\n            }\r\n            addCornerIfNotExists(newCorner) {\r\n                const exists = this.corners.some(c =>\r\n                    Math.abs(c.x - newCorner.x) < this.epsilon &&\r\n                    Math.abs(c.y - newCorner.y) < this.epsilon &&\r\n                    Math.abs(c.z - newCorner.z) < this.epsilon\r\n                );\r\n                if (!exists) {\r\n                    this.corners.push(newCorner);\r\n                }\r\n            }\r\n            getOrientationDims(piece, orientation) {\r\n                switch (orientation) {\r\n                    case 0: return { w: piece.width, h: piece.height, d: piece.depth };\r\n                    case 1: return { w: piece.height, h: piece.width, d: piece.depth };\r\n                    case 2: return { w: piece.width, h: piece.depth, d: piece.height };\r\n                    case 3: return { w: piece.depth, h: piece.width, d: piece.height };\r\n                    case 4: return { w: piece.height, h: piece.depth, d: piece.width };\r\n                    case 5: return { w: piece.depth, h: piece.height, d: piece.width };\r\n                    default: return { w: piece.width, h: piece.height, d: piece.depth };\r\n                }\r\n            }\r\n        }\r\n\r\n        // --- 2. Packing Algorithm ---\r\n        // (evaluatePlacementHeuristic, findBestPlacement, packStep - Identical)\r\n        function evaluatePlacementHeuristic(piece, corner, dims, orientation, bin) {\r\n            let score = piece.volume * 1.0;\r\n            const positionPenalty = (corner.x + corner.y + corner.z) * 0.5;\r\n            score -= positionPenalty;\r\n            if (dims.w * dims.d > dims.w * dims.h && dims.w * dims.d > dims.h * dims.d) {\r\n                score += piece.volume * 0.1;\r\n            }\r\n            score -= corner.y * 1.0;\r\n            return score;\r\n        }\r\n        function findBestPlacement(bin, currentRemainingPieces) {\r\n            let bestPlacement = null;\r\n            let bestScore = -Infinity;\r\n            for (let i = 0; i < currentRemainingPieces.length; i++) {\r\n                const piece = currentRemainingPieces[i];\r\n                for (const corner of bin.corners) {\r\n                    for (let orientation = 0; orientation < 6; orientation++) {\r\n                        if (bin.checkPlacement(piece, corner, orientation)) {\r\n                            const dims = bin.getOrientationDims(piece, orientation);\r\n                            const currentScore = evaluatePlacementHeuristic(piece, corner, dims, orientation, bin);\r\n                            if (currentScore > bestScore) {\r\n                                bestScore = currentScore;\r\n                                bestPlacement = { piece, corner, orientation, pieceIndex: i, score: currentScore };\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return bestPlacement;\r\n        }\r\n        function packStep() {\r\n            if (!theBin || remainingPieces.length === 0) {\r\n                const message = !theBin ? \"Status: Load data first.\" : \"Status: Packing Complete (All pieces placed).\";\r\n                statusElement.textContent = message;\r\n                console.log(message);\r\n                startButton.disabled = !theBin; // Keep disabled if no bin\r\n                if (packingTimeoutId) clearTimeout(packingTimeoutId);\r\n                packingTimeoutId = null;\r\n                return;\r\n            }\r\n\r\n            const bestPlacement = findBestPlacement(theBin, remainingPieces);\r\n\r\n            if (bestPlacement) {\r\n                const { piece, corner, orientation, pieceIndex, score } = bestPlacement;\r\n                theBin.placePiece(piece, corner, orientation);\r\n                remainingPieces.splice(pieceIndex, 1);\r\n                statusElement.textContent = `Status: Placed Piece ${piece.id} (Score: ${score.toFixed(2)}). Remaining: ${remainingPieces.length}`;\r\n                visualizePacking(theBin.placedPieces, theBin);\r\n                visualizeCorners(theBin.corners);\r\n                packingTimeoutId = setTimeout(packStep, packingDelay);\r\n            } else {\r\n                statusElement.textContent = `Status: Packing Complete (Cannot place remaining ${remainingPieces.length} pieces).`;\r\n                console.log(`Packing Complete: No valid placement found for remaining ${remainingPieces.length} pieces.`);\r\n                startButton.disabled = false; // Re-enable start if needed (though reset is better)\r\n                if (packingTimeoutId) clearTimeout(packingTimeoutId);\r\n                packingTimeoutId = null;\r\n            }\r\n        }\r\n\r\n        /** Initiates the step-by-step packing process. Requires data to be loaded first. */\r\n        function startPackingProcess() {\r\n            if (!theBin || !allPieces.length) {\r\n                statusElement.textContent = \"Status: Error - Load data before starting.\";\r\n                return;\r\n            }\r\n            if (packingTimeoutId) { // Prevent multiple starts\r\n                console.log(\"Packing already in progress.\");\r\n                return;\r\n            }\r\n\r\n            // Reset state but keep loaded data\r\n            theBin.reset();\r\n            allPieces.forEach(p => p.reset());\r\n            remainingPieces = [...allPieces]; // Use the loaded pieces\r\n            pieceMeshes.clear();\r\n            cornerMeshes.clear();\r\n            visualizeCorners(theBin.corners); // Show initial corner for the loaded bin\r\n\r\n            // Sort pieces once initially (optional, heuristic might override)\r\n            remainingPieces.sort((a, b) => b.volume - a.volume);\r\n\r\n            startButton.disabled = true; // Disable start during packing\r\n            resetButton.disabled = true; // Disable reset during packing\r\n            loadJsonButton.disabled = true; // Disable load during packing\r\n\r\n            statusElement.textContent = \"Status: Packing Started...\";\r\n            console.log(\"Packing Started...\");\r\n            packingTimeoutId = setTimeout(packStep, packingDelay);\r\n        }\r\n\r\n        /** Resets the packing state and visualization completely, requires reload of data. */\r\n        function resetPacking() {\r\n            if (packingTimeoutId) {\r\n                clearTimeout(packingTimeoutId);\r\n                packingTimeoutId = null;\r\n            }\r\n            if (theBin) {\r\n                theBin.reset(); // Reset internal state if bin exists\r\n                allPieces.forEach(p => p.reset());\r\n                remainingPieces = [];\r\n                pieceMeshes.clear();\r\n                cornerMeshes.clear();\r\n                visualizeCorners(theBin.corners); // Show initial corner\r\n                statusElement.textContent = \"Status: Reset. Load data to start.\";\r\n            } else {\r\n                statusElement.textContent = \"Status: Ready. Load data first.\";\r\n            }\r\n\r\n            startButton.disabled = true; // Disable start until data loaded\r\n            resetButton.disabled = false;\r\n            loadJsonButton.disabled = false;\r\n            console.log(\"Packing Reset.\");\r\n        }\r\n\r\n        /** Loads bin and piece data from the JSON input field. */\r\n        function loadDataFromJson() {\r\n            if (packingTimeoutId) {\r\n                statusElement.textContent = \"Status: Stop packing before loading new data.\";\r\n                return;\r\n            }\r\n            let data;\r\n            try {\r\n                data = JSON.parse(jsonInputElement.value);\r\n            } catch (error) {\r\n                statusElement.textContent = `Status: Error - Invalid JSON: ${error.message}`;\r\n                console.error(\"JSON Parsing Error:\", error);\r\n                startButton.disabled = true;\r\n                return;\r\n            }\r\n\r\n            // Validate data structure\r\n            if (!data || typeof data.bin !== 'object' || !Array.isArray(data.pieces)) {\r\n                statusElement.textContent = \"Status: Error - Invalid JSON structure. Need 'bin' object and 'pieces' array.\";\r\n                startButton.disabled = true;\r\n                return;\r\n            }\r\n            if (typeof data.bin.width !== 'number' || typeof data.bin.height !== 'number' || typeof data.bin.depth !== 'number') {\r\n                statusElement.textContent = \"Status: Error - Bin dimensions (width, height, depth) must be numbers.\";\r\n                startButton.disabled = true;\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Create new Bin (this includes validation)\r\n                theBin = new Bin(data.bin.width, data.bin.height, data.bin.depth);\r\n\r\n                // Create new Pieces\r\n                allPieces = data.pieces.map((p, index) => {\r\n                    if (typeof p.width !== 'number' || typeof p.height !== 'number' || typeof p.depth !== 'number' ||\r\n                        p.width <= 0 || p.height <= 0 || p.depth <= 0) {\r\n                        throw new Error(`Invalid dimensions for piece at index ${index} (id: ${p.id || 'N/A'}). Dimensions must be positive numbers.`);\r\n                    }\r\n                    // Ensure ID is unique or generate one\r\n                    const id = p.id !== undefined ? p.id : `piece_${index + 1}`;\r\n                    return new Piece(id, p.width, p.height, p.depth, p.value || 0);\r\n                });\r\n\r\n                // Update visualization for the new bin size\r\n                updateVisualizationForNewBin();\r\n\r\n                // Reset packing state with new data\r\n                resetPacking(); // Resets bin state, clears meshes, resets pieces\r\n                statusElement.textContent = `Status: Data Loaded (${allPieces.length} pieces). Ready to Pack.`;\r\n                startButton.disabled = false; // Enable start button now\r\n                console.log(\"Data loaded successfully.\");\r\n\r\n            } catch (error) {\r\n                statusElement.textContent = `Status: Error - ${error.message}`;\r\n                console.error(\"Data Loading Error:\", error);\r\n                theBin = null; // Invalidate bin on error\r\n                allPieces = [];\r\n                startButton.disabled = true;\r\n            }\r\n        }\r\n\r\n\r\n        // --- 3. Three.js Visualization Setup ---\r\n\r\n        /** Updates the visualization elements tied to the bin size */\r\n        function updateVisualizationForNewBin() {\r\n            if (!theBin) return;\r\n\r\n            // Remove old bin mesh if it exists\r\n            if (binMesh) {\r\n                scene.remove(binMesh);\r\n                binMesh.geometry.dispose();\r\n                binMesh.material.dispose();\r\n                binMesh = null;\r\n            }\r\n\r\n            // Create new bin mesh\r\n            const binGeometry = new THREE.BoxGeometry(theBin.width, theBin.height, theBin.depth);\r\n            const binEdges = new THREE.EdgesGeometry(binGeometry);\r\n            binMesh = new THREE.LineSegments(binEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));\r\n            binMesh.position.set(theBin.width / 2, theBin.height / 2, theBin.depth / 2);\r\n            scene.add(binMesh);\r\n\r\n            // Update Axes Helper size\r\n            scene.remove(axesHelper); // Remove old one\r\n            axesHelper = new THREE.AxesHelper(Math.max(theBin.width, theBin.height, theBin.depth) * 1.2);\r\n            scene.add(axesHelper);\r\n\r\n            // Update camera position and controls target (optional, but helpful)\r\n            camera.position.set(theBin.width * 1.2, theBin.height * 1.5, theBin.depth * 1.8);\r\n            controls.target.set(theBin.width / 2, theBin.height / 2, theBin.depth / 2);\r\n            controls.update();\r\n        }\r\n\r\n\r\n        /** Initializes the base Three.js scene, camera, renderer, controls, lighting */\r\n        function initBaseVisualization() {\r\n            scene = new THREE.Scene();\r\n            scene.background = new THREE.Color(0xf0f0f0);\r\n            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n            renderer = new THREE.WebGLRenderer({ antialias: true });\r\n            renderer.setSize(visualizationContainer.clientWidth, visualizationContainer.clientHeight); // Use container size\r\n            renderer.setPixelRatio(window.devicePixelRatio);\r\n            visualizationContainer.appendChild(renderer.domElement); // Append to container\r\n\r\n            const ambientLight = new THREE.AmbientLight(0x606060, 1.5);\r\n            scene.add(ambientLight);\r\n            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);\r\n            directionalLight1.position.set(1, 0.75, 0.5).normalize();\r\n            scene.add(directionalLight1);\r\n            const directionalLight2 = new THREE.DirectionalLight(0xaaaaaa, 0.8);\r\n            directionalLight2.position.set(-1, -0.75, -0.5).normalize();\r\n            scene.add(directionalLight2);\r\n\r\n            controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.1;\r\n\r\n            // Add groups for pieces and corners to the scene\r\n            scene.add(pieceMeshes);\r\n            scene.add(cornerMeshes);\r\n\r\n            // Dummy axes helper initially, will be updated when data loads\r\n            axesHelper = new THREE.AxesHelper(10);\r\n            scene.add(axesHelper);\r\n\r\n            window.addEventListener('resize', onWindowResize, false);\r\n            animate();\r\n            console.log(\"Base Three.js visualization initialized.\");\r\n        }\r\n\r\n        // (visualizePacking, visualizeCorners - Identical)\r\n        function visualizePacking(packedPieces, bin) {\r\n            pieceMeshes.clear();\r\n            packedPieces.forEach(piece => {\r\n                const dims = bin.getOrientationDims(piece, piece.orientation);\r\n                const geometry = new THREE.BoxGeometry(dims.w, dims.h, dims.d);\r\n                const material = new THREE.MeshLambertMaterial({\r\n                    color: new THREE.Color(Math.random() * 0xffffff),\r\n                    transparent: true,\r\n                    opacity: 0.9\r\n                });\r\n                const cube = new THREE.Mesh(geometry, material);\r\n                cube.position.set(\r\n                    piece.position.x + dims.w / 2,\r\n                    piece.position.y + dims.h / 2,\r\n                    piece.position.z + dims.d / 2\r\n                );\r\n                pieceMeshes.add(cube);\r\n                const edges = new THREE.EdgesGeometry(geometry);\r\n                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.6 }));\r\n                line.position.copy(cube.position);\r\n                pieceMeshes.add(line);\r\n            });\r\n        }\r\n        function visualizeCorners(corners) {\r\n            cornerMeshes.clear();\r\n            const cornerGeometry = new THREE.SphereGeometry(0.1, 8, 8);\r\n            const cornerMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Blue\r\n\r\n            corners.forEach(corner => {\r\n                const sphere = new THREE.Mesh(cornerGeometry, cornerMaterial);\r\n                sphere.position.set(corner.x, corner.y, corner.z);\r\n                cornerMeshes.add(sphere);\r\n            });\r\n        }\r\n\r\n        /** Handles window resize events */\r\n        function onWindowResize() {\r\n            // Adjust based on the container div, not the whole window\r\n            const width = visualizationContainer.clientWidth;\r\n            const height = visualizationContainer.clientHeight;\r\n            if (width === 0 || height === 0) return; // Avoid issues if container is hidden\r\n\r\n            camera.aspect = width / height;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(width, height);\r\n        }\r\n\r\n        /** The main animation loop */\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n            controls.update();\r\n            renderer.render(scene, camera);\r\n        }\r\n\r\n        // --- 4. Initialization and Event Listeners ---\r\n\r\n        // Initialize base visualization (without data)\r\n        initBaseVisualization();\r\n\r\n        // Add event listeners for buttons\r\n        loadJsonButton.addEventListener('click', loadDataFromJson);\r\n        startButton.addEventListener('click', startPackingProcess);\r\n        resetButton.addEventListener('click', resetPacking);\r\n\r\n        // Attempt to load default data on page load\r\n        loadDataFromJson();\r\n\r\n\r\n    </script>\r\n</body>\r\n\r\n</html>",
  "id": "bin-packing-ga-3-gemini-pro-2-5",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.887Z",
    "model": "gemini-pro-2.5",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, astronomy, architecture."
  }
}
