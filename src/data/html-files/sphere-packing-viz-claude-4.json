{
  "title": "Fruit Packing Algorithms Visualization",
  "htmlContent": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Fruit Packing Algorithms Visualization</title>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            background: linear-gradient(135deg, #1a1a2e, #16213e);\n            font-family: 'Arial', sans-serif;\n            overflow: hidden;\n        }\n        \n        #container {\n            position: relative;\n            width: 100vw;\n            height: 100vh;\n        }\n        \n        #controls {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            background: rgba(0, 0, 0, 0.9);\n            padding: 20px;\n            border-radius: 15px;\n            color: white;\n            z-index: 100;\n            backdrop-filter: blur(10px);\n            border: 1px solid rgba(255, 165, 0, 0.3);\n            max-width: 350px;\n        }\n        \n        #stats {\n            position: absolute;\n            top: 20px;\n            right: 20px;\n            background: rgba(0, 0, 0, 0.9);\n            padding: 20px;\n            border-radius: 15px;\n            color: white;\n            z-index: 100;\n            backdrop-filter: blur(10px);\n            border: 1px solid rgba(255, 165, 0, 0.3);\n            min-width: 250px;\n        }\n        \n        .control-group {\n            margin-bottom: 15px;\n        }\n        \n        label {\n            display: block;\n            margin-bottom: 5px;\n            font-weight: bold;\n            color: #ffa500;\n        }\n        \n        select, input[type=\"range\"], input[type=\"number\"], button {\n            width: 100%;\n            padding: 8px;\n            border-radius: 8px;\n            border: 1px solid rgba(255, 165, 0, 0.5);\n            background: rgba(0, 0, 0, 0.8);\n            color: white;\n            font-size: 14px;\n        }\n        \n        select option {\n            background: rgba(0, 0, 0, 0.9);\n            color: white;\n            border: none;\n        }\n        \n        select optgroup {\n            background: rgba(255, 165, 0, 0.2);\n            color: #ffa500;\n            font-weight: bold;\n        }\n        \n        button {\n            background: linear-gradient(45deg, #ff8c00, #ffa500);\n            cursor: pointer;\n            font-weight: bold;\n            transition: all 0.3s ease;\n            margin-top: 10px;\n            color: #000;\n        }\n        \n        button:hover {\n            background: linear-gradient(45deg, #ffa500, #ff8c00);\n            transform: translateY(-2px);\n            box-shadow: 0 5px 15px rgba(255, 165, 0, 0.4);\n        }\n        \n        .range-display {\n            text-align: right;\n            color: #ffcc80;\n            font-size: 12px;\n        }\n        \n        .stat-row {\n            display: flex;\n            justify-content: space-between;\n            margin-bottom: 8px;\n            padding: 5px 0;\n            border-bottom: 1px solid rgba(255, 165, 0, 0.2);\n        }\n        \n        .stat-label {\n            color: #ffcc80;\n        }\n        \n        .stat-value {\n            color: #ffa500;\n            font-weight: bold;\n        }\n        \n        #loading {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            color: white;\n            font-size: 18px;\n            z-index: 200;\n            background: rgba(0, 0, 0, 0.9);\n            padding: 20px;\n            border-radius: 10px;\n            display: none;\n            border: 1px solid #ffa500;\n        }\n        \n        .algorithm-description {\n            font-size: 12px;\n            color: #ffcc80;\n            font-style: italic;\n            margin-top: 5px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"container\">\n        <div id=\"controls\">\n            <h3 style=\"margin-top: 0; color: #ffa500;\">📦 Product Packing Algorithms</h3>\n            \n            <div class=\"control-group\">\n                <label for=\"algorithm\">Packing Strategy:</label>\n                <select id=\"algorithm\">\n                    <option value=\"layered_hexagonal\">Layered Hexagonal (Spheres)</option>\n                    <option value=\"layered_square\">Layered Square Grid</option>\n                    <option value=\"pyramid_stacking\">Pyramid Stacking (Spheres)</option>\n                    <option value=\"offset_layers\">Offset Layer Stacking</option>\n                    <option value=\"tight_hexagonal\">Tight Hexagonal (Spheres)</option>\n                    <option value=\"brick_pattern\">Brick Pattern Layers</option>\n                    <option value=\"tetrahedral\">Tetrahedral (Spheres)</option>\n                    <option value=\"corner_fill\">Corner-Fill Strategy</option>\n                    <option value=\"dense_random\">Dense Random Fill</option>\n                    <option value=\"oval_nested\">Oval Nested Layers</option>\n                    <option value=\"oval_aligned\">Oval Aligned Rows</option>\n                    <option value=\"oval_egg_crate\">Egg Crate Pattern</option>\n                    <option value=\"oval_honeycomb\">Oval Honeycomb</option>\n                </select>\n                <div class=\"algorithm-description\" id=\"algorithmDesc\">\n                    Industry standard for optimal space utilization\n                </div>\n            </div>\n            \n            <div class=\"control-group\">\n                <label for=\"productType\">Product Type:</label>\n                <select id=\"productType\">\n                    <optgroup label=\"Spherical Fruits\">\n                        <option value=\"orange\">Orange (7cm diameter)</option>\n                        <option value=\"apple\">Apple (8cm diameter)</option>\n                        <option value=\"grapefruit\">Grapefruit (12cm diameter)</option>\n                        <option value=\"lime\">Lime (5cm diameter)</option>\n                    </optgroup>\n                    <optgroup label=\"Oval/Ellipsoidal\">\n                        <option value=\"lemon\">Lemon (6×4cm)</option>\n                        <option value=\"egg_large\">Large Egg (6×4.5cm)</option>\n                        <option value=\"egg_medium\">Medium Egg (5.5×4cm)</option>\n                        <option value=\"avocado\">Avocado (9×6cm)</option>\n                        <option value=\"kiwi\">Kiwi (6×4.5cm)</option>\n                        <option value=\"plum\">Plum (5×4cm)</option>\n                    </optgroup>\n                    <optgroup label=\"Custom\">\n                        <option value=\"custom_sphere\">Custom Sphere</option>\n                        <option value=\"custom_oval\">Custom Oval</option>\n                    </optgroup>\n                </select>\n            </div>\n            \n            <div class=\"control-group\" id=\"sphereCustomGroup\" style=\"display: none;\">\n                <label for=\"sphereDiameter\">Diameter (cm):</label>\n                <input type=\"range\" id=\"sphereDiameter\" min=\"3\" max=\"15\" step=\"0.5\" value=\"7\">\n                <div class=\"range-display\" id=\"sphereDiameterDisplay\">7 cm</div>\n            </div>\n            \n            <div class=\"control-group\" id=\"ovalCustomGroup\" style=\"display: none;\">\n                <label for=\"ovalLength\">Length (cm):</label>\n                <input type=\"range\" id=\"ovalLength\" min=\"3\" max=\"15\" step=\"0.5\" value=\"6\">\n                <div class=\"range-display\" id=\"ovalLengthDisplay\">6 cm</div>\n                \n                <label for=\"ovalWidth\">Width (cm):</label>\n                <input type=\"range\" id=\"ovalWidth\" min=\"2\" max=\"12\" step=\"0.5\" value=\"4\">\n                <div class=\"range-display\" id=\"ovalWidthDisplay\">4 cm</div>\n                \n                <label for=\"ovalHeight\">Height (cm):</label>\n                <input type=\"range\" id=\"ovalHeight\" min=\"2\" max=\"12\" step=\"0.5\" value=\"4\">\n                <div class=\"range-display\" id=\"ovalHeightDisplay\">4 cm</div>\n            </div>\n            \n            <div class=\"control-group\" id=\"orientationGroup\" style=\"display: none;\">\n                <label for=\"allowRotation\">Allow Rotation:</label>\n                <select id=\"allowRotation\">\n                    <option value=\"all\">All Orientations</option>\n                    <option value=\"horizontal_only\">Horizontal Only</option>\n                    <option value=\"vertical_only\">Vertical Only</option>\n                    <option value=\"natural\">Natural Position</option>\n                </select>\n            </div>\n            \n            <div class=\"control-group\">\n                <label for=\"boxLength\">Box Length (cm):</label>\n                <input type=\"range\" id=\"boxLength\" min=\"30\" max=\"100\" value=\"60\">\n                <div class=\"range-display\" id=\"boxLengthDisplay\">60 cm</div>\n            </div>\n            \n            <div class=\"control-group\">\n                <label for=\"boxWidth\">Box Width (cm):</label>\n                <input type=\"range\" id=\"boxWidth\" min=\"30\" max=\"80\" value=\"40\">\n                <div class=\"range-display\" id=\"boxWidthDisplay\">40 cm</div>\n            </div>\n            \n            <div class=\"control-group\">\n                <label for=\"boxHeight\">Box Height (cm):</label>\n                <input type=\"range\" id=\"boxHeight\" min=\"20\" max=\"60\" value=\"30\">\n                <div class=\"range-display\" id=\"boxHeightDisplay\">30 cm</div>\n            </div>\n            \n            <div class=\"control-group\">\n                <label for=\"colorMode\">Visualization Mode:</label>\n                <select id=\"colorMode\">\n                    <option value=\"layer\">By Layer</option>\n                    <option value=\"fruit_natural\">Natural Fruit Color</option>\n                    <option value=\"density\">By Local Density</option>\n                    <option value=\"position\">By Position</option>\n                    <option value=\"contact_points\">Contact Points</option>\n                </select>\n            </div>\n            \n            <button id=\"generateBtn\">🍊 Pack Products</button>\n            <button id=\"viewBtn\">📦 Toggle Box View</button>\n        </div>\n        \n        <div id=\"stats\">\n            <h3 style=\"margin-top: 0; color: #ffa500;\">📊 Packing Statistics</h3>\n            <div class=\"stat-row\">\n                <span class=\"stat-label\">Total Products:</span>\n                <span class=\"stat-value\" id=\"statFruits\">0</span>\n            </div>\n            <div class=\"stat-row\">\n                <span class=\"stat-label\">Layers:</span>\n                <span class=\"stat-value\" id=\"statLayers\">0</span>\n            </div>\n            <div class=\"stat-row\">\n                <span class=\"stat-label\">Packing Efficiency:</span>\n                <span class=\"stat-value\" id=\"statEfficiency\">0%</span>\n            </div>\n            <div class=\"stat-row\">\n                <span class=\"stat-label\">Volume Utilization:</span>\n                <span class=\"stat-value\" id=\"statVolumeUtil\">0%</span>\n            </div>\n            <div class=\"stat-row\">\n                <span class=\"stat-label\">Products per Layer (avg):</span>\n                <span class=\"stat-value\" id=\"statAvgPerLayer\">0</span>\n            </div>\n            <div class=\"stat-row\">\n                <span class=\"stat-label\">Wasted Space:</span>\n                <span class=\"stat-value\" id=\"statWastedSpace\">0%</span>\n            </div>\n            <div class=\"stat-row\">\n                <span class=\"stat-label\">Est. Weight (kg):</span>\n                <span class=\"stat-value\" id=\"statWeight\">0</span>\n            </div>\n        </div>\n        \n        <div id=\"loading\">📦 Optimizing product packing...</div>\n    </div>\n\n    <script>\n        class FruitPackingVisualizer {\n            constructor() {\n                this.scene = new THREE.Scene();\n                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n                this.fruits = [];\n                this.box = null;\n                this.showBox = true;\n                this.layers = [];\n                \n                this.setupRenderer();\n                this.setupCamera();\n                this.setupLights();\n                this.setupControls();\n                this.bindEvents();\n                this.updateAlgorithmDescription();\n                this.updateProductType();\n                \n                this.generatePacking();\n            }\n            \n            setupRenderer() {\n                this.renderer.setSize(window.innerWidth, window.innerHeight);\n                this.renderer.setClearColor(0x000000, 0);\n                this.renderer.shadowMap.enabled = true;\n                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n                document.getElementById('container').appendChild(this.renderer.domElement);\n            }\n            \n            setupCamera() {\n                this.camera.position.set(80, 60, 80);\n                this.camera.lookAt(0, 15, 0);\n            }\n            \n            setupLights() {\n                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);\n                this.scene.add(ambientLight);\n                \n                const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);\n                mainLight.position.set(50, 80, 50);\n                mainLight.castShadow = true;\n                mainLight.shadow.mapSize.width = 2048;\n                mainLight.shadow.mapSize.height = 2048;\n                mainLight.shadow.camera.near = 0.1;\n                mainLight.shadow.camera.far = 200;\n                mainLight.shadow.camera.left = -50;\n                mainLight.shadow.camera.right = 50;\n                mainLight.shadow.camera.top = 50;\n                mainLight.shadow.camera.bottom = -50;\n                this.scene.add(mainLight);\n                \n                const fillLight = new THREE.DirectionalLight(0xffa500, 0.3);\n                fillLight.position.set(-30, 40, -30);\n                this.scene.add(fillLight);\n                \n                const topLight = new THREE.PointLight(0xffffff, 0.5, 100);\n                topLight.position.set(0, 60, 0);\n                this.scene.add(topLight);\n            }\n            \n            setupControls() {\n                let mouseDown = false;\n                let mouseX = 0;\n                let mouseY = 0;\n                let cameraAngleX = Math.PI / 6;\n                let cameraAngleY = Math.PI / 4;\n                let cameraDistance = 120;\n                \n                this.renderer.domElement.addEventListener('mousedown', (e) => {\n                    mouseDown = true;\n                    mouseX = e.clientX;\n                    mouseY = e.clientY;\n                });\n                \n                this.renderer.domElement.addEventListener('mousemove', (e) => {\n                    if (!mouseDown) return;\n                    \n                    const deltaX = e.clientX - mouseX;\n                    const deltaY = e.clientY - mouseY;\n                    \n                    cameraAngleY += deltaX * 0.01;\n                    cameraAngleX += deltaY * 0.01;\n                    cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX));\n                    \n                    this.updateCameraPosition(cameraAngleX, cameraAngleY, cameraDistance);\n                    \n                    mouseX = e.clientX;\n                    mouseY = e.clientY;\n                });\n                \n                this.renderer.domElement.addEventListener('mouseup', () => {\n                    mouseDown = false;\n                });\n                \n                this.renderer.domElement.addEventListener('wheel', (e) => {\n                    cameraDistance += e.deltaY * 0.1;\n                    cameraDistance = Math.max(30, Math.min(200, cameraDistance));\n                    this.updateCameraPosition(cameraAngleX, cameraAngleY, cameraDistance);\n                });\n            }\n            \n            updateCameraPosition(angleX, angleY, distance) {\n                this.camera.position.x = distance * Math.cos(angleX) * Math.sin(angleY);\n                this.camera.position.y = distance * Math.sin(angleX);\n                this.camera.position.z = distance * Math.cos(angleX) * Math.cos(angleY);\n                this.camera.lookAt(0, 15, 0);\n            }\n            \n            bindEvents() {\n                document.getElementById('generateBtn').addEventListener('click', () => this.generatePacking());\n                document.getElementById('viewBtn').addEventListener('click', () => this.toggleBoxView());\n                \n                ['boxLength', 'boxWidth', 'boxHeight', 'sphereDiameter', 'ovalLength', 'ovalWidth', 'ovalHeight'].forEach(id => {\n                    const element = document.getElementById(id);\n                    if (element) {\n                        element.addEventListener('input', () => {\n                            document.getElementById(id + 'Display').textContent = element.value + ' cm';\n                        });\n                    }\n                });\n                \n                document.getElementById('productType').addEventListener('change', () => {\n                    this.updateProductType();\n                });\n                \n                document.getElementById('algorithm').addEventListener('change', () => {\n                    this.updateAlgorithmDescription();\n                });\n                \n                window.addEventListener('resize', () => this.onWindowResize());\n            }\n            \n            updateAlgorithmDescription() {\n                const descriptions = {\n                    'layered_hexagonal': 'Industry standard for spherical fruits - optimal space utilization',\n                    'layered_square': 'Simple grid pattern, easy for manual packing',\n                    'pyramid_stacking': 'Triangular layers for spheres - maximum stability',\n                    'offset_layers': 'Alternating offset for better interlocking',\n                    'tight_hexagonal': 'Maximum density hexagonal for spheres',\n                    'brick_pattern': 'Staggered like bricks for good stability',\n                    'tetrahedral': 'Natural sphere packing arrangement',\n                    'corner_fill': 'Fill corners first, then work inward',\n                    'dense_random': 'Random placement with high density',\n                    'oval_nested': 'Ovals nest together in alternating orientations',\n                    'oval_aligned': 'All ovals aligned in same direction for easy access',\n                    'oval_egg_crate': 'Like egg cartons - ovals in protective depressions',\n                    'oval_honeycomb': 'Hexagonal pattern adapted for oval shapes'\n                };\n                \n                const algorithm = document.getElementById('algorithm').value;\n                document.getElementById('algorithmDesc').textContent = descriptions[algorithm];\n            }\n            \n            updateProductType() {\n                const productType = document.getElementById('productType').value;\n                const sphereCustomGroup = document.getElementById('sphereCustomGroup');\n                const ovalCustomGroup = document.getElementById('ovalCustomGroup');\n                const orientationGroup = document.getElementById('orientationGroup');\n                \n                sphereCustomGroup.style.display = 'none';\n                ovalCustomGroup.style.display = 'none';\n                orientationGroup.style.display = 'none';\n                \n                const ovalProducts = ['lemon', 'egg_large', 'egg_medium', 'avocado', 'kiwi', 'plum', 'custom_oval'];\n                if (ovalProducts.includes(productType)) {\n                    orientationGroup.style.display = 'block';\n                }\n                \n                if (productType === 'custom_sphere') {\n                    sphereCustomGroup.style.display = 'block';\n                } else if (productType === 'custom_oval') {\n                    ovalCustomGroup.style.display = 'block';\n                    orientationGroup.style.display = 'block';\n                }\n            }\n            \n            onWindowResize() {\n                this.camera.aspect = window.innerWidth / window.innerHeight;\n                this.camera.updateProjectionMatrix();\n                this.renderer.setSize(window.innerWidth, window.innerHeight);\n            }\n            \n            clearScene() {\n                this.fruits.forEach(fruit => {\n                    this.scene.remove(fruit);\n                    if (fruit.geometry) fruit.geometry.dispose();\n                    if (fruit.material) fruit.material.dispose();\n                });\n                this.fruits = [];\n                this.layers = [];\n                \n                if (this.box) {\n                    this.scene.remove(this.box);\n                }\n            }\n            \n            createBox(length, width, height) {\n                const group = new THREE.Group();\n                \n                const floorGeometry = new THREE.PlaneGeometry(length, width);\n                const floorMaterial = new THREE.MeshLambertMaterial({ \n                    color: 0x8B4513, \n                    side: THREE.DoubleSide \n                });\n                const floor = new THREE.Mesh(floorGeometry, floorMaterial);\n                floor.rotation.x = -Math.PI / 2;\n                floor.position.y = 0;\n                floor.receiveShadow = true;\n                group.add(floor);\n                \n                const boxGeometry = new THREE.BoxGeometry(length, height, width);\n                const edges = new THREE.EdgesGeometry(boxGeometry);\n                const lineMaterial = new THREE.LineBasicMaterial({ \n                    color: 0x8B4513, \n                    linewidth: 2 \n                });\n                const wireframe = new THREE.LineSegments(edges, lineMaterial);\n                wireframe.position.y = height / 2;\n                group.add(wireframe);\n                \n                const wallMaterial = new THREE.MeshLambertMaterial({ \n                    color: 0x8B4513, \n                    transparent: true, \n                    opacity: 0.1 \n                });\n                const walls = new THREE.Mesh(boxGeometry, wallMaterial);\n                walls.position.y = height / 2;\n                group.add(walls);\n                \n                return group;\n            }\n            \n            async generatePacking() {\n                document.getElementById('loading').style.display = 'block';\n                await new Promise(resolve => setTimeout(resolve, 100));\n                \n                this.clearScene();\n                \n                const algorithm = document.getElementById('algorithm').value;\n                const productType = document.getElementById('productType').value;\n                \n                const productInfo = this.getProductDimensions(productType);\n                const boxLength = parseFloat(document.getElementById('boxLength').value);\n                const boxWidth = parseFloat(document.getElementById('boxWidth').value);\n                const boxHeight = parseFloat(document.getElementById('boxHeight').value);\n                const colorMode = document.getElementById('colorMode').value;\n                \n                this.box = this.createBox(boxLength, boxWidth, boxHeight);\n                this.scene.add(this.box);\n                \n                let positions = [];\n                \n                if (productInfo.isSpherical) {\n                    switch (algorithm) {\n                        case 'layered_hexagonal':\n                            positions = this.generateLayeredHexagonal(productInfo.radius, boxLength, boxWidth, boxHeight);\n                            break;\n                        case 'layered_square':\n                            positions = this.generateLayeredSquare(productInfo.radius, boxLength, boxWidth, boxHeight);\n                            break;\n                        default:\n                            positions = this.generateLayeredHexagonal(productInfo.radius, boxLength, boxWidth, boxHeight);\n                    }\n                } else {\n                    switch (algorithm) {\n                        case 'oval_nested':\n                            positions = this.generateOvalNested(productInfo, boxLength, boxWidth, boxHeight);\n                            break;\n                        case 'oval_aligned':\n                            positions = this.generateOvalAligned(productInfo, boxLength, boxWidth, boxHeight);\n                            break;\n                        case 'oval_egg_crate':\n                            positions = this.generateOvalEggCrate(productInfo, boxLength, boxWidth, boxHeight);\n                            break;\n                        case 'oval_honeycomb':\n                            positions = this.generateOvalHoneycomb(productInfo, boxLength, boxWidth, boxHeight);\n                            break;\n                        default:\n                            positions = this.generateOvalAligned(productInfo, boxLength, boxWidth, boxHeight);\n                    }\n                }\n                \n                this.createProducts(positions, productInfo, colorMode, productType);\n                this.updateStatistics(positions, productInfo, boxLength, boxWidth, boxHeight, productType);\n                \n                document.getElementById('loading').style.display = 'none';\n            }\n            \n            getProductDimensions(productType) {\n                const productData = {\n                    'orange': { isSpherical: true, radius: 3.5, color: 0xFFA500, weight: 0.15 },\n                    'apple': { isSpherical: true, radius: 4, color: 0xFF6B6B, weight: 0.18 },\n                    'grapefruit': { isSpherical: true, radius: 6, color: 0xFFD700, weight: 0.4 },\n                    'lime': { isSpherical: true, radius: 2.5, color: 0x32CD32, weight: 0.06 },\n                    'lemon': { isSpherical: false, length: 6, width: 4, height: 4, color: 0xFFFF00, weight: 0.08 },\n                    'egg_large': { isSpherical: false, length: 6, width: 4.5, height: 4.5, color: 0xFFF8DC, weight: 0.06 },\n                    'egg_medium': { isSpherical: false, length: 5.5, width: 4, height: 4, color: 0xFFF8DC, weight: 0.05 },\n                    'avocado': { isSpherical: false, length: 9, width: 6, height: 6, color: 0x568203, weight: 0.2 },\n                    'kiwi': { isSpherical: false, length: 6, width: 4.5, height: 4.5, color: 0x8B4513, weight: 0.07 },\n                    'plum': { isSpherical: false, length: 5, width: 4, height: 4, color: 0x8B008B, weight: 0.065 }\n                };\n                \n                if (productType === 'custom_sphere') {\n                    const diameter = parseFloat(document.getElementById('sphereDiameter').value);\n                    return { isSpherical: true, radius: diameter / 2, color: 0xFFA500, weight: 0.15 };\n                } else if (productType === 'custom_oval') {\n                    return {\n                        isSpherical: false,\n                        length: parseFloat(document.getElementById('ovalLength').value),\n                        width: parseFloat(document.getElementById('ovalWidth').value),\n                        height: parseFloat(document.getElementById('ovalHeight').value),\n                        color: 0xFFA500,\n                        weight: 0.15\n                    };\n                }\n                \n                return productData[productType] || productData['orange'];\n            }\n            \n            generateLayeredHexagonal(radius, length, width, height) {\n                const positions = [];\n                this.layers = [];\n                \n                const spacing = radius * 2;\n                const hexSpacing = spacing * Math.sqrt(3) / 2;\n                const layerHeight = spacing;\n                \n                let layer = 0;\n                for (let y = radius; y + radius <= height; y += layerHeight) {\n                    const layerPositions = [];\n                    const isEvenLayer = layer % 2 === 0;\n                    \n                    for (let x = -length/2 + radius; x + radius <= length/2; x += hexSpacing) {\n                        for (let z = -width/2 + radius; z + radius <= width/2; z += spacing) {\n                            let posX = x;\n                            let posZ = z;\n                            \n                            if (Math.floor((z + width/2) / spacing) % 2 === 1) {\n                                posX += hexSpacing / 2;\n                            }\n                            \n                            if (!isEvenLayer) {\n                                posX += hexSpacing / 2;\n                                posZ += spacing / 2;\n                            }\n                            \n                            if (Math.abs(posX) <= length/2 - radius && Math.abs(posZ) <= width/2 - radius) {\n                                const pos = new THREE.Vector3(posX, y, posZ);\n                                pos.layer = layer;\n                                positions.push(pos);\n                                layerPositions.push(pos);\n                            }\n                        }\n                    }\n                    \n                    this.layers.push(layerPositions);\n                    layer++;\n                }\n                \n                return positions;\n            }\n            \n            generateLayeredSquare(radius, length, width, height) {\n                const positions = [];\n                this.layers = [];\n                \n                const spacing = radius * 2;\n                const layerHeight = spacing;\n                \n                let layer = 0;\n                for (let y = radius; y + radius <= height; y += layerHeight) {\n                    const layerPositions = [];\n                    \n                    for (let x = -length/2 + radius; x + radius <= length/2; x += spacing) {\n                        for (let z = -width/2 + radius; z + radius <= width/2; z += spacing) {\n                            const pos = new THREE.Vector3(x, y, z);\n                            pos.layer = layer;\n                            positions.push(pos);\n                            layerPositions.push(pos);\n                        }\n                    }\n                    \n                    this.layers.push(layerPositions);\n                    layer++;\n                }\n                \n                return positions;\n            }\n            \n            generateOvalNested(productInfo, length, width, height) {\n                const positions = [];\n                this.layers = [];\n                \n                const { length: pLength, width: pWidth, height: pHeight } = productInfo;\n                const allowRotation = document.getElementById('allowRotation') ? document.getElementById('allowRotation').value : 'all';\n                \n                const spacingX = pLength * 1.1;\n                const spacingZ = pWidth * 1.1;\n                const layerHeight = pHeight * 1.1;\n                \n                let layer = 0;\n                for (let y = pHeight / 2; y + pHeight / 2 <= height; y += layerHeight) {\n                    const layerPositions = [];\n                    const isEvenLayer = layer % 2 === 0;\n                    \n                    for (let x = -length/2 + pLength/2; x + pLength/2 <= length/2; x += spacingX) {\n                        for (let z = -width/2 + pWidth/2; z + pWidth/2 <= width/2; z += spacingZ) {\n                            let posX = x;\n                            let posZ = z;\n                            let rotation = { x: 0, y: 0, z: 0 };\n                            \n                            // Nest alternating layers and rows\n                            if (!isEvenLayer) {\n                                posX += spacingX / 2;\n                                posZ += spacingZ / 2;\n                                if (allowRotation === 'all') {\n                                    rotation.y = Math.PI / 2; // 90-degree rotation\n                                }\n                            }\n                            \n                            // Alternate every other product in the row for better nesting\n                            const rowIndex = Math.floor((z + width/2) / spacingZ);\n                            if (rowIndex % 2 === 1 && allowRotation !== 'vertical_only') {\n                                rotation.y += Math.PI / 4; // Additional 45-degree rotation\n                            }\n                            \n                            if (Math.abs(posX) <= length/2 - pLength/2 && Math.abs(posZ) <= width/2 - pWidth/2) {\n                                const pos = new THREE.Vector3(posX, y, posZ);\n                                pos.layer = layer;\n                                pos.rotation = rotation;\n                                pos.dimensions = { length: pLength, width: pWidth, height: pHeight };\n                                positions.push(pos);\n                                layerPositions.push(pos);\n                            }\n                        }\n                    }\n                    \n                    this.layers.push(layerPositions);\n                    layer++;\n                }\n                \n                return positions;\n            }\n            \n            generateOvalAligned(productInfo, length, width, height) {\n                const positions = [];\n                this.layers = [];\n                \n                const { length: pLength, width: pWidth, height: pHeight } = productInfo;\n                const allowRotation = document.getElementById('allowRotation') ? document.getElementById('allowRotation').value : 'natural';\n                \n                const spacingX = pLength * 1.05;\n                const spacingZ = pWidth * 1.05;\n                const layerHeight = pHeight * 1.05;\n                \n                let layer = 0;\n                for (let y = pHeight / 2; y + pHeight / 2 <= height; y += layerHeight) {\n                    const layerPositions = [];\n                    \n                    for (let x = -length/2 + pLength/2; x + pLength/2 <= length/2; x += spacingX) {\n                        for (let z = -width/2 + pWidth/2; z + pWidth/2 <= width/2; z += spacingZ) {\n                            let rotation = { x: 0, y: 0, z: 0 };\n                            \n                            // Set orientation based on allowRotation setting\n                            if (allowRotation === 'vertical_only') {\n                                rotation.z = Math.PI / 2; // Stand upright\n                            } else if (allowRotation === 'natural') {\n                                // Natural position (e.g., eggs pointed up slightly)\n                                rotation.x = Math.PI / 12; // 15-degree tilt\n                            }\n                            \n                            const pos = new THREE.Vector3(x, y, z);\n                            pos.layer = layer;\n                            pos.rotation = rotation;\n                            pos.dimensions = { length: pLength, width: pWidth, height: pHeight };\n                            positions.push(pos);\n                            layerPositions.push(pos);\n                        }\n                    }\n                    \n                    this.layers.push(layerPositions);\n                    layer++;\n                }\n                \n                return positions;\n            }\n            \n            generateOvalEggCrate(productInfo, length, width, height) {\n                const positions = [];\n                this.layers = [];\n                \n                const { length: pLength, width: pWidth, height: pHeight } = productInfo;\n                \n                // Create depressions like egg cartons\n                const crateSpacingX = pLength * 1.2;\n                const crateSpacingZ = pWidth * 1.2;\n                const layerHeight = pHeight * 1.3; // Extra space for crate structure\n                \n                let layer = 0;\n                for (let y = pHeight / 2; y + pHeight / 2 <= height; y += layerHeight) {\n                    const layerPositions = [];\n                    \n                    for (let x = -length/2 + pLength/2; x + pLength/2 <= length/2; x += crateSpacingX) {\n                        for (let z = -width/2 + pWidth/2; z + pWidth/2 <= width/2; z += crateSpacingZ) {\n                            let rotation = { x: 0, y: 0, z: 0 };\n                            \n                            // Slight upward tilt for stability (like real egg cartons)\n                            rotation.x = Math.PI / 24; // 7.5-degree tilt\n                            \n                            // Alternate orientations for better fit\n                            const rowIndex = Math.floor((z + width/2) / crateSpacingZ);\n                            if (rowIndex % 2 === 1) {\n                                rotation.y = Math.PI; // 180-degree turn\n                            }\n                            \n                            const pos = new THREE.Vector3(x, y, z);\n                            pos.layer = layer;\n                            pos.rotation = rotation;\n                            pos.dimensions = { length: pLength, width: pWidth, height: pHeight };\n                            positions.push(pos);\n                            layerPositions.push(pos);\n                        }\n                    }\n                    \n                    this.layers.push(layerPositions);\n                    layer++;\n                }\n                \n                return positions;\n            }\n            \n            generateOvalHoneycomb(productInfo, length, width, height) {\n                const positions = [];\n                this.layers = [];\n                \n                const { length: pLength, width: pWidth, height: pHeight } = productInfo;\n                const allowRotation = document.getElementById('allowRotation') ? document.getElementById('allowRotation').value : 'all';\n                \n                const spacingX = pLength * 0.9;\n                const spacingZ = pWidth * Math.sqrt(3) / 2;\n                const layerHeight = pHeight * 1.1;\n                \n                let layer = 0;\n                for (let y = pHeight / 2; y + pHeight / 2 <= height; y += layerHeight) {\n                    const layerPositions = [];\n                    \n                    for (let x = -length/2 + pLength/2; x + pLength/2 <= length/2; x += spacingX) {\n                        for (let z = -width/2 + pWidth/2; z + pWidth/2 <= width/2; z += spacingZ) {\n                            let posX = x;\n                            let posZ = z;\n                            let rotation = { x: 0, y: 0, z: 0 };\n                            \n                            // Hexagonal offset\n                            const rowIndex = Math.floor((z + width/2) / spacingZ);\n                            if (rowIndex % 2 === 1) {\n                                posX += spacingX / 2;\n                            }\n                            \n                            // Rotate products to fit hexagonal pattern better\n                            if (allowRotation === 'all') {\n                                const hexRotation = (rowIndex % 3) * Math.PI / 3; // 60-degree increments\n                                rotation.y = hexRotation;\n                            }\n                            \n                            // Layer offset for better interlocking\n                            if (layer % 2 === 1) {\n                                posX += spacingX / 3;\n                                posZ += spacingZ / 3;\n                                if (allowRotation === 'all') {\n                                    rotation.y += Math.PI / 6; // Additional 30-degree rotation\n                                }\n                            }\n                            \n                            if (Math.abs(posX) <= length/2 - pLength/2 && Math.abs(posZ) <= width/2 - pWidth/2) {\n                                const pos = new THREE.Vector3(posX, y, posZ);\n                                pos.layer = layer;\n                                pos.rotation = rotation;\n                                pos.dimensions = { length: pLength, width: pWidth, height: pHeight };\n                                positions.push(pos);\n                                layerPositions.push(pos);\n                            }\n                        }\n                    }\n                    \n                    this.layers.push(layerPositions);\n                    layer++;\n                }\n                \n                return positions;\n            }\n            \n            createProducts(positions, productInfo, colorMode, productType) {\n                const baseColor = productInfo.color;\n                \n                positions.forEach((position, index) => {\n                    let color;\n                    \n                    switch (colorMode) {\n                        case 'layer':\n                            const layerRatio = position.layer / (this.layers.length - 1 || 1);\n                            color = new THREE.Color().setHSL(0.1 + layerRatio * 0.6, 0.8, 0.6);\n                            break;\n                        case 'fruit_natural':\n                            const hsl = new THREE.Color(baseColor).getHSL({});\n                            color = new THREE.Color().setHSL(\n                                hsl.h + (Math.random() - 0.5) * 0.05,\n                                hsl.s + (Math.random() - 0.5) * 0.1,\n                                hsl.l + (Math.random() - 0.5) * 0.1\n                            );\n                            break;\n                        default:\n                            color = new THREE.Color(baseColor);\n                    }\n                    \n                    const material = new THREE.MeshLambertMaterial({ \n                        color: color,\n                        transparent: false\n                    });\n                    \n                    let geometry;\n                    if (productInfo.isSpherical) {\n                        geometry = new THREE.SphereGeometry(productInfo.radius, 16, 12);\n                    } else {\n                        geometry = new THREE.SphereGeometry(1, 16, 12);\n                        geometry.scale(\n                            productInfo.length / 2,\n                            productInfo.height / 2,\n                            productInfo.width / 2\n                        );\n                    }\n                    \n                    const product = new THREE.Mesh(geometry, material);\n                    product.position.copy(position);\n                    \n                    if (position.rotation) {\n                        product.rotation.set(position.rotation.x, position.rotation.y, position.rotation.z);\n                    }\n                    \n                    product.castShadow = true;\n                    product.receiveShadow = true;\n                    \n                    const scaleVariation = 0.95 + Math.random() * 0.1;\n                    product.scale.multiplyScalar(scaleVariation);\n                    \n                    this.scene.add(product);\n                    this.fruits.push(product);\n                });\n            }\n            \n            updateStatistics(positions, productInfo, boxLength, boxWidth, boxHeight, productType) {\n                const productCount = positions.length;\n                const layerCount = this.layers.length;\n                \n                let productVolume;\n                if (productInfo.isSpherical) {\n                    productVolume = (4/3) * Math.PI * Math.pow(productInfo.radius, 3);\n                } else {\n                    productVolume = (4/3) * Math.PI * (productInfo.length/2) * (productInfo.width/2) * (productInfo.height/2);\n                }\n                \n                const totalProductVolume = productVolume * productCount;\n                const boxVolume = boxLength * boxWidth * boxHeight;\n                const volumeUtilization = (totalProductVolume / boxVolume) * 100;\n                \n                // Calculate theoretical maximum for different shapes and algorithms\n                const algorithm = document.getElementById('algorithm').value;\n                const theoreticalMax = {\n                    // Spherical algorithms\n                    'layered_hexagonal': 74,\n                    'layered_square': 52,\n                    'pyramid_stacking': 70,\n                    'offset_layers': 68,\n                    'tight_hexagonal': 74,\n                    'brick_pattern': 65,\n                    'tetrahedral': 74,\n                    'corner_fill': 55,\n                    'dense_random': 64,\n                    // Oval/ellipsoidal algorithms\n                    'oval_nested': 82,        // Ovals can nest better than spheres\n                    'oval_aligned': 75,       // Good efficiency when aligned\n                    'oval_egg_crate': 78,     // Egg crate pattern is quite efficient\n                    'oval_honeycomb': 85      // Best for oval shapes\n                };\n                \n                const efficiency = Math.min((volumeUtilization / (theoreticalMax[algorithm] || 74)) * 100, 100);\n                const wastedSpace = 100 - volumeUtilization;\n                const avgPerLayer = layerCount > 0 ? (productCount / layerCount).toFixed(1) : 0;\n                const estimatedWeight = (productCount * productInfo.weight).toFixed(1);\n                \n                document.getElementById('statFruits').textContent = productCount;\n                document.getElementById('statLayers').textContent = layerCount;\n                document.getElementById('statEfficiency').textContent = efficiency.toFixed(1) + '%';\n                document.getElementById('statVolumeUtil').textContent = volumeUtilization.toFixed(1) + '%';\n                document.getElementById('statAvgPerLayer').textContent = avgPerLayer;\n                document.getElementById('statWastedSpace').textContent = wastedSpace.toFixed(1) + '%';\n                document.getElementById('statWeight').textContent = estimatedWeight;\n            }\n            \n            toggleBoxView() {\n                this.showBox = !this.showBox;\n                if (this.box) {\n                    this.box.visible = this.showBox;\n                }\n                \n                const button = document.getElementById('viewBtn');\n                button.textContent = this.showBox ? '📦 Hide Box' : '📦 Show Box';\n            }\n            \n            render() {\n                this.renderer.render(this.scene, this.camera);\n                requestAnimationFrame(() => this.render());\n            }\n        }\n        \n        window.addEventListener('load', () => {\n            const visualizer = new FruitPackingVisualizer();\n            visualizer.render();\n        });\n    </script>\n</body>\n</html>",
  "id": "sphere-packing-viz-claude-4",
  "metadata": {
    "prompt": "Imported from one-page directory",
    "tags": [
      "Three.js",
      "3D Graphics",
      "Animation",
      "WebGL",
      "Shaders",
      "Astronomy",
      "Architecture"
    ],
    "timestamp": "2025-08-04T21:59:57.749Z",
    "model": "claude-4",
    "description": "An interactive 3D visualization built with Three.js featuring three.js, 3d graphics, animation, webgl, shaders, astronomy, architecture."
  }
}
